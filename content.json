{"meta":{"title":"learner'blog","subtitle":null,"description":"花无凋零之日，意无传递之时 。爱情亘古不变，紫罗兰与世长存","author":"learner","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2024-03-27T13:00:23.062Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"learner && 淡燃 与&nbsp; learner &nbsp; （ ） 对话中... bot_ui_ini()","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2024-03-28T05:17:22.095Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题 balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2024-03-08T05:20:00.000Z","updated":"2024-03-28T09:14:13.613Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"我喜欢的音乐"},{"title":"theme-sakura","date":"2023-03-23T07:08:00.000Z","updated":"2024-03-27T12:41:19.615Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)，感谢原作者[Mashiro](https://2heng.xin/)","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2024-04-02T13:02:55.000Z","updated":"2024-04-02T13:03:05.947Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2024-03-27T13:54:28.646Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 回忆 故事的开始 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"cmake","slug":"19","date":"2024-06-10T07:58:55.435Z","updated":"2024-06-10T08:04:23.383Z","comments":true,"path":"2024/06/10/19/","link":"","permalink":"/2024/06/10/19/","excerpt":"","text":"cmake使用 1.创建 CMakeLists.txt 文件并进行编辑 2.使用 cmake \\ . 命令，. 指的是当前文件夹，生成 Makefile 文件 3.使用 make 命令生成可执行文件 CMakeLists.txt 语法 版本 cmake_minimum_required(VERSION 3.10)** 指定最低 cmake 版本 PROJECT 关键字 用来指定工程的名字和支持的语言 PROJECT(HELLO)​ 工程名为 ​HELLO​，默认支持所有语言 PROJECT(HELLO CXX)​ 工程名为 ​HELLO​，支持语言 CXX PROJECT(HELLO CXX C JAVA)​ 多种语言用空格或分号隔开 该指定隐式定义了两个 CMAKE 变量 _BINARY_DIR，比如 HELLO _BINARY_DIR，也可以直接简化使用 PROJECT _BINARY_DIR 来表示，这是编译路径 _SOURCE_DIR，比如 HELLO _SOURCE_DIR，也可以直接简化使用 PROJECT _SOURCE_DIR 来表示，这是工程路径 在 MESSAGE 关键字中可以直接使用这两个变量，指向当前的工作目录 SET 关键字 用来指定变量，默认都是字符串类型 SET(SRC_LIST main.cpp)​ 其中​ SRC_LIST ​变量包含 ​main.cpp​ SET(SRC_LIST a.cpp b.cpp c.cpp)​ SET(CMAKE_CXX_STANDARD 11) 指定c++版本为 11，CMAKE_CXX_STANDARD是宏不是变量 MESSAGE 关键字 用来在终端输出信息 主要包含三种信息： SEND_ERROR​，产生错误，生成过程被跳过 STAUS，输出前缀为 – 的信息 FATAL_ERROR ，立即终止所有 cmake 过程 ADD_EXECUTABLE 关键字 生成可执行文件 ADD_EXECUTABLE(hello\\ \\{SRC_LIST}) 生成的可执行文件名为 hello ，源文件读取变量 SRC_LIST 中的内容 也可以直接写成 ADD_EXECUTABLE(hello\\ \\{SRC_LIST}) 文件搜索 file(GLOB/GLOB_RECURSE 变量名 文件路径和类型) 第一个参数指定如何搜索，GLOB表示当前文件下搜索，GLOB_RECURSE表示递归搜索 例：file(GLOB MAIN_SRC /src/*.cpp) 指定头文件路径 INCLUDE_DIRECTORIES(path) path 为头文件路径 宏定义 add_definitions(-D宏名称 …) add_definitions(-D宏名称=100) 使用 = 来进行宏的初始化 内部构建和外部构建 内部构建：直接构建，因为文件多导致不整洁 外部构建：在 CMakeFile.txt 所在目录创建一个 build 文件夹，在 build 目录下使用 cmake \\ … 命令，构建后的文件都会放在 build 文件夹下，此时编译路径为 ./build 而工程路径为 build 所在路径 规范 添加一个子目录 src ，用来放置工程源代码 添加一个子目录 doc，用来放置工程文档 工程目录下添加 runhello.sh，运行二进制文件的脚本 工程目录下添加文本文件 COPYRIGHT，README 将构建后的目标文件放入构建目录的 bin 子目录 工程目录 . ├── build ├── CMakeLists.txt └── src ├── CMakeLists.txt └── main.cpp 工程目录下的 CMakeLists.txt PROJECT(HELLO) ADD_SUBDIRECTORY(src bin) src 下的 CMakeLists.txt ADD_EXECUTABLE(hello main.cpp) ADD_SUBDIRECTORY ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于想当前工程添加存放源文件的子目录，并可以指定二进制文件存放位置。ADD_SUBDIRECTORY(src bin) 生成的二进制文件在 /build/bin下，ADD_SUBDIRECTORY(src)生成的二进制文件在 /build/src 下 EXCLUDE_FROM_ALL 函数禁止该子目录下的目标被默认构建，和直接不写ADD_SUBDIRECTORY效果相同 静态库和动态库的构建 静态库文件后缀 .a，windows下是 .lib 动态库文件后缀 .so，windows下是 .dll 指定头文件路径 include_directories(path) 生成库 ADD_LIBRARY(库名称 STATIC 源文件) ADD_LIBRARY(库名称 SHARE 源文件) 指定生成路径 SET(LIBRARY_OUTPUT_PATH path) 全局链接库 link_libraries(库1 库2 …) 后续所有目标都会链接这些库 指定库路径 link_directories(path1 path2 …) 系统的库只需要名字就可以找到 自定义的库则还需要指定路径 指定链接库 target_link_libraries(target 权限1 库1 权限2 库2…) target 指定要加载库的文件名，可以为源文件、动态库文件、可执行文件。 权限：PRIVATE、PUBLIC、INTERFACE 默认权限是 PUBLIC target_link_libraries(B 权限 C) target_link_libraries(A B) 若权限为 PUBLIC，则 A 中能调用 C 中的函数 若权限为 PRIVETE，则 A 中不能调用 C 中的函数 target_link_libraries(B 权限 C 权限 D) target_link_libraries(A B) 若权限为 INTERFACE，则 A 中不能调用 C、D中的函数，B 中可以调用但不知道函数来自于 C 还是 D。也就是说 C、D不会被链接到 B，只会导出符号(符号就是函数)。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"/tags/cmake/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"字符串","slug":"11","date":"2024-06-04T07:54:55.449Z","updated":"2024-06-04T08:06:05.634Z","comments":true,"path":"2024/06/04/11/","link":"","permalink":"/2024/06/04/11/","excerpt":"","text":"KMP $\\pi[i]$ 为 $s[0…i]$ 的前缀函数( 最长的相等的真前缀(不能是 $s$ 本身)与真后缀的长度 ) int pi[N]; void getPi(string s) // s 下标从 0 开始 { int n = s.size(); for (int i = 1; i &lt; n; i++) { int j = pi[i - 1]; while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } } vector&lt;int&gt; kmp(string t, string s) // 返回 s 在 t 中的起点位置，pi 数组记得来 s+t+1 的大小 { string cur = s + '#' + t; int sz1 = t.size(), sz2 = s.size(); getPi(cur); vector&lt;int&gt; v; for (int i = sz2 + 1; i &lt;= sz1 + sz2; i++) if (pi[i] == sz2) v.push_back(i - 2 * sz2); return v; } 前缀函数应用 字符串周期(循环节) 若 $s$ 有长度为 $r$ 的前缀和长度为 $r$ 的后缀相等，则称 $s$ 有长度为 $r(0 \\leq r &lt; |s|)$ 的 $border$ $n - \\pi[n-1]、n-\\pi[\\pi[n-1]-1]…$ 是 $s$ 的周期的 $border$ 长度 $n - \\pi[n-1]$ 是 $s$ 的最小周期 例如 $abaaa$ 的最小周期是 $abaa $ 统计 $s$ 的每个前缀的出现次数 $s$ 的前缀在 $s$ 中的出现次数 vector&lt;int&gt; ans(n + 1); for (int i = 0; i &lt; n; i++) ans[pi[i]]++; for (int i = n - 1; i &gt; 0; i--) ans[pi[i - 1]] += ans[i];//长度为 i 的前缀将处于自己后缀的答案转移给处于自己的前缀 for (int i = 0; i &lt;= n; i++) ans[i]++;//前缀本身的答案 $s$ 的前缀在 $t$ 中的出现次数 与上述问题相同，但现在只需关注 $i \\geq n+1$ 的 $\\pi[i]$ ，也不需要加前缀本身的答案 一个字符串中本质不同的字串个数 扩展kmp $z[i]$ 为 $s[i,n-1]$ 和 $s$ 的最长公共前缀，$z[0]=0$ #include&lt;bits/stdc++.h&gt;//求字符串 b 的 z 函数, 和 b 与 a 的每个后缀的LCP长度 #define ll long long //(a + '#' + b) 可求 a 在 b 中的出现位置 using namespace std; vector&lt;int&gt; getZ(string s) { int n = s.size(); vector&lt;int&gt; z(n); for (int i = 1, l = 0, r = 0; i &lt; n; ++i) { if (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + 1) { z[i] = z[i - l]; } else { z[i] = max(0, r - i + 1); while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i]; } if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; } return z; } #define int ll signed main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string a, b; cin &gt;&gt; a &gt;&gt; b; auto t = getZ(b); t[0] = t.size(); int ans = 0; for(int i = 0; i &lt; t.size(); i++) ans = ans ^ ((i + 1) * (t[i] + 1)); cout &lt;&lt; ans &lt;&lt; '\\n'; t = getZ(b + &quot;#&quot; + a); ans = 0; for(int i = b.size() + 1; i &lt; t.size(); i++) ans = ans ^ ((i - b.size()) * (t[i] + 1)); cout &lt;&lt; ans &lt;&lt; '\\n'; } AC自动机 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 10; struct node{ int alp[26], end, fail; string s; int cnt, id; }tree[150 * 70 + 10]; int tot; void insert(string s, int id)//注意字母是否是小写，记得build { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp]) tree[p].alp[temp] = ++tot; p = tree[p].alp[temp]; } tree[p].end++; tree[p].s = s; tree[p].id = id; } void build() { queue&lt;int&gt; que; for(int i = 0; i &lt; 26; i++) if(tree[0].alp[i]) que.push(tree[0].alp[i]); while(que.size()) { int u = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) { if(tree[u].alp[i]) { tree[tree[u].alp[i]].fail = tree[tree[u].fail].alp[i]; // fail数组：同一字符可以匹配的其他位置 que.push(tree[u].alp[i]); } else tree[u].alp[i] = tree[tree[u].fail].alp[i]; } } } void query(string t) { int u = 0; for (int i = 0; i &lt; t.size(); i++) { u = tree[u].alp[t[i] - 'a']; // 转移 for (int j = u; j; j = tree[j].fail) tree[j].cnt += tree[j].end; } } void solve() { int n; while(cin &gt;&gt; n, n) { for(int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; insert(s, i); } build(); string t; cin &gt;&gt; t; query(t); vector&lt;pair&lt;int, pair&lt;int, string&gt;&gt;&gt; v; for(int i = 0; i &lt;= tot; i++) if(tree[i].cnt) v.push_back({tree[i].cnt, {-tree[i].id, tree[i].s}}); sort(v.begin(), v.end(), greater&lt;pair&lt;int, pair&lt;int, string&gt;&gt;&gt;()); if(v.empty()) cout &lt;&lt; 0 &lt;&lt; '\\n'; else { cout &lt;&lt; v[0].first &lt;&lt; '\\n'; for(auto &amp;[cnt, it] : v) if(cnt == v[0].first) cout &lt;&lt; it.second &lt;&lt; '\\n'; } for(int i = 0; i &lt;= tot; i++) { for(int j = 0; j &lt; 26; j++) tree[i].alp[j] = 0; tree[i].cnt = tree[i].fail = tree[i].end = 0; } tot = 0; } } signed main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t = 1; // cin &gt;&gt; t; while (t--) solve(); return 0; } #include &lt;bits/stdc++.h&gt;// fail树优化，求每个模式串在文本串中出现了多少次 using namespace std; const int N = 2e5 + 10; int ans[N]; struct AC{//注意字母是否是小写，记得build struct node{ int alp[26], fail; int cnt; vector&lt;int&gt; id; }tree[N]; int tot; vector&lt;int&gt; g[N]; void insert(string s, int id) { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp]) tree[p].alp[temp] = ++tot; p = tree[p].alp[temp]; } tree[p].id.push_back(id); } void build() { queue&lt;int&gt; que; for(int i = 0; i &lt; 26; i++) if(tree[0].alp[i]) que.push(tree[0].alp[i]); while(que.size()) { int u = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) { if(tree[u].alp[i]) { tree[tree[u].alp[i]].fail = tree[tree[u].fail].alp[i]; // fail数组：同一字符可以匹配的其他位置 que.push(tree[u].alp[i]); } else tree[u].alp[i] = tree[tree[u].fail].alp[i];//直接到可匹配处 } } } void query(string t) { int u = 0; for (int i = 0; i &lt; t.size(); i++) { u = tree[u].alp[t[i] - 'a'];// u 在原字典树中可能不存在，但字典树结构已经改变，会直接指向下一个匹配点 tree[u].cnt++; } } void dfs(int x)//求子树和 { for(auto &amp;to : g[x]) { dfs(to); tree[x].cnt += tree[to].cnt; } for(auto &amp;id : tree[x].id) ans[id] = tree[x].cnt; } void failTree() { for(int u = 1; u &lt;= tot; u++) g[tree[u].fail].push_back(u);//对 fail 边建图(一定是树) dfs(0); } }AC; void solve() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; AC.insert(s, i); } AC.build(); string t; cin &gt;&gt; t; AC.query(t); AC.failTree(); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } signed main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t = 1; // cin &gt;&gt; t; while (t--) solve(); return 0; } 二维哈希 const int N = 1e3 + 10; const int p1 = 23333; const int p2 = 233; const int mod = 998243453;//不是998244353 int n, m; string a[N];//原数组 ll h[N][N], pw1[N], pw2[N]; void init_Hash(int n, int m){//将下标从 (1,1) 开始的矩阵 a 进行哈希 h[0][0] = 0; pw1[0] = pw2[0] = 1; for(int i = 1; i &lt;= m; i++){ h[0][i] = 0; pw1[i] = pw1[i - 1] * p1 % mod; } for(int i = 1; i &lt;= n; i++){ h[i][0] = 0; pw2[i] = pw2[i - 1] * p2 % mod; } for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) h[i][j] = (h[i][j - 1] * p1 % mod + a[i][j]) % mod; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) h[i][j] = (h[i - 1][j] * p2 % mod + h[i][j]) % mod; } ll get_hash(int x, int y, int xx, int yy)//获得左上角坐标为(x,y),右下角坐标为(xx,yy)的hash值 { int len1 = yy - y + 1; int len2 = xx - x + 1; ll res = h[xx][yy]; res = (res - h[xx - len2][yy] * pw2[len2] % mod + mod) % mod; res = (res - h[xx][yy - len1] * pw1[len1] % mod + mod) % mod; res = (res + h[xx - len2][yy - len1] * pw2[len2] % mod * pw1[len1] % mod) % mod; return res; }","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"常见结论","slug":"16","date":"2024-06-04T07:54:52.408Z","updated":"2024-06-04T08:05:51.879Z","comments":true,"path":"2024/06/04/16/","link":"","permalink":"/2024/06/04/16/","excerpt":"","text":"a+b = a&amp;b + a|b a+b = a^b + 2(a&amp;b) min(x^y, y^z) &lt; x^z， x &lt; y &lt; z //一个数组中取两个元素让他们的异或和最小，一定是取大小相邻的两个元素 $$ \\lfloor \\frac{ \\lfloor \\frac{x}{y} \\rfloor }{z} \\rfloor = \\lfloor \\frac{x}{yz} \\rfloor $$ $$ a 至少整除 \\lceil \\frac{a+1}{x+1} \\rceil 会小于等于 x $$ $$ 对于一个任意的括号序列 \\ 令 n 为 括号序列长度，m 为括号序列前缀最小值(‘(’ 权值为 1， ‘)’ 权值为 -1)， sum 为括号序列和。 \\ 那么最长匹配子序列的括号匹配数为 n - sum + 2m $$ $$ 典中典 : 一棵树的节点 size 种类只有 \\sqrt{n} 中 $$ $$ log(a)+log(b)=log(a*b) $$ $$ (a + bx) % n = t，其中a,b,n为常数,x为变量,t的最小非负值为a%(gcd(b,n)) $$","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"基础知识","slug":"10","date":"2024-06-04T07:54:49.798Z","updated":"2024-06-04T08:06:08.481Z","comments":true,"path":"2024/06/04/10/","link":"","permalink":"/2024/06/04/10/","excerpt":"","text":"头文件 #include &lt;algorithm&gt; //STL通用算法 #include &lt;bitset&gt;//STL位集容器 #include &lt;cctype&gt; #include &lt;cerrno&gt; #include &lt;clocale&gt; #include &lt;cmath&gt; #include &lt;complex&gt; //复数类 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;deque&gt; //STL双端队列容器 #include &lt;exception&gt; //异常处理类 #include &lt;fstream&gt; #include &lt;functional&gt;//STL定义运算函数（代替运算符） #include &lt;limits&gt; #include &lt;list&gt;//STL线性列表容器 #include &lt;map&gt; //STL 映射容器 #include &lt;iomanip&gt; #include &lt;ios&gt;//基本输入／输出支持 #include&lt;iosfwd&gt;//输入／输出系统使用的前置声明 #include &lt;iostream&gt; #include &lt;istream&gt; //基本输入流 #include &lt;ostream&gt; //基本输出流 #include &lt;queue&gt; //STL队列容器 #include &lt;set&gt; //STL 集合容器 #include &lt;sstream&gt;//基于字符串的流 #include &lt;stack&gt; //STL堆栈容器 #include &lt;stdexcept&gt; //标准异常类 #include &lt;streambuf&gt;//底层输入／输出支持 #include &lt;string&gt;//字符串类 #include &lt;utility&gt; //STL通用模板类 #include &lt;vector&gt;//STL动态数组容器 #include &lt;cwchar&gt; #include &lt;cwctype&gt; 快读 ll read() { char ch; ll a = 0; while((ch = getchar()) == ' ' || ch == '\\n'); a+=ch-'0'; while((ch= getchar()) != ' ' &amp;&amp; ch != '\\n') { a *= 10; a += ch - '0'; } return a; } 快速乘 ll qmul(ll a, ll b, ll mod) //快速乘， 防止爆ll { ll ans = 0; while (b &gt; 0) { if (b &amp; 1) ans = (ans + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; } return ans; } 随机数 std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());//32位 std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());//64位,要用unsigned long long, 2^64-1 组合数 ll fac[N], invfac[N]; ll qpow(ll base, ll pow) { ll ans = 1; while (pow) { if (pow &amp; 1) ans = ans * base % mod; pow &gt;&gt;= 1; base = base * base % mod; } return ans; } inline ll inv(ll x){ return qpow(x, mod - 2); } void init()//不能忘记init和调N的大小 { fac[0] = invfac[0] = 1; for(int i = 1; i &lt; N; i ++ ) fac[i] = fac[i - 1] * i % mod; invfac[N - 1] = qpow(fac[N - 1], mod - 2); for(int i = N - 2; i &gt;= 0; i -- ) invfac[i] = invfac[i + 1] * (1 + i) % mod; } ll C(int n, int m) { if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return fac[n] * invfac[m] % mod * invfac[n - m] % mod; } 坐标系旋转后点的坐标变换 个数数量级 $n$ 以内的素数个数 : $\\frac{n}{In \\ n}$ 令 $d(n)$ 表示 $n$ 的因数个数 对于任意正整数 $n$， 有 $d(n) \\leq \\sqrt{3n}$ 对于 $n &gt; 1260$ ，有 $d(n) &lt; \\sqrt{n}$ 对于 $10^{18}$ 范围内的数，因数个数最多约为 $10^5$","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"数学","slug":"13","date":"2024-06-04T07:54:47.572Z","updated":"2024-06-04T08:05:59.921Z","comments":true,"path":"2024/06/04/13/","link":"","permalink":"/2024/06/04/13/","excerpt":"","text":"数学公式 1 + 1+2 + 1+2+3 + 1+2+3+4 + ······ + 1+2+3+···+n = $\\frac{n*(n+1)*(n+2)}{6}$ $1^2$ + $2^2$ + $3^2$ + ······ + $n^2$ = $\\frac{n*(n+1)*(2n+1)}{6}$ $1 + \\frac{1}{2} + \\frac{1}{3} + ··· + \\frac{1}{n - 1} = In(n) + 0.5772156649$(约等于， n越大误差越小) 欧拉筛 int isprime[N]; vector&lt;int&gt; prime; void sieve() { for (int i = 2; i &lt; N; i++) isprime[i] = 1; for (int i = 2; i &lt; N; i++) { if (isprime[i]) prime.push_back(i); for (int &amp;it : prime) { if (1ll * i * it &gt;= N) break; isprime[i * it] = 0; if (i % it == 0) break; } } } 欧拉函数 性质 ： n的所有因数的欧拉函数之和等于n本身 ll phi(ll x)//容斥原理 O(sqrt(n)) { if(x == 1) return 1; ll ans = x; for (ll i = 2; i * i &lt;= x; i++) { if (x % i == 0) { ans = ans / i * (i - 1); while (x % i == 0) x /= i; } } if (x &gt; 1) ans = ans / x * (x - 1); return ans; } ll phi[N], prime[N]; ll tot;//tot计数，表示prime[N]中有多少质数 void Euler() { phi[1] = 1; for (ll i = 2; i &lt; N; i++) { if (!phi[i]) { phi[i] = i - 1; prime[tot++] = i; } for (ll j = 0; j &lt; tot &amp;&amp; 1ll * i * prime[j] &lt; N; j++) { if (i % prime[j]) phi[i * prime[j]] = phi[i] * (prime[j] - 1); else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } 矩阵快速幂 const int K = 2; struct Matrix { ll a[K][K]; Matrix() {} void clear() { memset(a, 0, sizeof a); }//变成0矩阵 void init()//初始化为单位阵 { clear(); for (int i = 0; i &lt; K; i++) a[i][i] = 1; } Matrix operator * (const Matrix&amp; x) const { Matrix res; res.clear(); for (int i = 0; i &lt; K; i++) for (int j = 0; j &lt; K; j++) for (int k = 0; k &lt; K; k++) (res.a[i][j] += a[i][k] * x.a[k][j] % mod) %= mod; return res; } Matrix operator + (const Matrix&amp; x) const { Matrix res; res.clear(); for (int i = 0; i &lt; K; i++) for (int j = 0; j &lt; K; j++) res.a[i][j] = (a[i][j] + x.a[i][j]) % mod; return res; } }; Matrix qpow(Matrix base, int pow) { Matrix ans; ans.init(); while (pow) { if (pow &amp; 1) ans = ans * base; pow /= 2; base = base * base; } return ans; } void solve() { Matrix x; int p[2][2] = { 1, 1, 1, 0 }; memcpy(x.a, p, sizeof p); while (cin &gt;&gt; n, n != -1) { Matrix ans = qpow(x, n); cout &lt;&lt; ans.a[0][1] &lt;&lt; '\\n'; } } 高斯消元 整数类型解 int a[maxn][maxn]; int ans[maxn]; int GCD ( int a, int b ) { if ( ! b ) return a; return GCD ( b, a % b ); } int LCM ( int a, int b ) { return a / GCD ( a, b ) * b; } int Fabs ( int x ) { if ( x &lt; 0 ) return -x; return x; } int Gauss ( int equ, int var ) { // 方程数、增广矩阵宽度， 传进来的是下标从1，1开始的增广矩阵 for ( int i = 0;i &lt;= var;i ++ ) { ans[i] = 0; Free[i] = 1; } int row, col, MaxRow; col = 1; for ( row = 1;row &lt;= equ &amp;&amp; col &lt; var;row ++, col ++ ) { MaxRow = row; for ( int i = row + 1;i &lt;= equ;i ++ ) if ( Fabs ( a[i][col] ) &gt; Fabs ( a[MaxRow][col] ) ) MaxRow = i; if ( MaxRow != row ) { for ( int i = row;i &lt;= var;i ++ ) swap ( a[row][i], a[MaxRow][i] ); } if ( ! a[row][col] ) { row --; continue; } for ( int i = row + 1;i &lt;= equ;i ++ ) { if ( a[i][col] ) { int lcm = LCM ( Fabs ( a[i][col] ), Fabs ( a[row][col] ) ); int T1 = lcm / Fabs ( a[i][col] ); int T2 = lcm / Fabs ( a[row][col] ); if ( a[i][col] * a[row][col] &lt; 0 ) T2 = -T2; for ( int j = col;j &lt;= var;j ++ ) a[i][j] = a[i][j] * T1 - a[row][j] * T2; } } } for ( int i = row;i &lt;= equ;i ++ ) if ( a[i][col] ) return -1; int temp; if ( row &lt; var ) { return var - row; } for ( int i = var - 1;i &gt; 0;i -- ) { temp = a[i][var]; for ( int j = i + 1;j &lt; var;j ++ ) if ( a[i][j] ) temp -= a[i][j] * ans[j]; ans[i] = temp / a[i][i]; } return 0; } 浮点数 double a[222][222];//下标从 0，0 开始 double ans[222],Free[222];//Free存放自由元 int Gauss ( int equ, int var ) {//方程数量，增广矩阵宽度-1(未知数个数) for ( int i = 0;i &lt;= var;i ++ ) { ans[i] = 0; Free[i] = 1; } int row, col, MaxRow; col = 0; for ( row = 0;row &lt; equ &amp;&amp; col &lt; var;row ++, col ++ ) { MaxRow = row; for ( int i = row + 1;i &lt; equ;i ++ ) if ( fabs ( a[i][col] ) &gt; fabs ( a[MaxRow][col] ) ) MaxRow = i; if ( MaxRow != row ) { for ( int i = row;i &lt;= var;i ++ ) swap ( a[row][i], a[MaxRow][i] ); } if ( fabs ( a[row][col] ) &lt; eps ) {//如果等于0 row --; continue; } for ( int i = row + 1;i &lt; equ;i ++ ) { if ( fabs ( a[i][col] ) &gt; eps ) { double temp = a[i][col] / a[row][col]; for ( int j = col;j &lt;= var;j ++ ) a[i][j] -= a[row][j] * temp; a[i][col] = 0; } } } for ( int i = row;i &lt; equ;i ++ ) if ( fabs ( a[i][col] ) &gt; eps ) return -1; double temp; if ( row &lt; var ) { for ( int i = row - 1;i &gt;= 0;i -- ) { int free_num = 0, idx; for ( int j = 0;j &lt; var;j ++ ) if ( a[i][j] &amp;&amp; Free[j] ) { free_num ++; idx = j; } if ( free_num &gt; 1 ) continue; temp = a[i][var]; for ( int j = 0;j &lt; var;j ++ ) { if ( a[i][j] &amp;&amp; j != idx ) temp -= a[i][j] * ans[j]; } ans[idx] = temp / a[i][idx];//解出非自由元 Free[idx] = 0; } return var - row;//自由元的数量，Free[i] 为 1 则为自由元 } for ( int i = var - 1;i &gt;= 0;i -- ) { temp = a[i][var]; for ( int j = i + 1;j &lt; var;j ++ ) if ( a[i][j] ) temp -= a[i][j] * ans[j]; ans[i] = temp / a[i][i]; } return 0; } 模线性方程组（取模） int a[N][N], ans[N]; int Gauss(int equ, int var) // 下标从 0,0 开始，equ 方程个数，var未知数个数 { for(int i = 0; i &lt;= var; i++) ans[i] = 0; int row, col = 0; for (row = 0; row &lt; equ &amp;&amp; col &lt; var; row++, col++) { int MaxRow = row; for (int i = row + 1; i &lt; equ; i++) { if (Abs(a[i][col]) &gt; Abs(a[MaxRow][col])) MaxRow = i; } if (row != MaxRow) { for (int i = row; i &lt;= var; i++) swap(a[row][i], a[MaxRow][i]); } if (!a[row][col]) { row--; continue; } for (int i = row + 1; i &lt; equ; i++) { if (a[i][col]) { int T = a[i][col] * qpow(a[row][col], mod - 2) % mod; for (int j = col; j &lt;= var; j++) a[i][j] = (a[i][j] - a[row][j] * T % mod + mod) % mod; } } } for (int i = row; i &lt; equ; i++)//无解 { if (a[i][col]) return -1; } if (row &lt; var) return var - row;//多解 for (int i = var - 1; i &gt;= 0; i--)//x为答案 { int temp = a[i][var]; for (int j = i + 1; j &lt; var; j++) { if (a[i][j]) { temp -= a[i][j] * ans[j]; temp = (temp % mod + mod) % mod; } } ans[i] = temp * qpow(a[i][i], mod - 2) % mod; } return 0; } 异或 bitset&lt;222&gt; a[222]; int ans[222], Free[222], cnt; int Gauss(int equ,int var){//下标从 0,0 开始，方程数量，增广矩阵宽度-1(未知数个数) int row, col, MaxRow; col = 0; for(row = 0; row &lt; equ &amp;&amp; col &lt; var; row++, col++) { MaxRow = row; for(int i = row + 1; i &lt; equ; i++) if(abs(a[i][col]) &gt; abs(a[MaxRow][col])) MaxRow=i; if(MaxRow != row) swap(a[row], a[MaxRow]); if(a[row][col] == 0) { row--; Free[++cnt]=col; continue; } for(int i = row + 1; i &lt; equ; i++) if(a[i][col]) a[i] ^= a[row]; } for(int i = row; i &lt; equ; i++) if(a[i][col]) return -1; if(row&lt;var) return var-row; for(int i = var - 1; i &gt;= 0; i--) { ans[i] = a[i][var]; for(int j = i + 1; j &lt; var; j++) if(a[i][j]) ans[i] ^= (a[i][j] &amp;&amp; ans[j]); } return 0; } 行列式求值 int a[N][N]; int calDet(int n, int mod)// a 数组下标从 1,1 开始，方阵 { int i, j, k, r = 1, fh = 0, l; for(i = 1; i &lt;= n; i++) { k = i; for(j = i; j &lt;= n; j++) if(a[j][i]) {k = j; break;} if(a[k][i] == 0) return 0; for(++j; j &lt;= n; j++) if(a[j][i] &amp;&amp; a[j][i] &lt; a[k][i]) k = j; if(i != k) {swap(a[k], a[i]); fh ^= 1;} for(j = i + 1; j &lt;= n; j++) { if(a[j][i] &gt; a[i][i]) {swap(a[j], a[i]); fh ^= 1;} while(a[j][i]) { l = a[i][i] / a[j][i]; for(k = i; k &lt;= n; k++) a[i][k] = (a[i][k] + (ll)(mod - l) * a[j][k]) % mod; swap(a[j], a[i]); fh ^= 1; } } r = (ll)r * a[i][i] % mod; } if(fh) return (mod - r) % mod; return r; } 矩阵求逆 取模 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=505; const int mod=1e9+7; int a[N][N&lt;&lt;1];//开宽度开两倍, 开始要将[1, n]初始化为求逆矩阵，[n + 1, 2 * n] 初始化为单位阵, 最后[n + 1, 2 * n]是逆矩阵 int n; int ppow(int a,int b,int mod){ int ans=1%mod;a%=mod; while(b){ if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod; b&gt;&gt;=1; } return ans; } int Gauss_rev(int n){ for(int i=1;i&lt;=n;i++){ for(int j=i;j&lt;=n;j++){//找第i列非零的行换上来 if(a[j][i]){ swap(a[i],a[j]); break; } } if(!a[i][i])return 0;//无解 int kk=ppow(a[i][i],mod-2,mod);//逆元 for(int j=i;j&lt;=n*2;j++){//当前行每一列都除以a[i][i] a[i][j]=1ll*a[i][j]*kk%mod; } for(int j=1;j&lt;=n;j++){//其他行 if(j!=i){ kk=a[j][i]; for(int k=i;k&lt;=n*2;k++){ a[j][k]=(a[j][k]-1ll*kk*a[i][k]%mod+mod)%mod; } } } } return 1; } signed main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ scanf(&quot;%d&quot;,&amp;a[i][j]); } a[i][i+n]=1; } if(!Gauss_rev(n)){ puts(&quot;No Solution&quot;); }else{ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ printf(&quot;%d &quot;,a[i][j+n]); } puts(&quot;&quot;); } } return 0; } 异或 bitset&lt;N * 2&gt; a[N];//开宽度开两倍, 开始要将[1, n]初始化为求逆矩阵，[n + 1, 2 * n] 初始化为单位阵, 最后[n + 1, 2 * n]是逆矩阵 int Gauss_inv(int n) { for (int c = 1; c &lt;= n; c++) { int t = c; for (int i = c; i &lt;= n; i++) { if (a[i][c]) { t = i; break; } } if (a[t][c] == 0) return 0;//不存在逆矩阵 swap(a[t], a[c]); for (int i = 1; i &lt;= n; i++) if (a[i][c] &amp;&amp; i != c) a[i] ^= a[c]; } return 1; } 线性基 void add(ll x) { for(int i=60;i&gt;=0;i--) { if(x&amp;(1ll&lt;&lt;i))//注意，如果i大于31，前面的1的后面一定要加ll { if(d[i]) x^=d[i]; else { d[i]=x; break;//插入成功就退出 //没有break就说明插入不成功，意味着 x 可以有当前的线性基异或得到 } } } }//最后d数组就是线性基 如何求最大值 完整的说，是如何求在一个序列中，取若干个数，使得它们的异或和最大。 首先构造出这个序列的线性基，然后从线性基的最高位开始，假如当前的答案异或线性基的这个元素可以变得更大，那么就异或它，答案的初值为 0 ll ans() { ll anss = 0; for(int i = 60; i &gt;= 0; i--)//记得从线性基的最高位开始 if((anss ^ d[i]) &gt; anss) anss ^= d[i]; return anss; } 如何求最小值 注意，这里指的是用线性基内的元素能异或出的最小值。 显然就是最小的 d [ i ]了，因为最小的 d [ i ]无论异或谁都会变大。 如果是求整个序列能异或出的最小值而不是这个序列的线性基能异或出的最小值的话，要另外看一看有没有元素不能插入线性基，如果有，那么最小值就是 0，否则依然是最小的 d [ i ]。 从一个序列中取任意个元素进行异或，求能异或出的所有数字中第 $k$ 小的那个。 void work()//处理线性基 { for(int i=1;i&lt;=60;i++) for(int j=1;j&lt;=i;j++) if(d[i]&amp;(1ll&lt;&lt;(j-1)))d[i]^=d[j-1]; } ll k_th(ll k) { if(k==1&amp;&amp;tot&lt;n)return 0;//特判一下，假如k=1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度 if(tot&lt;n)k--;//类似上面，去掉0的情况，因为线性基中只能异或出不为0的解 work(); ll ans=0; for(int i=0;i&lt;=60;i++) if(d[i]!=0) { if(k%2==1)ans^=d[i]; k/=2; } return ans; } 康托展开 曼哈顿距离 $dis(a, b) = |i_a - i_b| + |j_a - j_b|$ ​ $ = max(i_a - i_b, i_b - i_a) + max(j_a - j_b, j_b - j_a)$//做笛卡尔积 ​ $ = max(|(i_a + j_a) - (i_b + j_b)|, |(i_a - j_a) - (i_b - j_b)|)$ 令 $z_a = i_a + j_a, w_a = i_a - j_a, z_b = i_b + j_b, w_b = i_b - j_b$; $dis(a, b) = |z_a - z_b| + |w_a - w_b|$ 平面上若求一个点$(x, y)$到一个点集的最大曼哈顿距离 则只需要维护 $z$的最大值最小值，$w$的最大值最小值 最终答案为 $max(z_{max} - z_x, z_x - z_{min}, w_{max} - w_x, w_x - w_{min})$ 例题 ： 求一个位置，使得其到所有黑点最大曼哈顿距离最小，我们枚举位置，之后最大距离取min即可。 //https://codeforces.com/contest/1689/problem/D #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-4; const ll mod = 1e9 + 7; const ll N = 1e3 + 5; ll n, m; char g[1005][1005]; void solve() { cin &gt;&gt; n &gt;&gt; m; cin.ignore(); for (ll i = 1; i &lt;= n; i++) for (ll j = 1; j &lt;= m; j++) cin &gt;&gt; g[i][j]; ll zmi = inf, zmx = -inf, wmi = inf, wmx = -inf; for (ll i = 1; i &lt;= n; i++) { for (ll j = 1; j &lt;= m; j++) { if(g[i][j] == 'B') { zmi = min(zmi, i + j); zmx = max(zmx, i + j); wmi = min(wmi, i - j); wmx = max(wmx, i - j); } } } ll dis = inf; pair&lt;ll, ll&gt; ans; for (ll i = 1; i &lt;= n; i++) { for (ll j = 1; j &lt;= m; j++) { ll zx = i + j; ll wx = i - j; ll diss = max({ zmx - zx, zx - zmi, wmx - wx, wx - wmi }); if (diss &lt; dis) { dis = diss; ans = { i, j }; } } } cout &lt;&lt; ans.first &lt;&lt; ' ' &lt;&lt; ans.second &lt;&lt; '\\n'; } signed main() { IOS; ll t = 1; cin &gt;&gt; t; while (t--) solve(); return 0; } 曼哈顿距离和切比雪夫距离的转化 曼哈顿距离转切比雪夫距离 $(x,y)-&gt;(x+y, x-y)$ 切比雪夫距离转曼哈顿距离 $(x, y) -&gt; (\\frac{x+y}{2}, \\frac{x-y}{2})$ 质因数分解求给定正整数的因数个数 正整数因数个数的快速求法 以72为例，将72进行质因数分解，72 = $22233$ = $2^3 * 3^2$ 将底数2的幂次和底数3的幂次分别加1再相乘 得到72的因数个数 = (3+1) * (2+1) = 12 对特殊的数如 1，质数均成立 min_25筛 ​ 求大区间素数个数 #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; const int S = 1e6; // S = sqrt(N);N是范围 int isprime[S]; vector&lt;int&gt; prime; ll v[S], f[S]; double inv[S]; void sieve() { fill(isprime + 2, isprime + S, 1); for (int i = 2; i &lt; S; ++i) { if (isprime[i]) prime.push_back(i); for (auto &amp;p : prime) { if (i * p &gt;= S) break; isprime[i * p] = 0; if (i % p == 0) break; } } } ll get(long long n) { // 返回 [1,n] 的素数个数 if (n &lt;= 1) return 0; int lim = sqrt(n); int cnt = 0; for (ll i = 1; i &lt;= n; i = n / (n / i) + 1) v[cnt++] = n / i; auto getid = [&amp;](long long x) { return x &lt;= lim ? cnt - x : n / x - 1; }; for (int i = 0; i &lt; cnt; ++i) f[i] = v[i] - 1; for (int i = 0; prime[i] &lt;= lim; ++i) for (int j = 0; j &lt; cnt &amp;&amp; 1ll * prime[i] * prime[i] &lt;= v[j]; ++j) f[j] -= f[getid(v[j] * inv[prime[i]] + 1e-9)] - i; return f[0]; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); for (int i = 1; i &lt; S; ++i) inv[i] = 1.0 / i; sieve(); ll n; cin &gt;&gt; n; cout &lt;&lt; get(n) &lt;&lt; '\\n'; return 0; } Miller_Rabin 判断大数是否为素数 #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline ll mul(ll x, ll y, ll mod) { return (__int128)x * y % mod; } inline ll qpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y &gt;&gt;= 1, x = mul(x, x, mod)) if (y &amp; 1) res = mul(res, x, mod); return res; } const int pr[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}; bool Miller_Rabin(ll x)//O(7log) { if (x &lt; 3 || x % 2 == 0) return x == 2; int r = 0; ll k = x - 1; while(k % 2 == 0) k /= 2, ++r; for (int T = 0; T &lt;= 6; T++) { ll p = pr[T]; if (p % x == 0) continue; ll v = qpow(p, k, x); if (v == 1) continue; int j; for (j = 1; j &lt;= r; j++, v = mul(v, v, x)) if (v == x - 1) break; if (j &gt; r) return 0; } return 1; } void solve() { ll x; while(cin &gt;&gt; x) cout &lt;&lt; (isprime(x) ? &quot;Y&quot; : &quot;N&quot;) &lt;&lt; '\\n'; } Pollard rho 可以分解出大数的质因子(改 get)，用 $Pollard rho$ 找出一个因子 $x$，然后接着对 $x$ 和 $\\frac{n}{x}$ 用 $Pollard rho$ 来分解 以下代码为找出大数的最大质因子 #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; ll max_factor, n; ll gcd(ll a, ll b){ return b ? gcd(b, a % b) : a; } inline ll mul(ll x, ll y, ll mod) { return (__int128)x * y % mod; } inline ll qpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y &gt;&gt;= 1, x = mul(x, x, mod)) if (y &amp; 1) res = mul(res, x, mod); return res; } const int pr[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}; bool Miller_Rabin(ll x)//判断素数 O(7log) { if (x &lt; 3 || x % 2 == 0) return x == 2; int r = 0; ll k = x - 1; while(k % 2 == 0) k /= 2, ++r; for (int T = 0; T &lt;= 6; T++) { ll p = pr[T]; if (p % x == 0) continue; ll v = qpow(p, k, x); if (v == 1) continue; int j; for (j = 1; j &lt;= r; j++, v = mul(v, v, x)) if (v == x - 1) break; if (j &gt; r) return 0; } return 1; } ll Pollard_Rho(ll x) //返回 x 的一个因子， O(n^(1/4)) { ll s = 0, t = 0; ll c = rand() % (x - 1) + 1; ll val = 1; for (int goal = 1; ; goal *= 2, s = t, val = 1)// 倍增优化 { for (int step = 1; step &lt;= goal; ++step) { t = ((__int128)t * t + c) % x; val = mul(val, abs(t - s), x); if (step % 127 == 0) { ll d = gcd(val, x); if (d &gt; 1) return d; } } ll d = gcd(val, x); if (d &gt; 1) return d; } } void get(ll x) { if (x &lt;= max_factor || x &lt; 2) return; if (Miller_Rabin(x)) { // 如果x为质数 max_factor = max(max_factor, x); // 更新答案 return; } ll p = x; while (p &gt;= x) p = Pollard_Rho(x); // 使用该算法 while (x % p == 0) x /= p; get(x), get(p); // 继续向下分解x和p } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { srand((unsigned)time(NULL)); max_factor = 0; scanf(&quot;%lld&quot;, &amp;n); get(n); if (max_factor == n) // 最大的质因数即自己 printf(&quot;Prime\\n&quot;); else printf(&quot;%lld\\n&quot;, max_factor); } return 0; }","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"数论","slug":"15","date":"2024-06-04T07:54:45.299Z","updated":"2024-06-04T08:05:54.983Z","comments":true,"path":"2024/06/04/15/","link":"","permalink":"/2024/06/04/15/","excerpt":"","text":"同余 ​ 若$a\\equiv b(mod\\ m)$， $a\\equiv b(mod\\ n)$ 则 $a\\equiv b(mod\\ (n,m))$ ​ 若$(k, m) = d$，$ka \\equiv kb(mod\\ m)$，则 $a \\equiv b(mod\\ \\frac{m}{d})$ 简化剩余系 所有$n$满足$0&lt;n\\leq m, (n,m)=1$ 构成了一个模$m$的简化剩余系 记这样的$n$的个数为$\\varphi(m)$ $\\varphi(m)=m\\prod_{p|m}(1-\\frac{1}{p})$ ll eular(ll n)//求单个数 { ll ans = n; for(int i=2; i*i &lt;= n; ++i) { if(n%i == 0) { ans = ans/i*(i-1); while(n%i == 0) n/=i; } } if(n &gt; 1) ans = ans/n*(n-1); return ans; } int m[n],phi[n],p[n],nump; //m[i]标记i是否为素数;p是存放素数的数组;nump是当前素数个数;phi[i]为欧拉函数 void eular() { phi[1]=1; for (int i=2;i&lt;=n;i++) { if (!m[i])//i为素数 { p[++nump]=i;//将i加入素数数组p中 phi[i]=i-1;//因为i是素数,由特性得知 } for (int j=1;j&lt;=nump&amp;&amp;p[j]*i&lt;=n;j++) //用当前已得到的素数数组p筛,筛去p[j]*i { m[p[j]*i]=1;//可以确定i*p[j]不是素数 if (i%p[j]==0) //看p[j]是否是i的约数,因为素数p[j],等于判断i和p[j]是否互质 { phi[p[j]*i]=phi[i]*p[j]; //特性2 break; } else phi[p[j]*i]=phi[i]*(p[j]-1); //互质,特性3其,p[j]-1就是phi[p[j]] } } } 费马小定理 欧拉定理 若$(a,m)=1$，则$a^{\\varphi(m)} \\equiv 1(mod\\ m)$ 特殊的，若$m$为质数，则$\\varphi(m)=m-1$，$a^{m-1}\\equiv1(mod\\ m)$（费马小定理） 逆元 $O(n)$求$1\\thicksim n$的逆元 : ​ $inv[i]=(p-\\frac{p}{i})*inv[p\\ mod\\ i] mod\\ p$ 裴蜀定理 对于不定方程 $ax + by = m$, 则其有整数解的充要条件为$gcd(a, b) | m$ 对于$\\forall x, y \\in Z$ 函数$f(x,y) = ax + by$的最小正整数取值为 $f(x, y) = gcd(x, y)$ 扩展欧几里得 可求出 $ax + by = gcd(a,b)$的一组解 通项 : $a*(x + k * \\frac{b}{gcd(a,b)}) + b * (y + (-k) * \\frac{a}{gcd(a,b)}) = gcd(a,b)$ int exgcd(int a, int b, int&amp; x, int&amp; y) { if (b == 0) { x = 1; y = 0; return a; } int xx, yy; int d = exgcd(b, a % b, xx, yy); x = yy; y = xx - a / b * yy; return d; } $exgcd$ 最终返回 $gcd(a,b)$ 解线性同余方程 $ax\\equiv n(mod \\ b)$ $a,b,n$ 为给定的整数，$x$ 为未知数，需要从区间 $[0,n-1]$ 中求解 $x$ 若 $gcd(a,b)$ 不可整除 $n$ ，则方程无解 扩展欧几里得求解: 将 $ax\\equiv n(mod \\ b)$ 等价成 $ax+by=n$ ，其中 $x,y$ 为未知数 对于 $ax+by=n$ 先求出一组解 $x_0,y_0$，即 $ax_0+by_0=gcd(a,b)$ 那么就得到方程 $a\\frac{n}{gcd(a,b)}x_0+b\\frac{n}{gcd(a,b)}y_0=n$，$\\frac{n}{gcd(a,b)}x_0$ 和 $\\frac{n}{gcd(a,b)}y_0$ 是原方程的一组解 最小整数解为 $(x_0 \\ mod \\ t + t) \\ mod \\ t$，其中 $t = \\frac{b}{gcd(a,b)}$ 中国剩余定理（CRT） 解线性同余方程组 只可求解模数两两互质 ll n, a[20], m[20]; ll qmul(ll a, ll b, ll mod) //快速乘， 防止爆ll { ll ans = 0; while (b &gt; 0) { if (b &amp; 1) ans = (ans + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; } return ans; } ll exgcd(int a, int b, int&amp; x, int&amp; y) { if (!b) { x = 1; y = 0; return a; } ll d = exgcd(b, a % b, x, y); ll temp = x; x = y; y = temp - a / b * y; return d; } ll crt() { ll ans = 0, M = 1; for (int i = 1; i &lt;= n; i++) M *= m[i]; for (int i = 1; i &lt;= n; i++) { ll x, y; ll Mi = M / m[i]; exgcd(Mi, m[i], x, y); //处理后x即为Mi的逆元 x = (x % m[i] + m[i]) % m[i]; //防止x为负数 ans = (ans + qmul(qmul(Mi, a[i], M), x, M)) % M; //模M得到唯一解 } return (ans + M) % M; } void solve() { cin &gt;&gt; n; for (ll i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; m[i]; for (int i = 1; i &lt;= n; i++) a[i] = (a[i] % m[i] + m[i]) % m[i]; //a[i]可能为负数，需要预处理 cout &lt;&lt; crt(); } excrt 增量法（excrt），可以处理任意模数，但$lcm(所有模数)$要在不能爆数据类型 ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) { if (b == 0) { x = 1; y = 0; return a; } ll xx, yy; ll d = exgcd(b, a % b, xx, yy); x = yy; y = xx - a / b * yy; return d; } void merge(ll&amp; a, ll&amp; b, ll c, ll d) { ll x, y; ll g = exgcd(b, d, x, y); if ((c - a) % g != 0) { a = b = -1; return; } d /= g; ll t0 = ((c - a) / g) % d * x % d; if (t0 &lt; 0) t0 += d; a = b * t0 + a; b = b * d; } void solve() { int n; cin &gt;&gt; n; ll a = 0, b = 1;//x mod b = a for (int i = 1; i &lt;= n; i++) { int c, d;//x mod d = c cin &gt;&gt; d &gt;&gt; c; merge(a, b, c, d); } cout &lt;&lt; a &lt;&lt; '\\n'; } 将合数的问题变为素数幂的问题 给定 $n$ 个方程，$x\\equiv a_i\\ (mod\\ m_i)$ ，判断方程是否有解 模一个数 和 模这个数的所有素数幂等价 可以将每个$m_i$转化为素数幂的形式，如$x \\equiv 3(mod\\ 12)$可以转化为 ​ $x \\equiv 4(mod\\ 3)$ ​ $x \\equiv 0(mod\\ 3)$ （同时满足） 方程组有解则说明原式有解 若存在同一素数的多种幂次，则解$x$时只需考虑最高幂次（但仍需检验其它幂次的正确性） void solve() { map&lt;ll, vector&lt;pair&lt;int, int&gt;&gt;&gt; mp; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { ll a; cin &gt;&gt; a &gt;&gt; m; for (int j = 2; j * j &lt;= m; j++) { if (m % j == 0) { ll p = j, pe = 1; //pe为素数幂 while (m % j == 0) m /= j, pe *= j; mp[p].push_back({ pe, a % pe }); //放入素数幂和取余后的结果 } } if (m != 1) mp[m].push_back({ m, a % m }); } for (auto x : mp) { auto e = x.second; ll v = max_element(all(e))-&gt;second; //找到最高次幂 for (auto i : e) { if (v % i.first != i.second) //检验低幂次的正确性，若结果不同说明无解 { cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return; } } } cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; } 扩展Lusca定理 int m, T, M, phipe; pair&lt;int, int&gt; x[110]; ll pr[110]; ll ans[N], a[N], b[N], fac[1010000]; ll qpowmod(ll base, ll pow, ll mod) { base %= mod; ll ans = 1; while (pow) { if (pow &amp; 1) ans = ans * base % mod; pow &gt;&gt;= 1; base = base * base % mod; } return ans; } ll cntp, cnts; ll cal(ll a, int p, int pe, int w)//分解阶乘（将p从阶乘中分解出来） { ll val = 1; while (a) { cntp += (a / p) * w; cnts += (a / pe) * w; val = val * fac[a % pe] % pe; a /= p; } return val; } ll C(ll a, ll b, int p, int pe) { cntp = cnts = 0; ll f1 = cal(a, p, pe, 1);//f1,f2,f3为每次剩下的乘积 ll f2 = cal(b, p, pe, -1); ll f3 = cal(a - b, p, pe, -1); ll v1 = f1 * qpowmod(f2 * f3 % pe, phipe - 1, pe) % pe; ll v2 = qpowmod(p, cntp, pe);//p ll v3 = qpowmod(fac[pe], cnts, pe);//整组的 return v1 * v2 % pe * v3 % pe; } void solve()//T组测试样例，模数相同 { cin &gt;&gt; m &gt;&gt; T; M = m; int tot = 0; for (int i = 2; i &lt;= m; i++)//分解质数， 若m较大， 则 i * i &lt;= m, 最后再判if(m &gt; 1) { if (m % i == 0) { int p = i, pe = 1; while (m % i == 0) { m /= i; pe *= i; } x[++tot] = { p, pe }; } } for (int i = 1; i &lt;= tot; i++)//CRT { int pe = x[i].second; ll Mi = M / pe; for (int c = Mi; c &lt; M; c += Mi)//也可以用exgcd求 { if (c % pe == 1) { pr[i] = c; break; } } } for (int i = 1; i &lt;= T; i++) cin &gt;&gt; a[i] &gt;&gt; b[i]; for (int i = 1; i &lt;= tot; i++) { int p = x[i].first, pe = x[i].second; fac[0] = 1; for (int j = 1; j &lt;= pe; j++) { if (j % p == 0) fac[j] = fac[j - 1]; else fac[j] = fac[j - 1] * j % pe; } phipe = pe / p * (p - 1);//用于后面求逆元 for (int j = 1; j &lt;= T; j++) ans[j] = (ans[j] + C(a[j], b[j], p, pe) * pr[i] % M) % M; } for (int i = 1; i &lt;= T; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; }","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"数据结构","slug":"14","date":"2024-06-04T07:54:43.413Z","updated":"2024-06-04T08:05:57.686Z","comments":true,"path":"2024/06/04/14/","link":"","permalink":"/2024/06/04/14/","excerpt":"","text":"并查集 struct DSU { vector&lt;int&gt; fa, sz; DSU(int n) : fa(n+1), sz(n + 1, 1) { iota(fa.begin(), fa.end(), 0); } int find(int x){ while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x; } bool same(int x, int y) { return find(x) == find(y); } bool merge(int x, int y){ x = find(x); y = find(y); if (x == y) return false; if (sz[x] &gt; sz[y]) swap(x, y); sz[y] += sz[x]; fa[x] = y; return true; } int size(int x) { return sz[find(x)]; } }; 树状数组 struct BIT { int n; vector&lt;int&gt; c; BIT(int sz) : n(sz), c(sz + 1) {}; int lowbit(int x) { return x &amp; -x; } void add(int x, int val) { while (x &lt;= n) c[x] += val, x += lowbit(x); } int getsum(int x){ int ans = 0; while (x) ans += c[x], x -= lowbit(x); return ans; } int query(int l, int r){ return getsum(r) - getsum(l - 1); } int kth(int k) {//大于等于k的最小位置 int res = 0, x = 0; for (int i = log2(n); i &gt;= 0; --i) { x += 1 &lt;&lt; i; if (x &gt;= n || res + c[x] &gt;= k) x -= 1 &lt;&lt; i; else res += c[x]; } return x + 1; } }; 线段树 单点修改 区间和查询 struct SegTree { struct node { int l, r, sum; }tree[N &lt;&lt; 2];//四倍大小 void push_up(int p) { tree[p].sum = tree[p &lt;&lt; 1].sum + tree[p &lt;&lt; 1 | 1].sum; } void build(int l, int r, int p) { tree[p].l = l, tree[p].r = r; if (l == r) { tree[p].sum = a[l]; return; } int mid = (l + r) / 2; build(l, mid, p &lt;&lt; 1); build(mid + 1, r, p &lt;&lt; 1 | 1); push_up(p); } void update(int pos, int val, int p)//单点修改，直接修改值 { int l = tree[p].l, r = tree[p].r; if (l == r) { tree[p].sum = val; return; } int mid = (l + r) / 2; if (pos &lt;= mid) update(pos, val, p &lt;&lt; 1); else update(pos, val, p &lt;&lt; 1 | 1); push_up(p); } int query(int ql, int qr, int p)//查询区间和 { int l = tree[p].l, r = tree[p].r; if (ql &lt;= l &amp;&amp; qr &gt;= r) { return tree[p].sum; } int mid = (l + r) / 2; int ans = 0; if (ql &lt;= mid) ans += query(ql, qr, p &lt;&lt; 1); if (qr &gt; mid) ans += query(ql, qr, p &lt;&lt; 1 | 1); return ans; } }; 区间修改 区间查询 最大值 struct SegTree { struct node { int l, r, mx, lazy; }tree[N &lt;&lt; 2]; void build(int l, int r, int p) { tree[p].l = l, tree[p].r = r; tree[p].mx = tree[p].lazy = 0; if (l == r) return; int mid = (l + r) / 2; build(l, mid, p &lt;&lt; 1); build(mid + 1, r, p &lt;&lt; 1 | 1); } void push_up(int p) { tree[p].mx = max(tree[p &lt;&lt; 1].mx, tree[p &lt;&lt; 1 | 1].mx); } void push_down(int p) { if (!tree[p].lazy) return; tree[p &lt;&lt; 1].mx += tree[p].lazy; tree[p &lt;&lt; 1 | 1].mx += tree[p].lazy; tree[p &lt;&lt; 1].lazy += tree[p].lazy; tree[p &lt;&lt; 1 | 1].lazy += tree[p].lazy; tree[p].lazy = 0; } void update(int ul, int ur, int val, int p) { int l = tree[p].l, r = tree[p].r; if (ul &lt;= l &amp;&amp; ur &gt;= r) { tree[p].mx += val; tree[p].lazy += val; return; } push_down(p); int mid = (l + r) / 2; if (ul &lt;= mid) update(ul, ur, val, p &lt;&lt; 1); if (ur &gt; mid) update(ul, ur, val, p &lt;&lt; 1 | 1); push_up(p); } int query(int ql, int qr, int p) { int l = tree[p].l, r = tree[p].r; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tree[p].mx; push_down(p); int mid = (l + r) / 2; int ans = 0; if (ql &lt;= mid) ans = max(ans, query(ql, qr, p &lt;&lt; 1)); if (qr &gt; mid) ans = max(ans, query(ql, qr, p &lt;&lt; 1 | 1)); return ans; } }sg; 主席树（ 可持久化权值线段树 ） int n, m, a[N], b[N];///求区间[l,r]中的第k大元素 struct node{ int ls, rs, sum;//ls：左儿子编号 lr：右儿子编号 sum：元素个数 }tree[N&lt;&lt;5];//一般开32倍大小 int rt[N], sz;//rt[i]：第i个根节点编号 sz ：节点数量 void update(int l, int r, int &amp;x, int y, int p) { x = ++sz; tree[x] = tree[y];//先将节点原点信息复制 tree[x].sum++;//元素个数增加 if(l == r) return; int mid = (l + r) / 2; if(p &lt;= mid) update(l, mid, tree[x].ls, tree[y].ls, p); else update(mid + 1, r, tree[x].rs, tree[y].rs, p); } int query(int l, int r, int x, int y, int k) { int temp = tree[tree[y].ls].sum - tree[tree[x].ls].sum;//左半边元素个数 if(l == r) return l; int mid = (l + r) / 2; if(temp &gt;= k) return query(l, mid, tree[x].ls, tree[y].ls, k); else return query(mid+1, r, tree[x].rs, tree[y].rs, k - temp); } void solve() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; b[i] = a[i]; } sort(b + 1, b + 1 + n); int len = unique(b + 1, b + 1 + n) - b - 1;//离散化数据 for(int i = 1; i &lt;= n; i++) { int p = lower_bound(b + 1, b + 1 + len, a[i]) - b;//寻找a[i]离散化后的数据 update(1, len, rt[i], rt[i-1], p); } while(m--) { ll l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; b[query(1, len, rt[l-1], rt[r], k)] &lt;&lt; '\\n'; } } 字典树 字符串 int tot;//点数 struct node{ int alp[26];//alp[i]若为正数，则有可通向对应字母的点 int isend;//该点是否可以作为终点 }tree[N];//开模式串个数*长度的大小 void insert(string s) { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp]) tree[p].alp[temp] = ++tot; p = tree[p].alp[temp]; } tree[p].isend = 1; } bool search(string s) { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp])//没有对应的点 return false; p = tree[p].alp[temp]; } if(tree[p].isend)//判断该点是否可作为终点 return true; return false; } void solve() { cin&gt;&gt;n; string s; for(ll i = 1; i &lt;= n; i++) { cin&gt;&gt;s; insert(s); } map&lt;string, ll&gt; mp; cin&gt;&gt;q; while(q--) { cin&gt;&gt;s; bool f = search(s); if(!f) cout&lt;&lt;&quot;WRONG&quot;&lt;&lt;'\\n'; else { mp[s]++; if(mp[s] == 2) { cout&lt;&lt;&quot;REPEAT&quot;&lt;&lt;'\\n'; mp[s] = 1; } else cout&lt;&lt;&quot;OK&quot;&lt;&lt;'\\n'; } }//洛谷P2580 } 二进制 #include&lt;bits/stdc++.h&gt;//cf 817E #define ll long long using namespace std; const int N = 1e5 + 5; ll n; struct node { ll bit[2]; ll cnt; }tree[N &lt;&lt; 5];开模式串个数*长度的大小 ll sz; void insert(ll num) { ll p = 0; for (ll i = 31; i &gt;= 0; i--) { if (!tree[p].bit[(num &gt;&gt; i) &amp; 1]) tree[p].bit[(num &gt;&gt; i) &amp; 1] = ++sz; p = tree[p].bit[(num &gt;&gt; i) &amp; 1]; tree[p].cnt++; } } void del(ll num) { ll p = 0; for (ll i = 31; i &gt;= 0; i--) { if (!tree[p].bit[(num &gt;&gt; i) &amp; 1]) return; p = tree[p].bit[(num &gt;&gt; i) &amp; 1]; tree[p].cnt--; } } ll search(ll num1, ll num2) { ll p = 0; ll ans = 0; for (ll i = 31; i &gt;= 0; i--) { ll x = (num1 &gt;&gt; i) &amp; 1; ll y = (num2 &gt;&gt; i) &amp; 1; if (x == 1) { if (y == 1) { ans += tree[tree[p].bit[1]].cnt; p = tree[p].bit[0]; } else if (y == 0) p = tree[p].bit[1]; } else if (x == 0) { if (y == 1) { ans += tree[tree[p].bit[0]].cnt; p = tree[p].bit[1]; } else if (y == 0) p = tree[p].bit[0]; } if (!p) break; } return ans; } void solve() { cin &gt;&gt; n; while (n--) { ll op; cin &gt;&gt; op; if (op == 1) { ll x; cin &gt;&gt; x; insert(x); } else if (op == 2) { ll x; cin &gt;&gt; x; del(x); } else { ll x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; search(x, y) &lt;&lt; '\\n'; } } } int main() { solve(); return 0; } ST表 一维ST表 最大/小值， gcd， 按位或 int mx[21][N], Log[N]; void init_ST() { for (int j = 1; j &lt;= 20; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + (1 &lt;&lt; (j - 1))]); Log[1] = 0; for (int i = 2; i &lt;= n; i++) Log[i] = Log[i / 2] + 1; } int query(int l, int r) { int k = Log[r - l + 1]; return max(mx[k][l], mx[k][r - (1 &lt;&lt; k) + 1]); } 二维ST表 int mi[N][N][21][21], Log[N]; void init_ST() { for (int i = 0; i &lt;= 20; i++){ for (int j = 0; j &lt;= 20; j++){ if (i == 0 and j == 0) continue; for (int k = 1; k &lt;= n - (1 &lt;&lt; i) + 1; k++){ for (int p = 1; p &lt;= m - (1 &lt;&lt; j) + 1; p++){ if (i == 0) mi[k][p][i][j] = min(mi[k][p][i][j - 1], mi[k][p + (1 &lt;&lt; j - 1)][i][j - 1]); else mi[k][p][i][j] = min(mi[k][p][i - 1][j], mi[k + (1 &lt;&lt; i - 1)][p][i - 1][j]); } } } } Log[1] = 0; for (int i = 2; i &lt;= n; i++) Log[i] = Log[i / 2] + 1; } int query(int r1, int c1, int r2, int c2) { int k1 = Log[r2 - r1 + 1]; int k2 = Log[c2 - c1 + 1]; return min({mi[r1][c1][k1][k2], mi[r2 - (1 &lt;&lt; k1) + 1][c1][k1][k2], mi[r1][c2 - (1 &lt;&lt; k2) + 1][k1][k2], mi[r2 - (1 &lt;&lt; k1) + 1][c2 - (1 &lt;&lt; k2) + 1][k1][k2]}); } 莫队 莫队 //https://codeforces.com/contest/1484/problem/D #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-4; const ll mod = 1e9 + 7; const ll N = 5e4 + 5; ll n, m, a[N], len, pos[N], res, num[N], ans[N], le[N]; struct node { ll l, r, id; bool operator &lt; (const node&amp; a) const { if (pos[l] != pos[a.l]) return pos[l] &lt; pos[a.l]; if (pos[l] % 2) return r &lt; a.r; return r &gt; a.r; } }q[N]; void add(ll x) { res -= num[a[x]] * (num[a[x]] - 1) / 2; num[a[x]]++; res += num[a[x]] * (num[a[x]] - 1) / 2; } void del(ll x) { res -= num[a[x]] * (num[a[x]] - 1) / 2; num[a[x]]--; res += num[a[x]] * (num[a[x]] - 1) / 2; } ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; } void solve() { cin &gt;&gt; n &gt;&gt; m; len = sqrt(n); for (ll i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; pos[i] = (i + len - 1) / len; } for (ll i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; } sort(q + 1, q + 1 + m); for (ll i = 1, l = 1, r = 0; i &lt;= m; i++) { while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); ans[q[i].id] = res; le[q[i].id] = q[i].r - q[i].l + 1; } for (ll i = 1; i &lt;= m; i++) { if (!ans[i]) { cout &lt;&lt; &quot;0/1&quot; &lt;&lt; '\\n'; continue; } ll x = le[i] * (le[i] - 1) / 2; ll g = gcd(ans[i], x); cout &lt;&lt; ans[i] / g &lt;&lt; &quot;/&quot; &lt;&lt; x / g &lt;&lt; '\\n'; } } signed main() { IOS; ll t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } 回滚莫队 //https://vjudge.net/contest/501795#problem/D #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-4; const ll mod = 1e9 + 7; const ll N = 1e5 + 5; ll n, m, len, pos[N], a[N], num[N], num2[N], ans[N], b[N]; struct node { ll l, r, id; bool operator &lt; (const node&amp; a) const { if (pos[l] != pos[a.l]) return pos[l] &lt; pos[a.l]; return r &lt; a.r; } }q[N]; void add(ll x, ll&amp; res) { num[x]++; res = max(res, num[x] * b[x]); } void del(ll x) { num[x]--; } void solve() { cin &gt;&gt; n &gt;&gt; m; len = sqrt(n); for (ll i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; b[i] = a[i]; pos[i] = (i + len - 1) / len; } sort(b + 1, b + 1 + n); ll cnt = unique(b + 1, b + 1 + n) - b - 1;//离散化 for (ll i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b; for (ll i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; } sort(q + 1, q + 1 + m); ll res = 0, l = 1, r = 0, last = 0; for (ll i = 1; i &lt;= m; i++) { //左右区间都在同一个块内,长度较小直接暴力 if (pos[q[i].l] == pos[q[i].r]) { ll res2 = 0; for (ll j = q[i].l; j &lt;= q[i].r; j++) { num2[a[j]]++; res2 = max(res2, num2[a[j]] * b[a[j]]); } ans[q[i].id] = res2; for (ll j = q[i].l; j &lt;= q[i].r; j++) num2[a[j]]--; continue; } //如果当前询问块号和前一次不同，将左指针移动到当前块最右端+1，右指针移动到当前块右端 if (last != pos[q[i].l]) { ll R = min(n, pos[q[i].l] * len); while (r &gt; R) del(a[r--]); while (l &lt; R + 1) del(a[l++]); res = 0; last = pos[q[i].l]; } while (r &lt; q[i].r) add(a[++r], res); ll templ = l; ll temp_res = res; //答案备份 while (templ &gt; q[i].l) add(a[--templ], temp_res); ans[q[i].id] = temp_res; //回滚 while (templ &lt; l) del(a[templ++]); } for (ll i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } signed main() { IOS; ll t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } 树上莫队 int n, m, a[N]; int tot, fa[N], dep[N], sz[N], hson[N], top[N], rnk[N]; int li[N * 2], st[N], ed[N]; int pos[N * 2]; int ans[N], res, cnt[N], use[N]; vector&lt;int&gt; g[N]; vector&lt;int&gt; v; struct Query { int l, r, id, lca; bool operator &lt; (Query a) { if (pos[l] != pos[a.l]) return pos[l] &lt; pos[a.l]; if (pos[l] % 2) return r &lt; a.r; return r &gt; a.r; } }q[N]; void dfs1(int x, int father, int d) { dep[x] = d; hson[x] = -1; sz[x] = 1; for (auto to : g[x]) { if (to == father) continue; fa[to] = x; dfs1(to, x, d + 1); sz[x] += sz[to]; if (hson[x] == -1 || sz[to] &gt; sz[hson[x]]) hson[x] = to; } } void dfs2(int x, int t) { top[x] = t; st[x] = ++tot; li[tot] = x; rnk[tot] = x; if (hson[x] != -1) dfs2(hson[x], t); for (auto to : g[x]) { if (to == fa[x] || to == hson[x]) continue; dfs2(to, to); } ed[x] = ++tot; li[tot] = x; } int Lca(int x, int y) { while (top[x] != top[y]) { if (dep[top[x]] &gt; dep[top[y]]) x = fa[top[x]]; else y = fa[top[y]]; } if (dep[x] &gt; dep[y]) swap(x, y); return x; } void cal(int x) { if (use[x] == 0) { cnt[a[x]]++; if (cnt[a[x]] == 1) res++; } else { cnt[a[x]]--; if (cnt[a[x]] == 0) res--; } use[x] ^= 1; } void solve() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1, u, v; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } for (int i = 1; i &lt;= n; i++) v.push_back(a[i]); sort(all(v)); v.erase(unique(all(v)), v.end()); for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(all(v), a[i]) - v.begin(); dfs1(1, -1, 1); dfs2(1, 1); int len = sqrt(n) + 1; for (int i = 1; i &lt;= n * 2; i++) pos[i] = (i - 1) / len + 1; for (int i = 1, x, y; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; y; q[i].id = i; if (st[x] &gt; st[y]) swap(x, y); q[i].lca = Lca(x, y); if (q[i].lca == x)//x, y在以x为根的子树中 { q[i].l = st[x]; q[i].r = st[y]; q[i].lca = 0; } else { q[i].l = ed[x]; q[i].r = st[y]; } } sort(q + 1, q + 1 + m); for (int i = 1, l = 1, r = 0; i &lt;= m; i++) { while (l &gt; q[i].l) cal(li[--l]); while (r &lt; q[i].r) cal(li[++r]); while (l &lt; q[i].l) cal(li[l++]); while (r &gt; q[i].r) cal(li[r--]); if (q[i].lca) cal(q[i].lca); ans[q[i].id] = res; if (q[i].lca) cal(q[i].lca); } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } 树链剖分 重链剖分 int tot, fa[N], dep[N], sz[N], hson[N], top[N], dfn[N], rnk[N]; vector&lt;int&gt; g[N]; void dfs1(int x, int father, int d) { dep[x] = d; hson[x] = -1; sz[x] = 1; for (auto to : g[x]) { if (to == father) continue; fa[to] = x; dfs1(to, x, d + 1); sz[x] += sz[to]; if (hson[x] == -1 || sz[to] &gt; sz[hson[x]]) hson[x] = to; } } void dfs2(int x, int t) { top[x] = t;//所在重链的最高点t dfn[x] = ++tot; rnk[tot] = x; if (hson[x] == -1) return; dfs2(hson[x], t); for (auto to : g[x]) { if (to == fa[x] || to == hson[x]) continue; dfs2(to, to); } } int Qmx(int x, int y) { int ans = -inf, fx = top[x], fy = top[y]; while (fx != fy) { if (dep[fx] &gt; dep[fy]) { ans = max(ans, st.query_mx(dfn[fx], dfn[x], 1)); x = fa[fx]; fx = top[x]; } else { ans = max(ans, st.query_mx(dfn[fy], dfn[y], 1)); y = fa[fy]; fy = top[y]; } } if (dfn[x] &lt; dfn[y]) swap(x, y); ans = max(ans, st.query_mx(dfn[y], dfn[x], 1)); return ans; } void Update(int x, int y, int val) { int fx = top[x], fy = top[y]; while (fx != fy) { if (dep[fx] &gt; dep[fy]) { st.update(dfn[fx], dfn[x], val, 1); x = fa[fx]; fx = top[x]; } else { st.update(dfn[fy], dfn[y], val, 1); y = fa[fy]; fy = top[y]; } } if (dfn[x] &gt; dfn[y]) swap(x, y); st.update(dfn[x], dfn[y], val, 1); } CDQ分治 离线解决三维偏序问题， 解决和点对有关的问题 原则 ：前一半更新后一半 //https://www.luogu.com.cn/problem/P3157 #include&lt;bits/stdc++.h&gt; #include&lt;unordered_map&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const int inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-8; const ll mod = 998244353; const int N = 1e5 + 5; int n, m, rk[N]; struct node { int val, del; int ans; }a[N]; struct BIT { int b[N]; int lowbit(int x) { return x &amp; (-x); } void add(int x, int val) { while (x &lt; N) { b[x] += val; x += lowbit(x); } } int getsum(int x) { int ans = 0; while (x) { ans += b[x]; x -= lowbit(x); } return ans; } int query(int l, int r) { return getsum(r) - getsum(l - 1); } }b; void cdq(int l, int r) { if (l == r) return; int mid = (l + r) / 2; cdq(l, mid); cdq(mid + 1, r); int i = l; int j = mid + 1; while (i &lt;= mid) { while (a[i].val &gt; a[j].val &amp;&amp; j &lt;= r) { b.add(a[j].del, 1); j++; } a[i].ans += b.query(a[i].del + 1, m + 1); i++; } i = l; j = mid + 1; while (i &lt;= mid) { while (a[i].val &gt; a[j].val &amp;&amp; j &lt;= r) { b.add(a[j].del, -1); j++; } i++; } i = mid; j = r; while (j &gt;= mid + 1) { while (a[i].val &gt; a[j].val &amp;&amp; i &gt;= l) { b.add(a[i].del, 1); i--; } a[j].ans += b.query(a[j].del + 1, m + 1); j--; } i = mid; j = r; while (j &gt;= mid + 1) { while (a[i].val &gt; a[j].val &amp;&amp; i &gt;= l) { b.add(a[i].del, -1); i--; } j--; } sort(a + l, a + 1 + r, [](node&amp; a, node&amp; b) { return a.val &lt; b.val; }); } void solve() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].val, rk[a[i].val] = i, a[i].del = m + 1; for (int i = 1, x; i &lt;= m; i++) { cin &gt;&gt; x; a[rk[x]].del = i; } ll res = 0; for (int i = 1; i &lt;= n; i++) { res += b.query(a[i].val + 1, n); b.add(a[i].val, 1); } for (int i = 1; i &lt;= n; i++) b.add(a[i].val, -1); cdq(1, n); sort(a + 1, a + 1 + n, [](node&amp; a, node&amp; b) { return a.del &lt; b.del; }); for (int i = 1; i &lt;= m; i++) { cout &lt;&lt; res &lt;&lt; '\\n'; res -= a[i].ans; } } signed main() { IOS; int t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } //https://codeforces.com/contest/1045/problem/G #include&lt;bits/stdc++.h&gt; #include&lt;unordered_map&gt; #include&lt;array&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const int inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-8; const ll mod = 998244353; const int N = 1e5 + 5; int n, k; ll ans; struct node { int x, r, q, L, R; }a[N]; struct BIT { int b[N]; int lowbit(int x) { return x &amp; (-x); } void add(int x, int val) { while (x &lt; N) { b[x] += val; x += lowbit(x); } } int getsum(int x) { int ans = 0; while (x) { ans += b[x]; x -= lowbit(x); } return ans; } int query(int l, int r) { return getsum(r) - getsum(l - 1); } }b; void cdq(int l, int r) { if (l == r) return; int mid = (l + r) / 2; cdq(l, mid); cdq(mid + 1, r); int i = mid + 1; int L = l, R = l; while (i &lt;= r) { while (L &lt;= mid &amp;&amp; a[L].q &lt; a[i].q - k) b.add(a[L++].x, -1); while (R &lt;= mid &amp;&amp; a[R].q &lt;= a[i].q + k) b.add(a[R++].x, 1); ans += b.query(a[i].L, a[i].R); i++; } while (L &lt; R) b.add(a[L++].x, -1); sort(a + l, a + r + 1, [](node&amp; a, node&amp; b) { return a.q &lt; b.q; }); } int p[N]; void solve() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i].x &gt;&gt; a[i].r &gt;&gt; a[i].q; a[i].L = max(0, a[i].x - a[i].r); a[i].R = min(inf, a[i].x + a[i].r); p[i] = a[i].x; } sort(p + 1, p + 1 + n); int len = unique(p + 1, p + 1 + n) - p - 1; for (int i = 1; i &lt;= n; i++) { a[i].x = lower_bound(p + 1, p + 1 + len, a[i].x) - p; a[i].L = lower_bound(p + 1, p + 1 + len, a[i].L) - p; a[i].R = upper_bound(p + 1, p + 1 + len, a[i].R) - p - 1; } sort(a + 1, a + 1 + n, [](node&amp; a, node&amp; b) { return a.r &gt; b.r; }); cdq(1, n); cout &lt;&lt; ans &lt;&lt; '\\n'; } signed main() { IOS; int t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } 欧拉序 欧拉序1 这一种欧拉序相当于是在dfs的时候，如果某个节点入栈，就把这个节点记录下来，直到后面的操作中这个节点出栈，再记录一次这个节点 欧拉序2 这一种欧拉序相当于是在dfs的时候，如果储存节点的栈变化一次，就把栈顶的节点编号记录下来,也就是说，每当访问完一个节点的子树，则需要返回一次该节点 树上启发式合并 /* 题意 ：给出一棵 n 个节点以 1 为根的树，节点 u 的颜色为 c[u] 现在对于每个结点 u 询问 u 子树里一共出现了多少种不同的颜色。 */ int n, a[N], c[N]; int ans[N]; vector&lt;int&gt; g[N]; int hson[N], L[N], R[N], sz[N], tot, rk[N]; int cnt[N], res; void dfs(int x, int fa) { hson[x] = -1; sz[x] = 1; L[x] = ++tot; rk[tot] = x; for (int &amp;to : g[x]) { if (to == fa) continue; dfs(to, x); sz[x] += sz[to]; if (hson[x] == -1 || sz[to] &gt; sz[hson[x]]) hson[x] = to; } R[x] = tot; } void add(int x) { cnt[c[x]]++; if(cnt[c[x]] == 1) res++; } void del(int x) { cnt[c[x]]--; if(cnt[c[x]] == 0) res--; } void dsu(int x, int fa, bool keep) { for (int &amp;to : g[x])// 计算轻儿子的答案 if (to != fa &amp;&amp; hson[x] != to) dsu(to, x, false); if (hson[x] != -1)// 计算重儿子答案并保留计算过程中的数据（用于继承） dsu(hson[x], x, true); for (int &amp;to : g[x])// 把轻儿子(轻子树)的贡献加进去,这样这颗子树的贡献就全在了 { if (to != fa &amp;&amp; hson[x] != to) { //for(int i = L[to]; i &lt;= R[to]; i++) cal(); for (int i = L[to]; i &lt;= R[to]; i++) add(rk[i]); } } add(x);// 将当前点的贡献加进去 //cal(x) ans[x] = res; // 计算以 x 为根的答案 if (!keep)//如果当前子树的是 fa 的轻儿子，则删除当前子树的贡献 { for (int i = L[x]; i &lt;= R[x]; i++) del(rk[i]); } } void solve() { cin &gt;&gt; n; for (int i = 1, u, v; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } for(int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i]; dfs(1, -1); dsu(1, -1, false); int m; cin &gt;&gt; m; while(m--) { int x; cin &gt;&gt; x; cout &lt;&lt; ans[x] &lt;&lt; '\\n'; } } 点分治 // 题意:给定一棵有 n 个点的树，询问树上距离为 k 的点对是否存在。 //O（nlognlogn） const int inf = 0x3f3f3f3f; const int N = 1e4 + 10; int n, m; int dis[N], vis[N], num, root, MX, sz[N], tot; vector&lt;pair&lt;int, int&gt;&gt; g[N]; int q[105], ans[105]; void getroot(int x, int fa)// 找重心 { sz[x] = 1; int mx = 0; for (auto &amp;now : g[x]) { int to = now.first; if (to == fa || vis[to]) continue; getroot(to, x); sz[x] += sz[to]; mx = max(mx, sz[to]); } mx = max(mx, num - sz[x]); if (mx &lt; MX) { MX = mx; root = x; } } void getdis(int x, int fa, int d) { dis[++tot] = d; for (auto &amp;[to, w] : g[x]) { if (vis[to] || to == fa) continue; getdis(to, x, d + w); } } int cal(int x, int k)//O(logn) { int res = 0; for (int l = 1; l &lt;= tot; l++)//合并用二分保证复杂度 res += upper_bound(dis + 1, dis + 1 + tot, k - dis[l]) - lower_bound(dis + 1, dis + 1 + tot, k - dis[l]); return res; } int ok[105];// 记录询问是否已经存在答案了 void divide(int x)//O(nlogn)，求解以当前所求子树中，经过 x 的路径的答案 { tot = 0; getdis(x, -1, 0);// 求当前子树中每个点到 x 的距离 sort(dis + 1, dis + 1 + tot); for (int i = 1; i &lt;= m; i++) if(!ok[i]) ans[i] += cal(x, q[i]); // 计算经过 x 的路径的条数 // 因为是通过 dis 计算出的路径数，可能两个端点都位于 x 的同一个儿子，此时路径是非法的 vis[x] = 1; for (auto &amp;[to, w] : g[x]) { if (vis[to]) continue; tot = 0; getdis(to, -1, w);//以 w 为起始距离，保证路径长度相同 sort(dis + 1, dis + 1 + tot); for (int i = 1; i &lt;= m; i++) if(!ok[i]) ans[i] -= cal(x, q[i]); // 减去非法路径数，因为此时 dis 的端点都在同一个儿子中 } for (int i = 1; i &lt;= m; i++) if (ans[i]) ok[i] = 1; // 减去非法路径后，若仍有长度为 k 的路径存在则有答案 for (auto &amp;[to, w] : g[x]) //子问题 { if (vis[to]) continue; num = sz[to]; MX = inf; getroot(to, -1); divide(root); } } void solve() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1, u, v, w; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back({ v, w }); g[v].push_back({ u, w }); } for (int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i];// 离线 num = n, MX = inf; getroot(1, -1); divide(root); for (int i = 1; i &lt;= m; i++) cout &lt;&lt; (ans[i] ? &quot;AYE&quot; : &quot;NAY&quot;) &lt;&lt; '\\n'; } #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; /* 离线处理询问，询问 u, v 会在 路径上某个点作为重心时求解，不然将询问丢给子树 */ const int N = 5e5 + 10; int n, q; ll c[N]; vector&lt;int&gt; g[N]; vector&lt;array&lt;int, 3&gt;&gt; qry[N]; int vis[N], sz[N], root, bel[N];//bel 记录处于根的那棵子树中//板子部分 ll f[N][60]; int dp[N][60]; int ans[N]; void get_sz(int x, int fa)//板子部分 { sz[x] = 1; for(auto &amp;to : g[x]) { if(to == fa || vis[to]) continue; get_sz(to, x); sz[x] += sz[to]; } } int find(int x, int fa, int s)//找重心//板子部分 { for(auto &amp;to : g[x]) { if(to == fa || vis[to] || 2 * sz[to] &lt;= s) continue; return find(to, x, s); } return x; } void dfs(int x, int fa)// cal，处理答案 { for(auto &amp;to : g[x]) { if(to == fa || vis[to]) continue; bel[to] = (x == root ? to : bel[x]); for(int i = 0; i &lt; 60; i++) { if(dp[x][i] == -1 || !(c[x] &amp; c[to])) dp[to][i] = -1; else if(f[x][i] &amp; c[to]) { dp[to][i] = dp[x][i] + 1; f[to][i] = f[x][i] &amp; c[to]; } else { dp[to][i] = dp[x][i] + 2; f[to][i] = c[x] &amp; c[to]; } } dfs(to, x); } } void divide(int x) { auto Q = move(qry[x]); get_sz(x, -1);//板子部分 x = find(x, -1, sz[x]);// x 为重心 //板子部分 for(int i = 0; i &lt; 60; i++) { if(c[x] &gt;&gt; i &amp; 1) { dp[x][i] = 0; f[x][i] = 1ll &lt;&lt; i; } else dp[x][i] = -1; } root = x;//板子部分 bel[x] = x;//板子部分 dfs(x, -1); for(auto &amp;[u, v, id] : Q) { if(bel[u] == bel[v]) qry[bel[u]].push_back({u, v, id}); else { for(int i = 0; i &lt; 60; i++) { if(dp[u][i] != -1 &amp;&amp; dp[v][i] != -1) { int res = dp[u][i] + dp[v][i]; if(ans[id] == -1 || ans[id] &gt; res) ans[id] = res; } } } } vis[x] = 1;//板子部分 for(auto &amp;to : g[x]) if(!vis[to]) divide(to);//板子部分 } void solve() { cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i]; for(int i = 1; i &lt; n; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } for(int i = 1; i &lt;= q; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; qry[1].push_back({u, v, i}); } for(int i = 1; i &lt;= q; i++) ans[i] = -1; divide(1);//板子部分 for(int i = 1; i &lt;= q; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } signed main() { ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); solve(); return 0; }","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"树形板子","slug":"17","date":"2024-06-04T07:54:41.714Z","updated":"2024-06-04T08:05:48.901Z","comments":true,"path":"2024/06/04/17/","link":"","permalink":"/2024/06/04/17/","excerpt":"","text":"树的重心 找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心 void getroot(int x, int fa) { son[x] = 1; int mx = 0; for (auto &amp;to : g[x]) { if (to == fa || vis[to]) continue; getroot(to, x); son[x] += son[to]; mx = max(mx, son[to]); } mx = max(mx, num - son[x]); if (mx &lt; MX) { MX = mx; root = x; } } 树的直径 （dfs） 先从图上任意一点，搜索整棵树，找到距离该点最远的点，再用距离该点最远的点搜索一次，即可得到树的直径。 void dfs(int x, int fa) { for (int &amp;to : g[x]) { if (to != fa) { dis[to] = dis[x] + 1; dfs(to, x); } } } int diameter() { for (int i = 1; i &lt;= n; i++) dis[i] = 0; dfs(1, -1); int mx = 0, st = 1; for (int i = 1; i &lt;= n; i++) if (dis[i] &gt; mx) mx = dis[i], st = i; for (int i = 1; i &lt;= n; i++) dis[i] = 0; dfs(st, -1); mx = 0; for (int i = 1; i &lt;= n; i++) mx = max(dis[i], mx); return mx; } 最小生成树（MST） Kruskal 稀疏图（边数少更有效率） // n为点数m为边数 struct DSU { // 并查集模板 int n; vector&lt;int&gt; dsu_fa; DSU(int _n) : n(_n) { for (int i = 0; i &lt;= n; i++) { dsu_fa.push_back(i); } } int find(int x) { if (x != dsu_fa[x]) dsu_fa[x] = find(dsu_fa[x]); return dsu_fa[x]; } bool merge(int x, int y) { x = find(x), y = find(y); dsu_fa[x] = y; return (x != y); } bool same(int x, int y) { return find(x) == find(y); } }; vector&lt;pair&lt;int,pair&lt;int,int&gt;&gt;&gt; e(m) // 存边(w,(u,v)) int kruskal() { DSU dsu(n); sort(e.begin(), e.end()); int res = 0, cnt = 0; for (const auto &amp;pi: e) { int u = pi.second.first, v = pi.second.second, w = pi.first; if (dsu.merge(u, v)) res += w, cnt++; if (cnt == n - 1) break; } return res; } Prim 稠密图（边数多更有效率） int n, m, e[N][N]; ll mst[N], lowcost[N];//lowcost[i]：终点为i的最小花费，若lowcast[i] = 0，则表示i点已在当前所建的图中；mst[i]：终点为i的最小花费所对应的起点 int prim() { ll sum = 0; for(int i = 2; i &lt;= n; i++) { lowcost[i] = e[1][i]; // mst[i] = 1; } //mst[1] = 0; for(int i = 2; i &lt;= n; i++) { int minid = -1; ll mi = inf; for(int j = 2; j &lt;= n; j++) { if(lowcost[j] &amp;&amp; lowcost[j] &lt; mi) { minid = j; mi = lowcost[j]; } } if(minid == -1) return inf;//图不联通返回inf sum += lowcost[minid]; lowcost[minid] = 0; for(int j = 2; j &lt;= n; j++) { if(e[minid][j] &lt; lowcost[j]) { lowcost[j] = e[minid][j]; // mst[j] = minid; } } } return sum; } 虚树 inline bool cmp(const int &amp;a, const int &amp;b){ return dfn[a] &lt; dfn[b]; } void build()//二次排序 { sort(all(v), cmp); for(auto &amp;it : v) t.push_back(it); for(int i = 1; i &lt; v.size(); i++) t.push_back(LCA(v[i - 1], v[i]));//lca 和关键点放入，按dfn排序 sort(all(t), cmp); t.erase(unique(all(t)), t.end()); for(int i = 1; i &lt; t.size(); i++)//lca 和 y 建边 { int lca = LCA(t[i - 1], t[i]); int val = dis(lca, t[i]); G[lca].push_back({t[i], val}); G[t[i]].push_back({lca, val}); } }","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"计数","slug":"18","date":"2024-06-04T07:54:39.775Z","updated":"2024-06-04T09:08:18.257Z","comments":true,"path":"2024/06/04/18/","link":"","permalink":"/2024/06/04/18/","excerpt":"","text":"组合数性质 1. ​ $C_n^0 + C_n^1 + C_n^2 ··· + C_n^{n-1} + C_n^n = 2^n$ 2. ​ $C_n^0 + C_n^2 + C_n^4 ··· = C_n^1 + C_n^3 + C_n^5 ··· = 2 ^{n-1}$ 3. ​ $0 * C_n^0 + 1 * C_n^1 + 2 * C_n^2 + ··· + n * C_n^n = n * 2^{n-1}$ 4. ​ $C_n^m = \\frac{n}{m} * C_{n-1}^{m-1}$ ​ $C_n^{m+1} = \\frac{n-m}{m+1}C_n^m$ 5. ​ $({C_n^0})^2 + ({C_n^1})^2 + ··· + ({C_n^n})^2 = C_{2n}^n$ 6. ​ $\\sum_{i=0}^n C_i^k = C_{n+1}^{k+1}$ 7. ​ $C_n^m$为奇数时有 $n$ &amp; $m = m$ ​ 模数为2时也满足$n$ &amp; $m = m $(根据卢卡斯定理)，可将问题转化成二进制下的问题，然后考虑数位dp 8. ​ $C_n^k * C_k^r = C_n^r * C_{n-r}^{k-r}(k \\geq r)$ 9. $C_{n+r+1}^{r} = C_{n}^{0}+C_{n+1}^{1}+···+C_{n+r-1}^{r-1}+C_{n+r}^{r}$ $C_{n+r+1}^{n+1} = C_{n}^{n}+C_{n+1}^{n}+···+C_{n+r}^{n}$ 10. $\\sum_{i=0}^{i=s}C_s^i*i = s2^{s-1}$ 11. $\\sum_{i=0}^{min(x,y)}C_x^iC_y^i = C_{x+y}^x$ 12. $\\sum_{i=0}^{k}C_{n}^{i}C_m^{k-i}=C_{n+m}^{k}$ 二项式定理 ​ 1.一般二项式定理($n$为非负整数) ​ $(a + b) ^ n = \\sum_{k=0}^{n} C_n^k a ^ kb^{n-k}$ 二项式反演 二项式反演为一种反演形式，常用于通过 “指定某若干个” 求 “恰好若干个” 的问题。 考虑解决至少、至多的问题，这个问题解决就是 $f(n)$ 的值。一般是会比较好求的，用点数学方法或者DP就可以解决。然后，用二项式反演，求出 $g(n)$。这就是恰好的方案数 形式零 $f(n)=\\sum_{i=0}^{n}(-1)^iC_n^ig(i) \\Longleftrightarrow g(n)=\\sum_{i=0}^{n}(-1)^iC_n^if(i)$ 形式一 $f(n)=\\sum_{i=m}^{n}C_n^ig(i) \\Longleftrightarrow g(n)=\\sum_{i=m}^{n}(-1)^{n-i}C_n^if(i)$ 形式二 $f(n)=\\sum_{i=n}^{m}C_i^ng(i) \\Longleftrightarrow g(n)=\\sum_{i=n}^{m}(-1)^{i-n}C_i^nf(i)$ 组合意义 : 记 $f(n)$ 表示 “钦定选 $n$ 个”，$g(n)$ 表示 “恰好选 $n$ 个”，则对于任意的 $i≥n$ ，$g(i)$ 在 $f(n)$ 中被计算了 $C_i^n$ 次，故 $f(n)=\\sum_{i=n}^{m}C_i^n g(i)$ ，其中 $m$ 是数目上界。 多重集合的排列数 有$n$种物品，每种物品有$c_i$个，将物品全排列的方案数为 $\\frac{\\sum_{i=1}^{n} c_i}{\\prod_{i=1}^{n} c_i}$ 多重集的组合数 有$n$种物品，每种物品有$c_i$个，从中选出 $m \\ (m \\leq c_i)$ 个物品的方案数为 $C_{m + n - 1}^{n - 1}$ 若没有对于 $m$ 的限制 多项式 $dp_{i+1,j}=dp_{i+1,j-1}+dp_{i,j}-dp_{i,j-1-c_i}$ $dp_{ij} : $前 $i$ 种物品拿了 $j$ 个的方案数 在计数DP中，为了避免重复计算，同一类物品往往要一起处理 错排 $f(n) = (n - 1)(f(n - 1) + f(n - 2))$ ​ $= nf(n-1) +(-1)^n$ 随着元素的增加，一个随机排列是错排的概率接近$\\frac{1}{e}$ 圆排列 从 $n$ 个不同元素中选取 $r$ 个元素，不分首尾地围成一个圆圈的排列叫做圆排列，其排列方案数为 $\\frac{A_n^r}{r}$ 可重复组合数 多重集的排列数$(r &lt; n_i)$ $H_n^r = C_{n+r-1}^r$ 分装问题 将 $n$ 个球放入 $r$ 个盒子称为分装问题 $n$ 个球完全相同，$r$ 个盒子完全不相同，允许空盒 ： $C_{n+r-1}^{r-1}$ $n$ 个球完全相同，$r$ 个盒子完全不相同，不允许空盒 ：$C_{n-1}^{r-1}$ $n$ 个球完全相同，$r$ 个盒子完全相同，允许空盒 ：$\\sum _{k=1}^{r}P(n,k)$，分拆数 $n$ 个球完全相同，$r$ 个盒子完全相同，不允许空盒($n \\geq r $) ：$P(n,r)$，分拆数 $n$ 个球完全不相同，$r$ 个盒子完全不相同，允许空盒 ：$r^n$ $n$ 个球完全不相同，$r$ 个盒子完全不相同，不允许空盒 : $r!S(n,r)$，第二类斯特林数 $n$ 个球完全不相同，$r$ 个盒子完全相同，允许空盒 ：$\\sum _{k=1}^{r}S(n,k)$，第二类斯特林数 $n$ 个球完全不相同，$r$ 个盒子完全相同，不允许空盒: $S(n,r)$，第二类斯特林数 Lucas 定理 ​ 若$p$是质数，则对于任意整数 $1 \\leq m \\leq n$, 有： $C_n^m \\equiv C_{n \\ mod \\ p}^{m \\ mod \\ p} * C_{n/p}^{m/p}(mod \\ p)$ ​ 也就是把 $n$ 和 $m$ 表示成 $p$ 进制数， 对 $p$ 进制下的每一位分别计算组合数，最后再乘起来 ll C(ll n, ll m) { if (m &lt; 0 || m &gt; n) return 0; if (m == 0) return 1; if (m &lt; p &amp;&amp; n &lt; p) return fac[n] * invfac[m] % p * invfac[n - m] % p; return C(n / p, m / p) * C(n % p, m % p) % p; } 若$(_a^{a+b}) \\neq 0$，则说明$a + b$在$p$进制里加法不进位 斐波那契数列 性质 $\\sum_{i=1}^nf_i = f_{n+2}-1$ $\\sum_{i=1}^nf_{2i-1} = f_{2n}$ $\\sum_{i=1}^nf_{2i} = f_{2n+1} - 1$ $\\sum_{i=1}^n(f_i)^2 = f_nf_{n+1}$ $f_{n+m} = f_{n-1}f_{m-1} + f_nf_m$ $(f_n)^2 = (-1)^{n-1} + f_{n-1}f_{n+1}$ $f_{2n-1} = (f_n)^2 - (f_{n-2})^2$ $f_n = \\frac{f_{n+2} + f_{n-2}}{3}$ $\\frac{f_i}{f_{i-1}} \\thickapprox \\frac{\\sqrt{5} - 1}{5} \\thickapprox 0.618$ $f_n = \\frac{(\\frac{1+\\sqrt{5}}{2})^n - (\\frac{1-\\sqrt{5}}{2})^n}{\\sqrt{5}}$ Catalan数列 $Cat_n = Cat_0 * Cat_{n-1} + Cat_1 * Cat_{n-2} + ··· + Cat_{n-1}*Cat_0(n \\geq 2)$ $ = Cat_{n-1} * \\frac{4n-2}{n+1}$ $= C_{2n}^{n} - C_{2n}^{n-1}$ $ = \\frac{C_{2n}^{n}}{n+1}$ Cat = {1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670} ​ 应用： 1.n个左括号和n个右括号组成的合法括号序列的数量为 $Cat_n$ 2.$1,2,···,n$ 经过一个栈， 形成的合法出栈序列的数量为 $Cat_n$ 3.n 个节点构成的不同二叉树的数量为 $Cat_n$ 4.在平面直角坐标系上， 每一步只能向上或向右走， 从$(0,0)$走到$(n,n)$并且除两个端点外不接触直线$y = x$的路线数量为 $2Cat_{n-1}$ 5.在平面直角坐标系上， 每一步只能向上或向右走， 从$(0,0)$走到$(n,n)$，在任一时刻，向右走的次数不能少于向上走的次数，方案数为 $Cat_{n}$ 6.在圆上选择$2n$个点，将这些点成对连接起来使得所得到的$n$条线段不相交的方法数为 $Cat_n$ 7.一个有$n$个定点的凸多边形区域划分成三角形区域的方法数为$Cat_{n-2}$ 斯特林数(Stirling) 第一类斯特林数 $s(n,m)$，也记为 $[_m^n]$。表示将 $n$ 个不同元素构成 $m$ 个圆排列的方案数。同时还分为无符号第一类斯特林数 $s_u(n,m)$ 和有符号第一类第一类斯特林数 $s_s(n,m)$。 第二类斯特林数 $S(n,m)$，也记为 ${_m^n}$。表示将 $n$ 个不同的元素划分成 $m$ 个集合的方案数。 第二类斯特林数 ​ ${m^n} = {{m-1}^{n-1}} + m{_{\\ \\ m}^{n-1}}$ ​ ${m^n} = \\sum{i=0}^{m}\\frac{(-1)^{m-i}i^n}{i!(m-i)!}$ 第一类斯特林数 ​ $[m^n] = [{m-1}^{n-1}] + (n-1)[_{\\ \\ m}^{n-1}]$ 上升幂 ​ $x^{\\bar{n}} = \\prod_{k=0}^{n-1}(x+k) = x(x+1)(x+2)\\dots(x+n-1)$ ​ 1).上升幂转普通幂 ​ $x^{\\bar{n}} = \\sum_{k=0}^n[_k^n]x^k$ ​ 2).普通幂转上升幂 ​ $x^n = \\sum_{k=0}^n(-1)^{n-k}x^{\\bar{k}}$ 下降幂 ​ $x^{\\underline{n}} = \\frac{x!}{(x-n)!} = \\prod_{k=0}^{n-1}(x-k)$ ​ 1).下降幂转普通幂 ​ $x^{\\underline{n}} = \\sum_{k=0}^n_k^n^{n-k}x^k$ ​ 2).普通幂转下降幂 ​ $x^n = \\sum_{k=0}^{n}{_k^n}x^{\\underline{k}}$ 贝尔数 $B_n$ 表示将 $n$ 个集合划分成若干个非空集合的方案数。 $B_n = \\sum_{i=0}^{n-1}C_{n-1}^{i}B_i$ $B_n = \\frac{1}{e}\\sum_{i \\geq0}\\frac{i^n}{i!}$ $B_n = \\sum_{i=0}^nS(n,i)$ $B_n$ 等于第二类斯特林数第 $n$ 行之和 对于质数$p$ ，$B_{p^m+n} = mB_n + B_{n+1}$ Bell数列模质数 $p$ 意义下的循环节长度为 $\\frac{p^p-1}{p-1}$ B = {1, 1, 2, 5, 15, 52, 203} 贝尔三角 用以下方法构造一个三角矩阵（形式类似杨辉三角形） 第一行第一项为 1 $(a_{1,1} = 1)$ 对于 $n &gt; 1$，第 $n$ 行第一项等于第 $n - 1$ 行的第 $n - 1$ 项 $(a_{n,1} = a_{n-1,n-1})$ 对于 $m, n &gt; 1$，第 $n$ 行的第 $m$ 项等于它左边和坐上角两数之和 $(a_{n,m} = a_{n,m-1} + a_{n-1,m-1})$ 1 1 2 2 3 5 5 7 10 15 15 20 27 37 52 52 67 87 114 151 203 每行的首项是贝尔数。可以利用这个三角形递推求出Bell数 分拆数 $p_n$ : 自然数 $n$ 的分拆为多个正整数的和的方案数， 特殊的 $p_0 = 1$ 该递推公式时间复杂度为$O(n\\sqrt{n})$ 也可以用完全背包 $O(n^2)$求解 $ p_n$ $k$ 部分拆数,$p(n,k)$: 自然数 $n$ 分拆为 $k$ 个正整数的和的方案数 $p(n,k)=\\sum_{j=0}^{k}p(n-k,j)$ $p(n,k) = p(n-1,k-1) + p(n-k,k)$ 用该递推式时间复杂度为 $O(nk)$ 最大 $k$ 分拆数 ：自然数 $n$ 分拆后最大的正整数为 $k$ 的方案数 根据 Ferrers 图与共轭可知， $n$ 的最大 $k$ 拆分数等于 $k$ 部分拆数，都为 $p(n,k)$ 互异拆分数($pd_n$) ：自然数 $n$ 拆分后各部分不相同的拆分数 互异$k$部分拆数,$pd(n,k)$ : 自然数 $n$ 拆分为 $k$ 个部分，且各部分不同的方案数 $pd(n,k)=pd(n-k,k-1)+pd(n-k,k)$ cayley定理 (凯莱定理): ​ 有n个标志节点的树的数量等于$n^{n-2}$ 生成函数 泰勒展开式 $\\frac{1}{1-x}=1+x^2+x^3+x^4 + \\dots$ $\\frac{1}{(1-x)^2}=1+2x+3x^2+ \\dots$ $e^x = 1+\\frac{x}{1!}+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\dots$ $e^{-x} = 1-\\frac{x}{1!}+\\frac{x^2}{2!}-\\frac{x^3}{3!}+\\dots$ $e^{px}=1+p\\frac{x}{1!}+p^2\\frac{x^2}{2!}+p^3\\frac{x^3}{3!}+\\dots$ $\\frac{e^x+e^{-x}}{2}=1+\\frac{x^2}{2!}+\\frac{x^4}{4!}+\\dots$ $\\frac{e^x-e^{-x}}{2}=\\frac{x}{1!}+\\frac{x^3}{3!}+\\frac{x^5}{5!}+\\dots$ 1.普通型母函数(OGF) 普通型母函数的乘法和“多重集的组合问题”有关 ​ 把一个数列的普通型母函数乘以 $1+x+x^2+x^3+ \\dots$ 相当于求其前缀和 ​ 把一个数列的普通型母函数乘以 $1-x$ 相当于求其差分 2.指数型母函数(EGF) 指数型母函数的乘法和“多重集的排列问题”有关。","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"常见序列","slug":"12","date":"2024-06-04T07:54:37.002Z","updated":"2024-06-04T08:06:03.303Z","comments":true,"path":"2024/06/04/12/","link":"","permalink":"/2024/06/04/12/","excerpt":"","text":"常见序列 f = {1, 1, 1, 3, 16, 125, 1296, 16807, 262144, 4782969, 100000000} f[i] = i ^ (i - 2)//前几项特判 f = {1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670} //卡特兰数列 f = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55}//斐波那契数列 B = {1, 1, 2, 5, 15, 52, 203}//贝尔数","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"STL","slug":"9","date":"2024-06-04T07:54:33.754Z","updated":"2024-06-04T08:06:10.722Z","comments":true,"path":"2024/06/04/9/","link":"","permalink":"/2024/06/04/9/","excerpt":"","text":"ios::sync_with_stdio(false);//同步流 cin.tie(0); vector v.insert(v.begin()+2, 1); // 指定位置，插入元素，O(n) vector&lt;ll&gt;::iterator it = find(v.begin(),v.end(),num); //返回的是一个迭代器指针,若未找到返回v.end(); rotate(v.begin(), it, v.end()); ////rotate : 将v.begin() 与 v.end()之间的元素从it(it为存在与begin 和 end 间的一个迭代器)位置进行左旋转, it所指元素为旋转后的首元素 ////rotate(v.begin(), v.begin() + 3, v.end()); //// 1 2 3 4 5 6 //// 4 5 6 1 2 3 string string aa = &quot;12345&quot;; s.append(aa, 0, 2); // 将字符串aa第0位开始的2个字符串追加到是s尾部 aa = s.substr(0, 2); // 将字符串s从第0位开始的2个字符串赋值给aa s.length() s.size() s = cin.get(); // 读入一个字符 getline(cin, s); // 读入一行 vector&lt;string&gt; vs; // string等都可以放入 s.find(&quot;a&quot;) // 在s中找&quot;a&quot;第一次出现的位置 s.find(&quot;a&quot;, 1) // 从下标1开始在s中&quot;a&quot;第一次出现的位置 s.find(&quot;a&quot;) == s.npos // 找不到返回npos （1）s.erase(pos,n);//删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符 （2）s.erase(position);//删除position处的一个字符(position是个string类型的迭代器) （3）s.erase(first,last);//删除从first到last之间的字符（first和last都是迭代器） set $O(\\log{size})$ #include &lt;set&gt; // 集合 自动去重 自动排序 内部使用红黑树实现 插入、查找时间复杂度都是log级别的 {2, 1, 1} -&gt; {1, 2} set&lt;int&gt; s; multiset&lt;int&gt; ms; // 不去重（注意删除操作） {1, 1, 2} erase(1) -&gt; {2} erase(iterator) s.insert(2); // 插入元素O(1) s.erase(2); // 删除元素 set&lt;int&gt;::iterator it; for (it = s.begin(); it != s.end(); ++it) {} set&lt;int&gt;::reverse_iterator rit; rit = prev(rit)//上一个 for (rit = s.rbegin(); rit != s.rend(); ++rit) {} for (auto v : s) s.lower_bound(2); s.upper_bound(2); // 找不到会返回s.end() s.find(2) == s.end() s.count(2) clear(); set&lt;pair&lt;ll, ll&gt;&gt; s; ll a = s.lower_bound(make_pair(a, b));//先找a,再找b set的lower_bound 比 std::lower_bound效率高很多 bitset bitset&lt;4&gt;s1(string(&quot;1001&quot;)); bitset&lt;4&gt;s2(string(&quot;0011&quot;)); cout&lt;&lt;s1.count()&lt;&lt;endl;//用于计算s1中1的个数 cout&lt;&lt;s1.size()&lt;&lt;endl;//s1的位数 cout&lt;&lt;s1.test(0)&lt;&lt;endl;//用于检查s1[0]是0 or 1并返回0 or 1 cout&lt;&lt;s1.any()&lt;&lt;endl;//检查s1中是否有1，并返回1or0 cout&lt;&lt;s1.all()&lt;&lt;endl;//检查s1中是否全部为1，并返回0or1 cout&lt;&lt;s1.none()&lt;&lt;endl;//检查s1中是否全不为1，并返回0or1 cout&lt;&lt;s1.flip(2)&lt;&lt;endl;//将参数位取反，0变1，1变0 cout&lt;&lt;s1.flip()&lt;&lt;endl;//不指定参数时，每一位取反 cout&lt;&lt;s1.set()&lt;&lt;endl;//不指定参数时，每一位变为１ cout&lt;&lt;s1.set(3,1)&lt;&lt;endl;//指定两位参数时，将第一参数位的元素变为第二参数的值，第二参数位只能为0or1 cout&lt;&lt;s1.set(3)&lt;&lt;endl;//只有一个参数时，将参数下标处变为１ cout&lt;&lt;s1.reset(4)&lt;&lt;endl;//一个参数时将参数下标处变为０ cout&lt;&lt;s1.reset()&lt;&lt;endl;//不传参数时将bitset的每一位变为０ string s = s1.to_string(); //将bitset转换成string unsigned long a = s1.to_ulong(); //将bitset转换成unsigned long unsigned long long b = s1.to_ullong(); //将bitset转换成unsigned long long cout&lt;&lt;s&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; merge merge(first1, last1, first2, last2, now, cmp)//将两个 有序 的序列合并为一个 有序 的序列 //first1 是第一个容器的首迭代器 //last1 是第一个容器的末迭代器 //first2 是第二个容器的首迭代器 //last2 是第二个容器的末迭代器 //now 合并之后要存放的容器首地址 //cmp为比较函数， 不写cmp则默认升序 vector&lt;ll&gt; v; v.resize(new size);//配合merge使用，不然会报错 iota #include &lt;iostream&gt; // std::cout #include &lt;numeric&gt; // std::iota int main () { int numbers[10]; std::iota (numbers,numbers+10,100);////从val(此处为100)开始逐个加一 for (int&amp; i:numbers) std::cout &lt;&lt; ' ' &lt;&lt; i;/////100 101 102 103 104 105 106 107 108 109 std::cout &lt;&lt; '\\n'; return 0; } 位运算函数 __builtin_ctz()//返回二进制下末尾0的个数 __buitlin_ctzll()//返回二进制末尾0的个数 __buitlin_clz()//返回二进制下前导0的个数，总长32 __buitlin_clzll()//返回二进制下前导0的个数，总长64 __builtin_popcount()//返回二进制下1的个数 __builtin_ffs()//返回二进制下最后一个1的位置(最后一个位置是1) nth_element nth_element(v.begin(), v.begin() + k, v.end(), cmp); 将第 k 大的元素(排序后放在v.begin()+k-1上的元素)放在 v.begin()+k-1 上，前面的元素都比它小，后面的都比它大 v.erase+remove_if bool isZero(int num){return num == 0;} int main(){ vector&lt;int&gt; v{1,2,0,3,4,0,0,5,6,7,8,9,0,0,8,0,9}; remove_if(v.begin(),v.end(),isZero); for(vector&lt;int&gt;::iterator it = v.begin();it!=v.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; return 0; } // 这里的输出为：1 2 3 4 5 6 7 8 9 8 9 9 0 0 8 0 9 //可以理解为用remove_if将容器中符合remove条件的元素移去，但容器的size不会改变。 //比如例中有6个0，最后六个位置是原序列最后六个元素，可以配合 erase 进行删除 vector&lt;int&gt; v{1,2,0,3,4,0,0,5,6,7,8,9,0,0,8,0,9}; v.erase(remove_if(v.begin(),v.end(),isZero),v.end()); //得到序列：1 2 3 4 5 6 7 8 9 8 9","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"找两个升序数组的中位数","slug":"7","date":"2024-06-04T07:51:49.681Z","updated":"2024-06-04T07:53:19.919Z","comments":true,"path":"2024/06/04/7/","link":"","permalink":"/2024/06/04/7/","excerpt":"","text":"LeetCode 4 ： 找两个升序数组的中位数(第 k 小) solution：每次删一半 int getkth(int l1, int l2, vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2, int k) { if(l1 == nums1.size()) return nums2[l2 + k - 1]; if(l2 == nums2.size()) return nums1[l1 + k - 1]; if(k == 1) return min(nums1[l1], nums2[l2]); int mid = k / 2; int r1 = min(nums1.size() - 1, l1 + mid - 1); int r2 = min(nums2.size() - 1, l2 + mid - 1); if(nums1[r1] &lt;= nums2[r2]) return getkth(r1 + 1, l2, nums1, nums2, k - (r1 - l1 + 1)); return getkth(l1, r2 + 1, nums1, nums2, k - (r2 - l2 + 1)); } double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int totlen = nums1.size() + nums2.size(); if((totlen) &amp; 1) return getkth(0, 0, nums1, nums2, totlen / 2 + 1); return (getkth(0, 0, nums1, nums2, totlen / 2) + getkth(0, 0, nums1, nums2, totlen / 2 + 1)) / 2.0; }","categories":[{"name":"题目","slug":"题目","permalink":"/categories/题目/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"/tags/LeetCode/"}],"keywords":[{"name":"题目","slug":"题目","permalink":"/categories/题目/"}]},{"title":"设计模式","slug":"6","date":"2024-06-04T06:58:29.241Z","updated":"2024-06-04T07:49:33.528Z","comments":true,"path":"2024/06/04/6/","link":"","permalink":"/2024/06/04/6/","excerpt":"","text":"常见的七种设计模式 单例模式、工厂方法模式、抽象工厂模式、代理模式、装饰器模式、观察者模式、责任链模式 软件设计七大原则（OOP原则） 开闭原则：对扩展开放，对修改关闭。 里氏替换原则：不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义。 依赖倒置原则：要面向接口编程，不要面向实现编程。 单一职责原则：控制类的粒度大小、将对象解耦、提高其内聚性。 接口隔离原则：要为各个类建立它们需要的专用接口。 迪米特法则：一个类应该保持对其它对象最少的了解，降低耦合度。 合成复用原则：多用组合设计类，少继承 单例模式(Singleton Pattern) ①单例类只有一个实例对象 ③单例类对外提供一个访问该单例的全局访问点 ④、优点 单例模式可以保证内存里只有一个实例，减少了内存的开销。 可以避免对资源的多重占用。 单例模式设置全局访问点，可以优化和共享资源的访问。 ⑤、缺点 单例模式一般没有接口，扩展困难。 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则 懒汉模式 延时加载， 由调用者实例，多线程情况下会存在线程安全问题，需要加互斥锁进行防护 #include&lt;iostream&gt; #include&lt;mutex&gt; using namespace std; /*单例模式：构造函数私有化，对外提供一个接口*/ //线程安全的单例模式 class Lazysingleton { public: static Lazysingleton* getinstance() { if (instance == nullptr) { i_mutex.lock(); if (instance == nullptr) { instance = new Lazysingleton(); } i_mutex.unlock();//解锁 } return instance; } private: static Lazysingleton* instance; static mutex i_mutex;//锁 Lazysingleton(){} Lazysingleton(const Singleton&amp;) = delete; Lazysingleton&amp; operator=(const Lazysingleton&amp;) = delete; }; Lazysingleton* Lazysingleton::instance=nullptr; mutex Lazysingleton::i_mutex;//类外初始化 int main() { Lazysingleton* lhsinglep5 = Lazysingleton::getinstance(); Lazysingleton* lhsinglep6 = Lazysingleton::getinstance(); cout &lt;&lt; lhsinglep5 &lt;&lt; endl; cout &lt;&lt; lhsinglep6 &lt;&lt; endl; return 0; } 饿汉模式 #include&lt;iostream&gt; using namespace std; /*单例模式：构造函数私有化，对外提供一个接口*/ //饿汉模式：不管用不用得到，都构造出来。本身就是线程安全的 class hungrysingleton { public: static hungrysingleton* getinstance() { return instance; } private: static hungrysingleton* instance; hungrysingleton() {} hungrysingleton(const hungrysingleton&amp;) = delete; hungrysingleton&amp; operator=(const hungrysingleton&amp;) = delete; }; hungrysingleton* hungrysingleton::instance = new hungrysingleton(); int main() { hungrysingleton* ehsinglep3 = hungrysingleton::getinstance(); hungrysingleton* ehsinglep4 = hungrysingleton::getinstance(); cout &lt;&lt; ehsinglep3 &lt;&lt; endl; cout &lt;&lt; ehsinglep4 &lt;&lt; endl; return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"SQL","slug":"5","date":"2024-06-04T06:56:14.867Z","updated":"2024-06-04T07:49:27.473Z","comments":true,"path":"2024/06/04/5/","link":"","permalink":"/2024/06/04/5/","excerpt":"","text":"CREATE DATABASE 数据库名; USE 数据库名; CREATE TABLE 表名( 列名1 类型, 列名2 类型 ); 增 insert into 表名(参数1,参数2...) values (参数1值,参数2值...); 这种方式是给部分参数或所有参数赋值 insert into 表名 values (参数1值,参数2值...); 这种方式必须给所有参数赋值 删 delete from 表名; 删除表中所有数据 delete from 表名 where 条件; 删除表中所有满足条件的数据 改 update 表名 set 参数1=参数1值,参数2=参数2值,...; 改变表中所有数据 update 表名 set 参数1=参数1值,参数2=参数2值,... where 条件; 改变表中所有满足条件的数据 查 select * from 表名; 查询表中所有数据 select * from 表名 where 条件; 查询表中所有满足条件的数据 select 参数1,参数2... from 表名; 查询表中部分参数 select 参数1,参数2... from 表名 where 条件; 查询表中满足条件的部分参数 去重 select distinct class_id from students; 排序 select name, age from students order by age asc; select name, score from students order by score desc; SELECT * FROM students ORDER BY CASE WHEN gender = '男' THEN 1 WHEN gender = '女' THEN 2 ELSE 3 END; 截断 -- LIMIT 后只跟一个整数，表示要截断的数据条数（一次获取几条） select task_name, due_date from tasks limit 2; -- LIMIT 后跟 2 个整数，依次表示从第几条数据开始、一次获取几条 select task_name, due_date from tasks limit 2, 2; 条件分支 --条件分支语法 /*CASE WHEN (条件1) THEN 结果1 * WHEN (条件2) THEN 结果2 * ... * ELSE 其他结果 END */ --将学生按照年龄划分为三个年龄等级（age_level） SELECT name, CASE WHEN (age &gt; 60) THEN '老同学' WHEN (age &gt; 20) THEN '年轻' ELSE '小同学' END AS age_level FROM student ORDER BY name asc; IFNULL expression 的值不是 NULL，返回expression的值，不然返回 alternative_value IFNULL(expression, alternative_value); SELECT contactname, IFNULL(bizphone, homephone) AS phone FROM contacts; 一定要配合 as 使用，不然字段名就是 “IFNULL(bizphone, homephone)” 聚合函数 COUNT：计算指定列的行数或非空值的数量。 SUM：计算指定列的数值之和。 AVG：计算指定列的数值平均值。 MAX：找出指定列的最大值。 MIN：找出指定列的最小值。 --汇总学生表中所有学生的总成绩（total_score）、平均成绩（avg_score）、最高成绩（max_score）和最低成绩（min_score），汇总数据条数（total） SELECT SUM(score) AS total_score, AVG(score) AS avg_score, MAX(score) AS max_score, MIN(score) AS min_score, COUNT(*) AS total FROM student; COUNT( column_name ) 返回指定列的值的数目，不会计入 NULL 值 COUNT(1) 和 COUNT(*) 都会记录NULL值 DATEDIFF DATEDIFF(日期1, 日期2)： 返回日期1与日期2相差的天数。 如果日期1比日期2大，结果为正；如果日期1比日期2小，结果为负 分组聚合 --单字段分组 --统计学生表中的班级编号（class_id）和每个班级的平均成绩（avg_score） SELECT class_id, AVG(score) AS avg_score FROM student GROUP BY class_id; --多字段分组 --统计学生表中每个班级每次考试的总学生人数（total_num） SELECT class_id, exam_num, COUNT(*) AS total_num FROM student GROUP BY class_id, exam_num; HAVING HAVING要用在 GROUP BY 后 SELECT name FROM Employee WHERE id IN (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT(*) &gt;= 5) ; 因为子查询有多条结果，所以要用 “id IN” 关联（连接） CROSS JOIN 普通关联，返回多个表的笛卡尔积 --将学生表和班级表的所有行组合在一起，并返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）以及班级名称（class_name） select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name from student s, class c; INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。注意，INNER JOIN 只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。 --根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level） select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s join class c on s.class_id = c.id; 左外连接（LEFT JOIN）：即使右表中没有匹配，也从左表返回所有的行 SELECT * FROM table1 RIGHT JOIN table2 ON condition; 右外连接（RIGHT JOIN）：即使左表中没有匹配，也从右表返回所有的行 SELECT * FROM table1 RIGHT JOIN table2 ON condition; NATURAL JOIN 自然连接， 用于在两个表中查找同名列并且这些列的值相同的行。自然连接会自动选择两个表中同名的、相同数据类型的列进行连接 SELECT * FROM employees NATURAL JOIN departments; 索引 //普通索引 CREATE INDEX index_name ON table_name(index_column_1); //联合索引 CREATE INDEX index_name ON table_name(index_column_1，index_column_2，...); 事务 START TRANSACTION;//执行第一条语句时启动事务 //start transaction with consistent snapshot//立即启动事务 COMMIT; 锁 全局锁 flush tables with read lock; unlock tables; 表锁 表级锁 //表级别的共享锁，也就是读锁； lock tables t_student read; //表级别的独占锁，也就是写锁； lock tables t_stuent write; unlock tables; 意向锁 //先在表上加上意向共享锁，然后对读取的记录加共享锁 select ... lock in share mode; //先表上加上意向独占锁，然后对读取的记录加独占锁 select ... for update; 行级锁 //对读取的记录加共享锁 select ... lock in share mode; //对读取的记录加独占锁 select ... for update;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"/tags/SQL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"c++","slug":"4","date":"2024-06-04T06:44:59.523Z","updated":"2024-06-04T07:49:22.591Z","comments":true,"path":"2024/06/04/4/","link":"","permalink":"/2024/06/04/4/","excerpt":"","text":"多态注意点 class B{ public: int a = 1; }; class D : public B{ public: int b = 1; }; int main() { D *pd = new D(); // 创建D类的对象 pd-&gt;a = 2; B *pb = pd; // 基类指针指向派生类对象 std::cout &lt;&lt; pb-&gt;a &lt;&lt; '\\n'; // std::cout &lt;&lt; pb-&gt;b &lt;&lt; '\\n'; error，基类指针pb指向派生类时，只能访问继承的部分 return 0; } 缺省参数早绑定，缺省参数对应的虚函数晚绑定 #include&lt;bits/stdc++.h&gt; using namespace std; class A{ public: A(){cout &lt;&lt; 1 &lt;&lt; '\\n';} A(A&amp;&amp; a) {cout &lt;&lt; 2 &lt;&lt; '\\n';} A(const A &amp;a) {cout &lt;&lt; 3 &lt;&lt; '\\n';}; void operator = (const A&amp; a) {cout &lt;&lt; 4 &lt;&lt; '\\n';} }; class B: public A{ public: B(){cout &lt;&lt; 'a' &lt;&lt; '\\n';} B(B&amp;&amp; b):A(b) {cout &lt;&lt; 'b' &lt;&lt; '\\n';} B(const B &amp;b):A(b) {cout &lt;&lt; 'c' &lt;&lt; '\\n';}; void operator = (const B&amp; b) {cout &lt;&lt; 'd' &lt;&lt; '\\n';} }; int main() { B b;//1a B m(b);//3c B p = b;//3c，注意是初始化不是赋值操作，会隐式转换成P(b) B q = move(b);//3b，注意A(b)进去就强转为左值了 return 0; } 虚函数实现原理 1、虚函数的实现方式，是编译器决定的 2、如果类定义了虚函数，编译器会为该类创建一个虚函数表（其实是一个指针数组，数组存放的元素是虚函数地址），该虚函数表并不存储在类里面，编译器为类创建了一个隐藏指针（该指针占用存储空间），该指针指向虚函数表。每个类对象都会有一个隐藏指针。 3、如果声明了虚函数的类被继承，那么它的虚函数表，会被子类复制拷贝（内容一样，物理空间独立），如果该 类覆盖了父类的虚函数，那么虚函数表里面对应的函数指针就会指向，子类的覆盖函数。如果子类新定义了其他虚函数，那么在该虚函数表的后面追加虚函数指针。 4、如果父类指针指向了一个子类对象，那么父类指针会获取子类对象的隐藏的虚函数表指针。当调用一个虚函数后，会通过虚函数表指针找到虚函数，再通过相对偏移，找到对应的虚函数指针，进而找到虚函数。 5、调用虚函数是根据其相对虚函数表的首地址的偏移来查找的，只要将基类的虚函数表指针换成子类的基函数指针，自动就会寻找到子类定义的虚函数。 this-&gt;vptr-&gt;vtable-&gt;virtual fun 虚函数表存放在全局区 普通类成员函数放在代码区 不能声明为虚函数的函数： 构造函数 友元函数 非类成员函数 静态成员函数 注意：内联函数可以为虚函数，但在表现多态性时不会进行内联(写没写inline是一样的)，因为内联函数是在编译时展开 编译器处理虚函数表应该如何处理 拷⻉基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表 还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派⽣类的主基类 查看派⽣类中是否有重写基类中的虚函数， 如果有，就替换成已经重写的虚函数地址；查看派⽣类是否有⾃ 身的虚函数，如果有，就追加⾃身的虚函数到⾃身的虚函数表中 虚析构函数 解决：多态使用时，如果子类中有属性开辟到堆区，那么父类的指针在释放时无法调用子类的虚构函数 如果声明了虚析构函数，则一定要有函数实现，不然在释放对象时会产生报错 纯虚函数可以没有函数实现，因为纯虚函数不能实例化对象 获取虚函数表，虚函数地址 #include&lt;bits/stdc++.h&gt; using namespace std; class intelCPU { public: virtual void run() { cout &lt;&lt; &quot;intelCPU 正在被调用&quot; &lt;&lt; '\\n'; } }; int main() { intelCPU a; cout &lt;&lt; *(int *)(&amp;a) &lt;&lt; '\\n';//虚函数表地址，虚函数表位于类地址的首位 int addr = *(int *)(&amp;a); cout &lt;&lt; *(int *)(addr + 0);//虚函数地址 *(int *)(addr + 4*x)，x从0开始，多一个虚函数就+1 return 0; } 菱形继承 虚继承 #include &lt;iostream&gt; using namespace std; class A { public: int a; }; class B : virtual public A { public: int b; }; class C : virtual public A { public: int c; }; class D : public B, public C //这里也可以加上virtual，但没有意义。但不能这里加virtual而上面没有加，因为这样会导致B，C中已经有各自独立的A的实例 { public: int d; }; int main() { D d; cout &lt;&lt; &amp;d.a &lt;&lt; endl;//输出相同，d中只有一份副本 cout &lt;&lt; &amp;d.B::a &lt;&lt; endl; cout &lt;&lt; &amp;d.C::a &lt;&lt; endl; return 0; } 虚继承中，D只会有一个虚函数表指针，指向ABC中虚函数共享的虚函数表 非虚继承中，D中会有两个虚函数表指针 c++11新特性 auto 别名模板 template &lt;typename T&gt; using Vec = std::vector&lt;T&gt;; template&lt;typename T, typename U&gt; struct A { T t; U u; }; template&lt;typename T&gt; using B = A&lt;T, int&gt;; int main() { B&lt;double&gt; b; b.t = 10; b.u = 20; cout &lt;&lt; b.t &lt;&lt; endl; cout &lt;&lt; b.u &lt;&lt; endl; return 0; } 智能指针 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象 ，防止堆内存泄漏。 当类对象声明周期结束时，自动调用析构函数释放资源。 头文件 C++11 引入 3 个智能指针类型： unique_ptr：独占资源所有权指针 unique_ptr 的使用比较简单，也是用得比较多的智能指针。当我们独占资源的所有权的时候，可以使用 unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源 unique_ptr 是 move-only 的，也是实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象的方法 { std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200); std::unique_ptr&lt;int&gt; uptr1 = uptr; // 编译错误，std::unique_ptr&lt;T&gt; 是 move-only 的 std::unique_ptr&lt;int&gt; uptr2 = std::move(uptr); assert(uptr == nullptr); } shared_ptr：共享资源所有权指针 shared_ptr 其实就是对资源做引用计数——当引用计数 sptr.use_count() 为 0的时候，自动释放资源。 { std::shared_ptr&lt;int&gt; sptr = std::make_shared&lt;int&gt;(200); assert(sptr.use_count() == 1); // 此时引用计数为 1 { std::shared_ptr&lt;int&gt; sptr1 = sptr; assert(sptr.get() == sptr1.get()); assert(sptr.use_count() == 2); // sptr 和 sptr1 共享资源，引用计数为 2 } assert(sptr.use_count() == 1); // sptr1 已经释放 } // use_count 为 0 时自动释放内存 #include &lt;iostream&gt; #include &lt;mutex&gt; using namespace std; template&lt;typename T&gt; class shared_ptr{ public: explicit shared_ptr(T *ptr = nullptr) :m_ptr(ptr), m_count(new unsigned int(0)), m_mutex(new mutex) { if(ptr != nullptr) addCount(); } explicit shared_ptr(const shared_ptr&lt;T&gt; &amp;sp) :m_ptr(sp.m_ptr), m_count(sp.m_count), m_mutex(sp.m_mutex) { addCount(); } shared_ptr&lt;T&gt;&amp; operator= (const shared_ptr&lt;T&gt; &amp;sp) { if(m_ptr != sp.m_ptr) { release(); m_ptr = sp.m_ptr; m_count = sp.m_count; m_mutex = sp.m_mutex; addCount(); } return *this; } T* operator-&gt; () { return m_ptr; } T operator* () { return *m_ptr; } T* get() { return m_ptr; } unsigned int getCount() { return *m_count; } ~shared_ptr() { release(); } private: T* m_ptr; unsigned int *m_count; mutex *m_mutex; void addCount() { m_mutex-&gt;lock(); ++(*m_count); m_mutex-&gt;unlock(); } void release() { bool deleteFlag = false; m_mutex-&gt;lock(); if(--(*m_count) == 0) { delete m_ptr; m_ptr = NULL; delete m_count; m_count = NULL; deleteFlag = true; } m_mutex-&gt;unlock(); if(deleteFlag) { delete m_mutex; m_mutex = NULL; } } }; int main() { shared_ptr&lt;int&gt; p1(new int(6)); cout &lt;&lt; p1.getCount() &lt;&lt; '\\n'; shared_ptr&lt;int&gt; p2(p1); cout &lt;&lt; p1.getCount() &lt;&lt; '\\n'; shared_ptr&lt;int&gt; p3; p3 = p1; cout &lt;&lt; p1.getCount() &lt;&lt; '\\n'; cout &lt;&lt; *p1 &lt;&lt; ' ' &lt;&lt; *p2 &lt;&lt; ' ' &lt;&lt; *p3 &lt;&lt; '\\n'; shared_ptr&lt;int&gt; p4(new int(7)); p3 = p4; cout &lt;&lt; p1.getCount() &lt;&lt; ' ' &lt;&lt; p4.getCount() &lt;&lt; '\\n'; return 0; } weak_ptr：共享资源的观察者，需要和shared_ptr一起使用 #include &lt;iostream&gt; #include &lt;memory&gt; class CB; class CA { public: CA() { std::cout &lt;&lt; &quot;CA()&quot; &lt;&lt; std::endl; } ~CA() { std::cout &lt;&lt; &quot;~CA()&quot; &lt;&lt; std::endl; } void set_ptr(std::shared_ptr&lt;CB&gt;&amp; ptr) { m_ptr_b = ptr; } private: std::shared_ptr&lt;CB&gt; m_ptr_b; }; class CB { public: CB() { std::cout &lt;&lt; &quot;CB()&quot; &lt;&lt; std::endl; } ~CB() { std::cout &lt;&lt; &quot;~CB()&quot; &lt;&lt; std::endl; } void set_ptr(std::shared_ptr&lt;CA&gt;&amp; ptr) { m_ptr_a = ptr; } private: std::weak_ptr&lt;CA&gt; m_ptr_a; }; int main() { std::shared_ptr&lt;CA&gt; ptr_a(new CA()); std::shared_ptr&lt;CB&gt; ptr_b(new CB()); ptr_a-&gt;set_ptr(ptr_b); ptr_b-&gt;set_ptr(ptr_a); std::cout &lt;&lt; ptr_a.use_count() &lt;&lt; &quot; &quot; &lt;&lt; ptr_b.use_count() &lt;&lt; std::endl;//1 2 return 0; } weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数 atomic 原子变量是特殊的数据类型，提供了一种线程安全的方式来访问和修改共享数据，而无需使用显式的互斥锁 。 memory库中的shared_ptr就是使用atomic保证的线程安全 atomic&lt;int&gt; a(1);//声明 b = a.fetch_add(1);//b = 1，a = 2，a.fetch_add(1)的返回值是原来的值 b = a.load();//b = 2，a.load()返回a的当前值 原子变量只有使用原子操作( fetch_add(后置自增) 、 compare_exchange_strong 、load(读)、store(修改)等)才是线程安全的 ++、–、+ 等有对应原子操作运算都会转换成原子操作 使用非原子操作函数来访问 std::atomic 变量的底层值，那么这些操作就不再是线程安全 内存序 C++11中的内存序（memory order）是一种用于指定原子操作在多线程环境中如何同步的机制。它定义了原子操作对内存的访问顺序，以及如何在不同线程之间传播内存修改的规则 只有原子操作支持内存序 c++11有6种内存序 名次解释： ​ **happens-before:**按照程序的代码序执行 ​ **synchronized-with:**不同线程间，对于同一个原子操作，需要同步关系，store操作一定要先于 load，也就是说 对于一个原子变量x，先写x，然后读x是一个同步的操作，读x并不会读取之前的值，而是写x后的值。 memory_order_relaxed 不对执行顺序做保证，没有 happens-before的约束。 // 线程 1 ： r1 = y.load(std::memory_order_relaxed); // A x.store(r1, std::memory_order_relaxed); // B // 线程 2 ： r2 = x.load(std::memory_order_relaxed); // C y.store(6, std::memory_order_relaxed); // D 执行顺序可能是DABC memory_order_acquire 和memory_order_release memory_order_release保证本线程中,所有之前的写操作完成后才能执行本条原子操作。 memory_order_acquire保证本线程中,所有后续的读操作必须在本条原子操作完成后执行。 #include &lt;thread&gt; #include &lt;atomic&gt; #include &lt;cassert&gt; #include &lt;string&gt; std::atomic&lt;std::string*&gt; ptr; int data; void producer() { std::string* p = new std::string(&quot;Hello&quot;); data = 42; ptr.store(p, std::memory_order_release); } void consumer() { std::string* p2; while (!(p2 = ptr.load(std::memory_order_acquire))) ; assert(*p2 == &quot;Hello&quot;); // 绝无问题 assert(data == 42); // 绝无问题 } int main() { std::thread t1(producer); std::thread t2(consumer); t1.join(); t2.join(); } memory_order_release和memory_order_acquire的组合提供了一种保证线程间操作顺序和可见性的机制，从而避免了数据竞争和其他并发错误。 如果只有memory_order_release而没有memory_order_acquire，虽然能保证data更新了，但可能因为缓存一致性导致执行 assert(data == 42); data的值不可见还是旧值0 memory_order_consume memory_order_acq_rel memory_order_acquire 和memory_order_release的结合 memory_order_seq_cst 同步模式，同时也是默认的模型，具有强烈的happens-before语义， 来保证指令的顺序一致执行，相当于不打开编译器优化指令，按照正常的指令序执行。多线程各原子操作也会Synchronized-with，譬如atomic::load()需要等待atomic::store()写下元素才能读取。更进一步地，读操作需要在“一个写操作对所有处理器可见”的时候才能读，适用于基于缓存的体系结构。 lambda(匿名函数) //[&amp;],[=],[A, B, C]只获得ABC auto f = [](int a, int b) -&gt;{ return a + b; } void fun1()//值捕获会在lambda创建时拷贝 { size_t v1 = 42; auto f = [v1]() mutable {return ++v1;}; v1 = 0; auto j = f();//43 } void fun2()//引用捕获会在lambda调用时引用 { size_t v1 = 42; auto f = [&amp;v1]() {return ++v1;}; v1 = 0; auto j = f();//1 } 右值 一个非引用左值强制类型转换后为右值 nullptr NULL是0，而nullptr就是空指针，有自己的类型 根据类型可以抛出异常 constexpr 可以用来判断一个表达式是否为常量表达式 在编译时就确定其修饰对象的值 constexpr指针 所指变量必须是全局变量或者static变量 const: 限定一个变量不允许被改变 如何const 修饰的变量是常量或表达式)式则在编译时确定值，不然在运行时确定值 引用类型必须于其所引用的对象类型一致，但用一种例外。 初始化常量[引用]时允许用任意表达式作为初始值 int i = 1; const int &amp;a = i;//correct const int b = i; final和overide关键字 overide：告诉编译器这个函数一定会重写基类中的虚函数，如果基类中没有该虚函数则编译无法通过 final：告诉编译器这个函数到当前截止，后面有类继承该类也不能重写该函数。也可以修饰类，表示该类不可以被继承 struct Base1 final { }; struct Derived1 : Base1 {}; // 编译错：Base1不允许被继承 struct Base2 { virtual void f1() final; virtual void f2(); }; struct Derived2 : Base2 { virtual void f1(); // 编译错：f1不允许重写 virtual void f2(int) override; // 编译错：⽗类中没有 void f2(int) }; C++14新特性 函数返回类型推导 auto func(int i) { return i; } lambda 参数 auto auto f = [] (int a) { return a; }//c++11 auto f = [] (auto a) { return a; };//c++14 变量模板 template&lt;class T&gt; constexpr T pi = T(3.1415926535897932385L); int main() { cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl; // 3 cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl; // 3.14159 return 0; } 放宽对constexpr的限制 C++11中constexpr函数可以使用递归，在C++14中可以使用局部变量和循环 constexpr int factorial(int n) { // C++14 和 C++11均可 return n &lt;= 1 ? 1 : (n * factorial(n - 1)); } constexpr int factorial(int n) { // C++11中不可，C++14中可以 int ret = 0; for (int i = 0; i &lt; n; ++i) { ret += i; } return ret; } C++11中constexpr函数必须必须把所有东西都放在一个单独的return语句中，c++14则无此限制 constexpr int func(bool flag) { // C++14 和 C++11均可 return 0; } constexpr int func(bool flag) { // C++11中不可，C++14中可以 if (flag) return 1; else return 0; } 二进制字面量与整形字面量分隔符 int a = 0b0001'0011'1010; double b = 3.14'1234'1234'1234; std::make_unique struct A {}; std::unique_ptr&lt;A&gt; ptr = std::make_unique&lt;A&gt;(); std::exchange exchange(a, b) 将a变成b，函数返回a的旧值 int main() { std::vector&lt;int&gt; v; std::exchange(v, {1,2,3,4}); cout &lt;&lt; v.size() &lt;&lt; endl; for (int a : v) { cout &lt;&lt; a &lt;&lt; &quot; &quot;; } return 0; } exchange源码 template&lt;class T, class U = T&gt; constexpr T exchange(T&amp; obj, U&amp;&amp; new_value) { T old_value = std::move(obj); obj = std::forward&lt;U&gt;(new_value); return old_value; } std::forward 是模板函数，用于实现完美转发，可以提高效率 当new_value是左值时，则将其拷贝给obj 当new_value是右值时，则将其移动给obj c++17新特性 构造函数模板推导 pair p(1, 2.2); // c++17 自动推导 vector v = {1, 2, 3}; // c++17 结构化绑定 折叠表达式 可以简化可变参数模板编程 template &lt;typename ... Ts&gt; auto sum(Ts ... ts) { return (ts + ...); } int a {sum(1, 2, 3, 4, 5)}; 命名空间嵌套定义 namespace A { namespace B { namespace C { void func(); } } } // c++17，更方便更舒适 namespace A::B::C { void func(); } c++20新特性 模块 **解决：**使用#include包含头文件进行模块化编程。但是#include是在预处理阶段引入文件里的内容，尤其是涉及到递归引入时，增加编译时长；头文件做出修改，所有引入该头文件的翻译单元均需要重新编译，也会增加编译时间；同时头文件内的宏、全局变量否是在全局命名空间中定义，易导致命名冲突 **改进了编译速度和性能 ：**模块会被编译器预先编译一次 **更快的构建时间：**由于模块可以减少头文件的重复解析和编译，因此可以加快整体的构建时间 **避免宏污染：**传统的#include预处理指令可能会引入不必要的宏定义，可能导致命名空间污染和意外的行为。使用模块可以减少这种情况的发生，因为模块的导入更为明确 **提高代码的可维护性：**模块提供了更清晰的接口和依赖关系，使得代码更易于理解、维护和重用。 //math_separate.ixx //该模块接口文件无模块全局片段 // 导出模块接口，模块接口部分 export module math_separate; // 定义模块接口 export int add(int a, int b); //math_separate.cpp module; #include&lt;iostream&gt; //如下一行含义为指明该文件为math_separate的实现文件 module math_separate; int add(int a, int b)//模块实现 { std::cout &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;=&quot; &lt;&lt; a + b &lt;&lt; &quot;\\n&quot;; return a + b; } 一个模块可以分割为一个模块接口文件和多个模块实现文件，可以存在一对多的关系 协程 协程是一个可以暂停执行以便稍后恢复的函数 。 协程的挂起和恢复是通过协程句柄(保存执行的上下文)来实现的。而不是通过阻塞线程来实现。 线程因为是linux系统内核提供，所以他是有独立的栈空间和执行上下文的。而协程则没有， 多个协程可能都在一个线程里面运行，他是一个轻量级的线程。 进程和线程切换都会有内核态和用户态的切换，而协程则是用户自己控制切换的时机，并不需要切换至内核态，所以这样以来执行效率非常高 适合异步执行，同步写法写异步代码，让异步代码更加简洁 c++20引入三个与协程相关的关键字 co_await：暂停协程并等待一个操作完成 co_yield ：返回一个值给协程的调用者，并暂停协程的执行 co_return：返回一个值并终止协程 主程序与协程间用 promise 进行通信，类似与管道 LRU class Node{ public: int key, val; Node *pre, *next; Node(int key, int val) { this-&gt;key = key; this-&gt;val = val; pre = NULL; next = NULL; } }; class LRUCache { public: LRUCache(int capacity) { this-&gt;capacity = capacity; head = new Node(-1, -1); tail = new Node(-1, -1); head-&gt;next = tail; tail-&gt;pre = head; } void remove(Node *p) { p-&gt;pre-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = p-&gt;pre; } void insert(Node *p) { p-&gt;next = head-&gt;next; p-&gt;pre = head; head-&gt;next-&gt;pre = p; head-&gt;next = p; } int get(int key) { if(hash.find(key) == hash.end()) return -1; Node *p = hash[key]; remove(p); insert(p); return p-&gt;val; } void put(int key, int value) { if(hash.find(key) != hash.end()) { Node* p = hash[key]; p-&gt;val = value; remove(p); insert(p); } else { if(hash.size() == capacity) { Node *p = tail-&gt;pre; remove(p); hash.erase(p-&gt;key); delete p; p = NULL; } Node *p = new Node(key, value); hash[key] = p; insert(p); } } ~LRUCache() { while(head != NULL) { Node *nowNode = head; head = head-&gt;next; delete nowNode; nowNode = NULL; } } private: int capacity; Node *head, *tail; unordered_map&lt;int, Node*&gt; hash; }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ STL vector 1、底层：动态数组。可以自动调整大小。它使用一块连续的内存块来存储元素，可以通过指针运算来快速访问元素。 当需要扩大容量时，会重新申请一块更大的内存，将原来的元素拷贝到新的内存块中，并释放原来的内存。 因此，在插入和删除元素时，可能需要移动内存块中的很多元素，导致效率低下，当然，要看实际操作如何。 2、时间复杂度 2.1 访问元素O(1)：支持随机访问，也就是可以通过下标或者迭代器直接访问任意位置的元素；指针运算直接获取地址。 2.2 插入、删除：在末尾插入删除时间复杂度为O(1)，不存在数据的移动；其他地方的情况下，时间复杂度平均为O(n)。 2.3 扩容O(n)：当容量capcity == size时需要扩容，申请一块新的地址空间，然后将数据拷贝到新的空间中。 vector容器对象，初始容量默认为0（C++11），如果进行数据添加一次，此时会扩容为1；若是再继续添加就会按照增加一倍的方式继续扩容（2、4、8...）。 2.4 查找元素O(n) 3、相关问题 3.1 vector内部如何实现动态扩容？ 当容量不足以存储新元素时，会分配一个更大的内存块，将原有元素复制到新内存中，并释放原来的空间。新的内存块大小通常为当前容量的2倍数。 3.2 vector如何避免内存浪费？ vector采取预留空间的机制，即在未使用完当前容量时，可以预留一定的额外空间，避免不必要的内存重新分配。通过调用reserve(newCapcity)函数可以提前分配好内存块的大小。 3.3 vector&lt;int&gt;和vector&lt;bool&gt; 的差异是什么？ vector&lt;int&gt;是将整数类型存储在连续的内存中，每个元素都占用固定字节数。 vector&lt;bool&gt;实现为位向量，每个元素都只占用一个二进制位，最小化内存占用。 3.4 vector的迭代器失效情况有哪些？ 当vector进行插入或者删除操作时，可能会导致指向元素的迭代器失效。取决于这些位置是否发生了改变，可能未改变。 3.6 vector和array的区别？ vector是一种动态数组，可以动态增加和删除元素； array是一种静态数组，一旦声明之后就无法改变大小。 此外，由于array是固定大小的，因此可以在栈上分配空间，比堆上分配的vector更快。 在main()中开一个vector&lt;int&gt; vec(5)，vec对象本身在栈上分配空间，但vec管理的内存，也就是vec中的元素实在堆上分配的。 ​ list 1、底层：双向链表，即每个节点都包含指向前驱和后继节点的指针。与vector不同，list的元素在内存中不是连续存储的，因此可以高效的插入或者删除任意位置的元素。 2、时间复杂度 bool empty() const： 判断 list 是否为空，O(1) size_type size() const： 返回 list 的大小，O(1) void resize(size_type sz, T c = T())： 调整 list 大小为 sz，新增的元素使用值 c 初始化，O(n) void clear()： 清空 list，O(n) reference front()，const_reference front() const： 返回第一个元素的引用，O(1) reference back()，const_reference back() const： 返回最后一个元素的引用，O(1) void push_front(const T&amp; x)： 在头部插入元素 x，O(1) void push_back(const T&amp; x)： 在尾部插入元素 x，O(1) void pop_front()： 删除头部元素，O(1) void pop_back()： 删除尾部元素，O(1) iterator insert(iterator position, const T&amp; x)： 在 position 前面插入元素 x，O(1) iterator erase(iterator position)： 删除 position 指向的元素，O(1) void remove(const T&amp; val)： 删除所有值为 val 的元素，O(n) void reverse()： 反转 list，O(n) void unique()： 删除相邻重复的元素，O(n) void sort()： 使用默认排序规则（operator&lt;）对 list 进行排序，O(n log n) bool operator==(const list&amp; rhs) const： 判断两个 list 是否相等，O(n) bool operator!=(const list&amp; rhs) const： 判断两个 list 是否不相等，O(n) 总体来说，list 在插入、删除、反转、查找等操作方面表现优秀，而在随机访问和排序方面则不如 vector 表现。 3、相关面试题 3.1 与vector相比，list有什么优点？ 主要优点是支持高效地在任何位置添加或者删除节点元素，不会导致迭代器失效； 缺点是不支持随机访问，只能通过迭代器来访问元素，另外，空间占用较大。 ​ deque（双端队列double-ended queue） 1、底层：一个或者多个连续地存储块，每个存储块内部是一个固定大小地数组。当deque容量不足时，会分配新的存储块。 这种设计使得deque可以在两端进行常数时间复杂度的插入和删除操作O(1)；在中间进行线性时间复杂度的插入和删除操作O(n)。 2、时间复杂度 2.1 头插尾插、头删尾删：O(1) 2.2 访问头元素和尾元素O(1) 2.3 在指定位置插入元素O(n) 总的来说，deque的优点在于支持高效的在两端进行插入和删除操作。但是如果存储块过多会导致性能下降，可用其他容器替代。 3、关于存储块 如果一个deque中的一个存储块中的数据被清空了，这个存储块还是会存在着，并占据一定空间。这是因为deque的实现通常由多个存储块组成，每个存储块都会被分配一定空间。即使一个存储块中的数据被删除了，这个存储块仍然会存在不会立即回收这些空闲存储块，只是变成了空闲状态。以备后续继续添加数据，避免频繁元素数据数量变动进行存储块的分配和释放操作。 一般情况下，当deque中的元素数量减少到某一定程度，实现会将多余的存储块释放掉，从而减少内存的占用，这个阈值可以是固定的也可以动态调整。 4、相关问题 4.1 deque优势在哪？ 它是一种双端队列容器，可以在队列的两端进行快速插入和删除。与vector相比，deque的插入和删除操作的时间复杂度更加稳定，不受插入和删除位置的影响。同时，deque支持随机访问和迭代器操作，可以快速定位元素，但是相比于vector的快速定位会更慢些。 4.2 deque和vector区别？ 底层数据结构：vector使用连续内存块存储元素，而deque使用多个固定大小的存储块组成的双向链表存储元素。 插入和删除操作：vector时间复杂度为O(n)，除了尾部操作（O(1)）.deque两端操作为O(1)。 迭代器失效：对于vector在插入和删除时，迭代器可能会失效；而deque只有在删除中间元素时，迭代器才会失效。 4.3 使用场景 需要在两端进行频繁插入和删除操作。 需要对大量元素进行随机访问。 当元素数量较大时，使用deque可以避免vector的内存管理问题和迭代器失效问题。 ​ set 1、介绍：一种关联容器，其中的元素按照一定的排序规则进行排序，并且每个元素只出现一次。因此可以使用set进行元素的查找和去重操作。 2、底层：红黑树结构，红黑树是一种自平衡的二叉查找树，相对于平衡二叉树性能更优。可以理解为平衡二叉树是对二叉排序树的优化，红黑树是对平衡二叉树的优化，在自平衡上提高了性能。 3、时间复杂度 3.1 插入元素(自排序)：O(logn) 3.2 删除元素：O(logn) 3.3 查找元素：O(logn) 3.4 遍历：O(n) ​ multiset：同set红黑树结构，只是允许数据相同，不会去重。 ​ unordered_set 1、介绍：是哈希表实现，提供了快速的元素查找、插入、删除等操作。 2、底层：unordered_set底层使用了哈希表，一种根据关键字直接访问内存存储位置的数据结构，因此具备非常快的查找和插入速度。内部维护了一个动态数组和一个哈希表，哈希表中存储着指向动态数组中元素的指针。每个元素的位置是由哈希函数计算出来的，不同的元素可能会被映射到同一个位置上，因此哈希表中的每个元素都是一个链表，用于解决冲突。 3、插入流程介绍： 有元素插入，根据该元素计算出该元素的哈希值，这个哈希值直接定位到内存地址，也就是上面动态数组中的位置（桶）； 如果该位置不存在任何元素，那么就插入； 但是，哈希函数表示绝对完美的，可能会出现多个元素映射到同一个地址，此时，会在桶中维护一个链表，将哈希值相同的元素存储在同一个链表中。这种情况下，若是冲突过多，查找效率会变低。 4、时间复杂度 4.1 插入：O(1); 最坏O(n)，也就是所有元素全部映射到一个地址。 4.2 删除：O(1)；最坏O(n) 4.3 查找：O(1)；最坏O(n) 4.3 遍历：O(n) 5、特点： 5.1 元素无序 5.2 不允许有重复元素，会去重 5.3 可以自定义哈希函数，用来计算元素的哈希值。在自定义类型中就需要自定义哈希函数，用于比较两个元素时候相同。 6、相关问题 6.1 实现原理是什么？ 通过哈希表实现，具体来说是一个数组，每个数组元素都是一个链表。当要插入或者查找元素时，首先根据元素的哈希值得到它在数组中的位置，然后在对应链表中进行操作。 6.2 使用场景？ 适用于需要快速查找和插入元素的场景，因为哈希表的查找和插入复杂度都是常数级别。 6.3 为什么unordered_set的迭代器只支持前向迭代器？ 因为底层是哈希表，每个桶中可能有多个元素，采用链表或者红黑树来解决哈希冲突。每个桶内的元素是无序的，不会按照用户的插入顺序存放，因此只能向前遍历每个桶中的元素。此外，内部的存储结构可能随时变化，因此迭代器的递增过程也比较复杂，只能实现向前遍历。 ​ map 1、介绍：是一个关联容器，用于存储键值对，其中的键和值都可以是任何类型。每个键在map中都是唯一的，内部采用红黑树实现。 2、底层：底层使用红黑树实现，每个节点包含一个键值对pair，按照键值关系构建一颗二叉查找树。 3、时间复杂度： 插入、删除、查找 ： O(logn); 遍历O(n) 虽然能够自平衡，但是在极端情况下会退化为链表，比如插入的数据有序。 4、特性： 类似于set，根据键自动排序；可自定义比较函数。如果插入键相同的元素，那么之前的值会被替换成新插入的。 5、相关问题 5.1 Map 和 unordered_map 的区别是什么? Map 和 unordered_map 都是 C++ 中的关联式容器，它们的区别在于底层的实现方式不同。Map 使用红黑树来实现，而 unordered_map 使用哈希表来实现。因此，在大多数情况下，unordered_map 的查找和插入操作比 Map 更快，但是在某些情况下，Map 的性能可能会更好。 ​ multimap：基本同map，但是可以插入键相同的元素。 ​ unordered_map（底层类似于unordered_set) 1、介绍： unordered_map（无序映射）是一种关联容器，用于存储由键值对组成的元素。它使用哈希表作为底层实现，可以实现常数时间内的查找、插入和删除操作，因此在需要快速访问元素的场景中很有用。 2、底层：unordered_map 的底层实现是哈希表，哈希表是一种通过哈希函数将键映射到值的数据结构。哈希表通常包含一个数组，每个元素都是一个桶，桶中存放着哈希值相同的键值对。 3、时间复杂度 查找一个元素（operator[]、at、find）：平均时间复杂度为 O(1)，最坏情况下为 O(n)； 插入一个元素（insert）：平均时间复杂度为 O(1)，最坏情况下为 O(n)； 删除一个元素（erase）：平均时间复杂度为 O(1)，最坏情况下为 O(n)； 遍历所有元素（begin/end/for）：时间复杂度为 O(n)。 4、相关问题 4.1 unordered_map 是如何实现的？ unordered_map 通常是使用哈希表实现的，它的键和值都存储在桶中。哈希表将键映射到桶中，这是通过哈希函数计算出来的。当多个键被映射到同一个桶时，它们存储在链表中。当链表变得太长时，它们被转换为更高效的数据结构，如红黑树。 4.2 unordered_map 的底层数据结构是什么？ unordered_map 的底层数据结构是哈希表，具体实现可能会有所不同，但通常包括一个桶数组和一个哈希函数。 4.3 unordered_map 的时间复杂度是什么？ 在平均情况下，unordered_map 的插入、删除和查找操作的时间复杂度都是 O(1)，但在最坏情况下，这些操作的时间复杂度会退化到 O(n)。这是因为如果哈希函数产生的哈希冲突太多，就会导致链表变得非常长，降低了效率。 ​ stack 1、介绍：一种先进后出的容器，即栈。 2、底层使用deque进行二次封装。因此它也可以动态扩容。 ​ queue 1、介绍：是一种先进先出的数据结构。队列容器在任务队列、消息队列等应用中非常常见。 2、底层：通常使用deque作为其底层数据结构来实现。但是queue是不支持随机访问的。 ​ array 1、底层：底层是C++的普通数组，是固定大小的。初始化时需要指定大小 强制类型转换 1.静态转换(static_cast)：可以用于基本数据类型之间的转换，也可以将基类指针或引用转换为派生类指针或引用，但是转换时需要保证类型转换是安全的。静态转换不能用于去除对象的const、volatile属性。 2.动态转换(dynamic_cast)：主要用于将基类指针或引用转换为派生类指针或引用，但是转换时需要判断类型转换是否安全，如果不安全则返回空指针。只有指向具有多态性质的类的基类指针或引用才能使用dynamic_cast。 **安全：**基类至少有一个虚函数，基类指针指向的需要是派生类对象 **用法：**static_cast&lt;目的类型&gt;(表达式) 基类和派生类之间的转换–没有virtual class A { public: void fn() { cout &lt;&lt; &quot;A::fn&quot; &lt;&lt; endl; } void gn() { cout &lt;&lt; &quot;A::gn&quot; &lt;&lt; endl; } }; class B :public A { public: void fn() { cout &lt;&lt; &quot;B::fn&quot; &lt;&lt; endl; }//隐藏，没有虚 void hn() { cout &lt;&lt; &quot;B::hn&quot; &lt;&lt; endl; } }; int main() { A a; B b; A* pa = &amp;b; pa-&gt;fn();//A pa-&gt;gn();//A // B* pb = &amp;a;//error B* pb = static_cast&lt;B*&gt;(&amp;a); pb-&gt;fn();//B pb-&gt;gn();//A pb-&gt;hn();//B pb-&gt;A::fn();//A } 两个无关类 #include&lt;bits/stdc++.h&gt; using namespace std; class A { public: void fn() { cout &lt;&lt; &quot;A::fn&quot; &lt;&lt; endl; } }; class B { public: B(A&amp;a){}//构造函数可以进行强转 void gn() { cout &lt;&lt; &quot;B::gn&quot; &lt;&lt; endl; } }; int main() { A a; B b = static_cast&lt;B&gt;(a);//B b(a); b.gn(); } 关键字 volatile： 允许修饰的变量被一些未知的外部因素访问，如操作系统和硬件，所以访问该变量时都会重新从内存中读取数据 volatile int i； extern： 作用1.对变量或函数进行声明，表示在别处定义要在此处声明。 //config.cpp int globalConfig = 42; // main.cpp #include &lt;iostream&gt; extern int globalConfig; int main() { std::cout &lt;&lt; &quot;Global Config value is: &quot; &lt;&lt; globalConfig &lt;&lt; std::endl; return 0; } g++ -c config.cpp -o config.o g++ -c main.cpp -o main.o g++ config.o main.o -o program.exe //链接 ./program.exe 如果不写 “extern int globalConfig;” 则会在编译的编译过程中产生报错 作用2： 指示 C 或者 C+＋函数的调⽤规范， 在 C++ 中调用 C 库函数，就需要在 C++ 程序中用 extern “C” 声明要引用的函数 。原因就是 C++ 和 C 程序编译完成后在目标代码中命名规则不同 类只能动态分配和只能静态分配 **动态分配：**将析构函数设置为protected类型，因为在栈上分配空间会先检查析构函数是否可访问，不可访问会拒绝申请 **静态分配：**将new运算符设置为私有，禁用 class A { private: void* operator new(size_t t){} //注意函数的第一个参数和返回值都是固定的 void operator delete(void* ptr){} //重载了new就需要重载delete }; 堆排序 #include&lt;bits/stdc++.h&gt; using namespace std; void keep_heap(vector&lt;int&gt; &amp;v, int n, int node) { int left = node * 2 + 1; int right = node * 2 + 2; if(left &gt; n - 1) return; if(right &gt; n - 1) { if(v[node] &lt; v[left]) { swap(v[node], v[left]); keep_heap(v, n, left); } } else { if(v[left] &gt; v[node] &amp;&amp; v[left] &gt;= v[right]) { swap(v[node], v[left]); keep_heap(v, n, left); } else if(v[right] &gt; v[node] &amp;&amp; v[right] &gt;= v[left]) { swap(v[node], v[right]); keep_heap(v, n, right); } } } void big_heap(vector&lt;int&gt; &amp;v) { int node = v.size() / 2 - 1; while(node &gt;= 0) { keep_heap(v, v.size(), node); node--; } } void heap_sort(vector&lt;int&gt; &amp;v) { big_heap(v); int n = v.size(); for(int i = n - 1; i &gt;= 0; i--) { swap(v[0], v[i]); n--; keep_heap(v, n, 0); } } int main() { vector&lt;int&gt; v = {91,60,96,13,35,65,46,65,10,30,20,31,77,81,22}; heap_sort(v); for (auto it : v) cout &lt;&lt; it &lt;&lt; &quot; &quot;; return 0; } 希尔排序 // 希尔排序 void shellSort(vector&lt;int&gt;&amp; nums) { for (int gap = nums.size() / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; nums.size(); ++i) { for (int j = i; j - gap &gt;= 0 &amp;&amp; nums[j - gap] &gt; nums[j]; j -= gap) { swap(nums[j - gap], nums[j]); } } } } 编译过程 **预处理：**展开所有宏、删除注释等。将 .c 文件转换为 .i 文件 编译： 把预处理完的文件进行一系列语法分析、语义分析以及优化后生成相应的汇编代码文件，.i 转换为 .s 汇编：将汇编语言转换为机器指令(二进制)，.s 转换为 .o 链接：将所有 .o 文件和库链接在一起生成可执行文件。.o 转换为 .out 静态链接库和动态链接库 静态链接库是把lib文件中用到的函数代码直接链接进目标程序，运行时就不需要其它的库文件 动态链接库是把调用函数所在的DLL文件和函数在文件中的位置等信息链接进目标程序，运行时查找相关代码 模板 非类型模板参数 template&lt;unsigned int N, unsigned int M&gt; void compare(char (&amp;p1) [N], char (&amp;p2) [M]){ cout &lt;&lt; N &lt;&lt; ' ' &lt;&lt; M &lt;&lt; '\\n'; } 使用 compare(“hi”, “mom”)会实例化成 compare(char (&amp;p1) [3], char (&amp;p2) [4]) 因为会在字符串字面常量末尾插入一个 ‘\\0’ 类模板被实例化时，成员变量会被实例化，而成员函数需要在使用时才会被实例化。 可变参数模板 可变参数函数通常是递归的 #include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt; void print(const T &amp;t) { cout &lt;&lt; t &lt;&lt; ' '; } template&lt;typename T, typename... Args&gt; void print(const T &amp;t, const Args&amp;... args) { cout &lt;&lt; t &lt;&lt; ' '; print(args...); //函数参数展开，等价于print(a1, args(a2,a3,...,an)) } template&lt;typename... Args&gt; void write(const Args&amp;... args) { (print(args), ...);//折叠表达式，需要使用分隔符隔开 //等价于 print(a1),print(a2),...,print(an) } int main() { print(1, 2, 6.1, &quot;abc&quot;);//输出 1, 2, 6.1, &quot;abc&quot; write(1, 2, 6.1, &quot;abc&quot;);//输出 1, 2, 6.1, &quot;abc&quot; return 0; } 模板特例化 template &lt;typename T, int Line, int Column&gt; // (1) class Matrix; template &lt;typename T&gt; // (2) class Matrix&lt;T, 3, 3&gt;{}; template &lt;&gt; // (3) class Matrix&lt;int, 3, 3&gt;{}; 主模板 第 (1) 行是主模板。主模板必须在部分或全特化模板之前声明。如果不需要主模板，像第 (1) 行这样的声明就可以了。 偏特化 第 (2) 行是偏特化模板。只有类模板支持偏特化。一个偏特化模板有模板形参和明确指定的模板实参。在这个例子中，类 Matrix 的 T 是模板形参，数字是模板实参。 全特化 第 (3) 行是全特化模板。“全”意味着所有的模板实参都已明确，模板形参列表为空：正如第 (3) 行的 template &lt;&gt; 所示。 使用模板特例化，判断两个数据类型是否相同 // 主模板定义 template&lt;class T1, class T2&gt; class my_is_same { public: operator bool() { // 重载隐式转换 return false; } }; // 特例化定义，当两个类型参数相同 template&lt;class T1&gt; class my_is_same&lt;T1, T1&gt; { public: operator bool() { return true; } }; int main() { // 使用 my_is_same 来判断两个类型是否相同 std::cout &lt;&lt; std::boolalpha &lt;&lt; my_is_same&lt;int, float&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; my_is_same&lt;int, int&gt;() &lt;&lt; std::endl; return 0; } 类型擦除 类型擦除指的是通过一些技术擦除c++的类型信息，使得一个数据结构或算法能够应用于不同类型的数据 技术是通过模板和多态(父类指针指向子类对象) c++内存分区 全局静态区、常量区、代码区、堆区、栈区 堆和栈的区别 **堆：**需要手动分配内存，低地址向高地址扩展。不连续内存空间，会产生内存碎片。 **栈：**自动分配内存，高地址向低地址扩展。连续内存空间，不会产生内存碎片。 sizeof sizeof 是运算符 int i = 1; cout &lt;&lt; i &lt;&lt; '\\n';//1 cout &lt;&lt; sizeof(++i) &lt;&lt; '\\n';//4 cout &lt;&lt; i &lt;&lt; '\\n';//1 因为sizeof会在编译时确定大小 union union变量共用内存 union u { int a; int b; }; union u mu; mu.a = 1; cout &lt;&lt; mu.b;//输出：mu.b = 1 占用内存为最大的变量类型所占用内存的整数倍 union u { char a[9]; //9*1=9字节 int b[3]; //3*4=12字节 double c; //8字节 }; cout &lt;&lt; sizeof(union u);// 输出16 #8*2=16大于任意变量所需字节数 大端小端 在union中，数据都是从低地址开始存放，所以可以用来判断是大端还是小端 union A{ char a; int b; /* char 占一个字节,int占四个字节 所以联合体的大小为四个字节,且a b公用一块内存 当对b赋值为1时,则b=0x00 00 00 01; ====》数据从高到低 地址从低到高 当为大端模式时:读取a得到的值为0; ====》低位地址高位数据 当为小端模式时:读取a得到的值为1; ====》低位地址低位数据 */ }; union { int a; char b[2]; char c; } u; int main() { u.a = 0; u.b[0] = 0x10; u.b[1] = 0x11; cout &lt;&lt; hex &lt;&lt; u.a &lt;&lt; '\\n';//1110，b[0]是低位，b[1]是高位 u.c = 0x22; cout &lt;&lt; hex &lt;&lt; u.a &lt;&lt; '\\n';//1122，c占用b[0]的位置 return 0; } #include &lt;iostream&gt; using namespace std; union{ int a; char b[3]; }u; int main() { u.a = 0; u.b[0] = 0x1; u.b[1] = 0x2; u.b[2] = 0x3; cout &lt;&lt; hex &lt;&lt; u.a;//输出30201 return 0; } new new 可以在指定地址上进行调用 一般用于在预分配的内存块中分配对象 #include &lt;iostream&gt; class MyClass { public: MyClass() { std::cout &lt;&lt; &quot;Constructor called.&quot; &lt;&lt; std::endl; } ~MyClass() { std::cout &lt;&lt; &quot;Destructor called.&quot; &lt;&lt; std::endl; } }; int main() { char buffer[sizeof(MyClass)]; // 预分配内存 MyClass* obj = new (buffer) MyClass(); // 在指定地址上构造对象 obj-&gt;~MyClass(); // 显式调用析构函数 // 如果 buffer 是动态分配的，还需要手动释放内存 return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"写一个函数在 main 函数执⾏前先运⾏","slug":"3","date":"2024-04-16T10:37:55.467Z","updated":"2024-04-16T10:46:40.678Z","comments":true,"path":"2024/04/16/3/","link":"","permalink":"/2024/04/16/3/","excerpt":"","text":"//第⼀种：gcc扩展，标记这个函数应当在main函数之前执⾏。同样有⼀个__attribute((destructor))，标记函 //数应当在程序结束之前（main结束之后，或者调⽤了exit后）执⾏; __attribute((constructor))void before() { printf(&quot;before main 1\\n&quot;); } //第⼆种：全局 static 变量的初始化在程序初始阶段，先于 main 函数的执⾏ int test1(){ cout &lt;&lt; &quot;before main 2&quot; &lt;&lt; endl; return 1; } static int i = test1(); // 第三种：知乎⼤⽜ Milo Yip 的回答利⽤ lambda 表达式 int a = []() { cout &lt;&lt; &quot;before main 3&quot; &lt;&lt; endl; return 0; }(); int main(int argc, char** argv) { cout &lt;&lt; &quot;main function&quot; &lt;&lt;endl; return 0; } 输出 before main 2 before main 3 before main 1 main function 其中 2 和 3 取决于调用位置","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"子数组和为0计数","slug":"2","date":"2024-04-04T13:45:51.399Z","updated":"2024-06-04T06:50:22.584Z","comments":true,"path":"2024/04/04/2/","link":"","permalink":"/2024/04/04/2/","excerpt":"","text":"B. Eugene and an array（一个数组中，求和为0的子数组的数量） https://codeforces.ml/group/DOZ49JViPG/contest/380948/problem/B 题意：定义一个数组为 good array 如果该数组的所有子数组和都不为 0 求一个数组中有多少个子数组是 good array。 思路：运用前缀和查找出和为 0 的子数组，若前缀 pre[i] 之前存在一个相同的 pre[j] (j &lt; i)， 则子数组 [j, i] 的和为 0, 若 pre[i] == 0， 则其本身也是一个和为 0 的子数组。 #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll N = 2e5 + 5; ll n, pre[N]; map&lt;ll, ll&gt; mp;//记录前缀和相同的最右边的位置 void solve() { cin &gt;&gt; n; ll ans =n * (n + 1) / 2;//答案最大值为 n * (n + 1) / 2, 后续处理删除不符合条件的子数组 ll l = 0;//用l标记左边已经处理到的位置，l前面的无需处理，否则会造成重复子数组的删除 for (ll i = 1, x; i &lt;= n; i++) { cin &gt;&gt; x; pre[i] = pre[i - 1] + x;//预处理前缀和 } for (ll i = 1; i &lt;= n; i++) { if (mp[pre[i]] + 1 &gt; l &amp;&amp; (mp[pre[i]] || !pre[i]))//要删除[mp[pre[i]] + 1, i]的子数组，若mp[pre[i]] + 1 &gt; l则当前可删除为删除过的子数组(删除区间[l, mp[pre[i]] + 1 &gt; l]中的部分元素) { ans -= (mp[pre[i]] - l + 1) * (n - i + 1);//删除不符合条件并且没有删过的子数组 l = mp[pre[i]] + 1;//将l更新至最右边， 端点在左边不符合条件的子数组均已删除 } mp[pre[i]] = i; } cout &lt;&lt; ans &lt;&lt; '\\n'; }","categories":[{"name":"题目","slug":"题目","permalink":"/categories/题目/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"/tags/codeforces/"}],"keywords":[{"name":"题目","slug":"题目","permalink":"/categories/题目/"}]},{"title":"LCA算法板子","slug":"1","date":"2024-03-25T09:54:14.393Z","updated":"2024-06-04T06:48:47.093Z","comments":true,"path":"2024/03/25/1/","link":"","permalink":"/2024/03/25/1/","excerpt":"","text":"LCA tarjan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll N = 5e5 + 7; vector&lt;ll&gt; G[N], Q[N]; ll ans[N][3], fa[N], n, m, s; ll vis[N]; void init() { for (ll i = 0; i &lt; N; i++) fa[i] = i; } int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); } void tarjan(int u) { vis[u] = 1;//标记该点已被访问 for (auto i : Q[u]) { if (vis[ans[i][1]] &amp;&amp; vis[ans[i][0]]) ans[i][2] = find(ans[i][0] == u ? ans[i][1] : ans[i][0]); } for (auto v : G[u]) {//父亲是靠近根节点的节点 if (vis[v]) continue; tarjan(v); fa[v] = u;//v的子节点已全部访问完 } } signed main() { init(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;//顶点数、询问次数、根节点 for (int i = 1, x, y; i &lt; n; i++) cin &gt;&gt; x &gt;&gt; y, G[x].push_back(y), G[y].push_back(x);//存图 for (int i = 1; i &lt;= m; i++)//存询问 { cin &gt;&gt; ans[i][0] &gt;&gt; ans[i][1]; Q[ans[i][0]].push_back(i); Q[ans[i][1]].push_back(i); } tarjan(s); for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i][2] &lt;&lt; '\\n'; return 0; } 倍增 两个节点到达同一节点后，不论怎么向上走，达到的显然还是同一节点 int fa[21][N], dep[N]; void dfs(int x, int pre, int d)//找到每个节点父亲与深度 { fa[0][x] = pre; dep[x] = d; for(auto &amp;to : g[x]) if(to != pre) dfs(to, x, d + 1); } int LCA(int u, int v) { if(dep[u] &gt; dep[v]) swap(u, v); int temp = dep[v] - dep[u];//将u v移到同一深度 for(int i = 0; ((1 &lt;&lt; i) &lt;= temp); i++) if((1 &lt;&lt; i) &amp; temp) v = fa[i][v]; if(u == v) return u; for(int i = log2(n); i &gt;= 0; i--)//两个节点一起往上走 { //最多合法的跳跃是 2 ^ log2(n) if(fa[i][u] != fa[i][v])//如果相同则代表跳的太多了 { u = fa[i][u]; v = fa[i][v]; } } return fa[0][u]; } void init_LCA()// 注意根节点是什么，dfs 默认是根节点是 1 { for(int j = 0; j &lt;= 20; j++) for( int i = 1; i &lt;= n; i++) fa[j][i] = 0; dfs(root, -1, 0); for(int j = 0; (1 &lt;&lt; j) &lt;= n; j++)//预处理出每个节点往上走2^j所到的节点，超过根节点记为-1 { for(int i = 1; i &lt;= n; i++) { if(fa[j][i] &lt; 0) fa[j + 1][i] = -1; else fa[j + 1][i] = fa[j][fa[j][i]]; } } }","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]},{"title":"DP","slug":"8","date":"2023-01-01T07:30:57.361Z","updated":"2024-06-04T08:06:14.016Z","comments":true,"path":"2023/01/01/8/","link":"","permalink":"/2023/01/01/8/","excerpt":"","text":"单调队列优化 单调队列(滑动窗口)优化动态规划问题的基本形态：当前状态的所有值可以从上一个状态的某个连续的段的值得到，要对这个连续的段进行 RMQ 操作，相邻状态的段的左右区间满足非降的关系。 //https://codeforces.com/problemset/problem/372/C /* 题意：你在一个长度为n的大街上，有m次烟花表演，分别在t[i]时刻上演，假设你现在站在位置x上，你观看第i次烟花表演，可以获得b[i]-abs(a[i]-x) 的幸福值（不能不看），然后你每一个时刻可以移动d个单位长度，开始你可以在任意位置，不能走出大街，问你最多能获得多少幸福值 */ int n, m, d, a[N], b[N], t[N]; int q[N]; ll dp[2][N]; void solve()//时间复杂度O(nm) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i]; int cur = 1; for(int i = 1; i &lt;= m; i++) { int l = 1, r = 0, k = 1; for(int j = 1; j &lt;= n; j++) { for(; k &lt;= min(1ll * n, j + 1ll * d * (t[i] - t[i - 1])); k++) { while(l &lt;= r &amp;&amp; dp[cur ^ 1][q[r]] &lt; dp[cur ^ 1][k]) r--; q[++r] = k; } while(l &lt;= r &amp;&amp; q[l] &lt; max(1ll, j - 1ll * d * (t[i] - t[i - 1]))) l++; dp[cur][j] = dp[cur ^ 1][q[l]] + b[i] - abs(a[i] - j); } cur ^= 1; } ll ans = -INF; for(int j = 1; j &lt;= n; j++) ans = max(ans, dp[cur ^ 1][j]); cout &lt;&lt; ans &lt;&lt; '\\n'; } 单调队列优化多重背包 //n 种物品，背包容量 m，第 i 种物品最多有 s[i] 件，每件体积是 v[i]，价值是 w[i]。 const int N = 1e3 + 10; int n, m; int f[2][20005], que[20005]; void solve()//时间复杂度O(nm)，O(物品种数 * 背包容积) { cin &gt;&gt; n &gt;&gt; m; int cur = 1; for(int i = 1; i &lt;= n; i++) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int r = 0; r &lt; v; r++)//枚举余数 { for(int k = 0, head = 1, tail = 0; r + k * v &lt;= m; k++) { while(head &lt;= tail &amp;&amp; k - que[head] &gt; s) head++; while(head &lt;= tail &amp;&amp; f[cur ^ 1][r + que[tail] * v] - que[tail] * w &lt;= f[cur ^ 1][r + k * v] - k * w) tail--; que[++tail] = k; f[cur][r + k * v] = f[cur ^ 1][r + que[head] * v] + (k - que[head]) * w; } } cur ^= 1; } cout &lt;&lt; f[cur ^ 1][m] &lt;&lt; '\\n'; } 斜率优化DP 最小值维护下凸包，最大值维护上凸包 $x$ 单调，但斜率不单调，可以二分切点 可以宏定义/函数 $x , y$ 来减少内存 宏定义时，表达式最外面记得加括号，不然运算顺序不对！！！！！！！！！！！！！！！！！！ //https://loj.ac/p/10188 /* f[i] = min{f[j] + (i - (j + 1) + pre[i] - pre[j] - C) ^ 2} 令 L = C + 1, s[i] = pre[i] + i 则 f[i] = min{f[j] + (s[i] - s[j] - L) ^ 2} 将与j无关的移到外面 则 f[i] - (s[i] - L) ^ 2 = min{f[j] + s[j] ^ 2 + 2 * s[j] * (L - s[i])} 因 y = kx + b, 移项得 b = y - kx 将与 j 有关的信息表示为 y 的形式 把同时与 i, j 相关的信息表示为 kx 把需要最小化的信息(与 i 有关的信息)表示为 b 的形式， 也就是截距 x[j] = s[j] y[j] = f[j] + s[j] ^ 2 k[i] = -2(L - s[i]) b[i] = f[i] - (s[i] - L) ^ 2 则 b[i] = min{y[j] - k[i] * x[j]} 把 x, y 看做二维平面上的点，那问题就转化为最小化截距 ***可以看出在本题新加入的决策点的横坐标单调，斜率k也单调 将一条斜率为 k[i] 的直线从下往上移动，第一个碰到的点 p 就是最优转移点 所以只有下凸包上的点可能成为转移点 考虑使用单调队列维护下凸壳上的点 队列中的点满足条件 K(i - 1, i) &lt; K(i, i + 1) 同时维护一个指针 p 维护最优转移点，因为 k[i] 递增， 所以 p 也递增 在插入一个点时， 要判断队尾还是否是下凸壳上的点，若满足 K(r-1, r) &lt;= K(r, i) 则是下凸壳上的点 */ int n, L; ll pre[N], s[N]; int que[N], head, p; ll x[N], y[N], f[N]; void solve() { cin &gt;&gt; n &gt;&gt; L; L++; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; pre[i]; pre[i] += pre[i - 1]; s[i] = pre[i] + i; } que[++head] = 0; p = 1; for(int i = 1; i &lt;= n; i++) { ll k = -2 * (L - s[i]); while(p &lt; head &amp;&amp; k * (x[que[p + 1]] - x[que[p]]) &gt;= y[que[p + 1]] - y[que[p]]) p++;//维护最大值就把 &gt;= 改成 &lt;= f[i] = y[que[p]] - k * x[que[p]] + (s[i] - L) * (s[i] - L); x[i] = s[i]; y[i] = f[i] + s[i] * s[i]; while(p &lt; head &amp;&amp; (y[que[head]] - y[que[head-1]]) * (x[i] - x[que[head]]) &gt;= (y[i] - y[que[head]]) * (x[que[head]] - x[que[head-1]])) head--;//维护最大值就把 &gt;= 改成 &lt;= que[++head] = i; } cout &lt;&lt; f[n] &lt;&lt; '\\n'; } 凸包上相邻两点的斜率具有单调性 可以将斜率优化与二分/分治/数据结构等结合，来维护性质不那么好（缺少一些单调性性质）的 DP 方程 CDQ分治，先解决[l, mid]，在解决[mid + 1, r]从[l,mid]的转移（此时[l,mid]是一个静态凸壳,不会有新的决策点加入，维护好凸包后可以将[mid+1,r]内按斜率排序解决转移），最后解决[mid+1,r] 数位DP //https://www.luogu.com.cn/problem/P2602 //每个数码各出现了多少次。 int num[20]; ll pow10[20], now[20]; ll f[20]; ll dfs(int pos, int dig, bool lead, bool limit) { if(pos == 0) return 0; if(!lead &amp;&amp; !limit &amp;&amp; f[pos] != -1) return f[pos]; ll ans = 0; int up = limit ? num[pos] : 9; for(int i = 0; i &lt;= up; i++) { if(lead &amp;&amp; i == 0) ans += dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); else if(i == dig &amp;&amp; limit &amp;&amp; i == up)//贡献是后面的数的数量 ans += now[pos - 1] + 1 + dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); else if(i == dig) ans += pow10[pos - 1] + dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); else ans += dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); } if(!lead &amp;&amp; !limit) f[pos] = ans; return ans; } ll run(ll x, int dig) { int len = 0; while(x) { num[++len] = x % 10; x /= 10; now[len] = now[len - 1] + pow10[len - 1] * num[len]; } return dfs(len, dig, true, true); } void solve() { ll l, r; cin &gt;&gt; l &gt;&gt; r; pow10[0] = 1; for(int i = 1; i &lt;= 15; i++) pow10[i] = pow10[i - 1] * 10; memset(f, -1, sizeof f); for(int i = 0; i &lt;= 9; i++) cout &lt;&lt; run(r, i) - run(l - 1, i) &lt;&lt; &quot; \\n&quot;[i == 9]; } //https://vjudge.net/problem/HDU-2089 //数字中不能有4或62 int num[20]; ll f[20][2]; ll dfs(int pos, int pre, bool sta, bool limit)//需要sta是因为这一位是否放 6 对后面计数有影响 { if (pos == 0) return 1; if (!limit &amp;&amp; f[pos][sta] != -1) return f[pos][sta]; ll ans = 0; int up = limit ? num[pos] : 9; for (int i = 0; i &lt;= up; i++) { if(i == 4 || pre == 6 &amp;&amp; i == 2) continue; ans += dfs(pos - 1, i, i == 6, limit &amp;&amp; i == up); } if (!limit) f[pos][sta] = ans; return ans; } ll run(ll x) { int len = 0; while (x) { num[++len] = x % 10; x /= 10; } return dfs(len, 0, 0, 1); } void solve() { memset(f, -1, sizeof f);//初始化有些题可以放多组输入外面。这一点是一个数位特点，使用的条件是：约束条件是每个数自身的属性，而与输入无关。例如有的题每次模数不同，则不能开在外面 ll l, r; while (cin &gt;&gt; l &gt;&gt; r, l || r) cout &lt;&lt; run(r) - run(l - 1) &lt;&lt; '\\n'; } WQS二分 /* 题意：有一颗带边权的树，从中选出确定的 K 条顶点不相交的边，使这 K 条边的权值和最大 用 WQS二分 将选出恰好 K 条边转化为选任意条边的问题后做树形DP即可 */ #define int ll pair&lt;ll, int&gt; operator + (const pair&lt;ll, int&gt; &amp;a, const pair&lt;ll,int&gt; &amp;b){ return {a.first + b.first, a.second + b.second}; } vector&lt;array&lt;int, 2&gt;&gt; g[N]; pair&lt;ll, int&gt; f[N][2]; void dfs(int x, int fa, int c) { f[x][0] = f[x][1] = {0, 0}; for(auto &amp;[to, w] : g[x]) { if(to == fa) continue; dfs(to, x, c); f[x][1] = max(f[x][1] + max(f[to][0], f[to][1]), f[x][0] + f[to][0] + make_pair(w - c, 1)); f[x][0] = f[x][0] + max(f[to][0], f[to][1]); } } void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt; n; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back({v, w}); g[v].push_back({u, w}); } int l = -1e13, r = 1e13;//答案值域 ll ans = -INF; while(l &lt;= r) { int c = (l + r) / 2; dfs(1, -1, c); auto [res, cnt] = max(f[1][0], f[1][1]);//因为下面是 cnt &gt;=k ，所以相同贡献下选cnt大的 if(cnt &gt;= k) { ans = res + 1ll * k * c;// 要加 k * c，而不是 cnt * c， 当 k 和 k + 1 处斜率相同时，DP出的数量答案是 k + 1 是的，但权值答案与 k 共享 l = c + 1; } else r = c - 1; } if(ans == -INF) cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; '\\n'; else cout &lt;&lt; ans &lt;&lt; '\\n'; } 树形DP以任意点与其他所有点的最大距离 void dfs1(int x, int fa)//f1[x] 记录x的子树中与x的最大距离，f2[x]记录非x子树中的点到x的最大距离 { f1[x] = f2[x] = 0; for(auto &amp;to : g[x]) { if(to == fa) continue; dfs1(to, x); f1[x] = max(f1[x], f1[to] + 1); } } int pre[N], suf[N]; void dfs2(int x, int fa) { vector&lt;int&gt; v(1);//下标从 1 开始，所以先放入一个元素 for(auto &amp;to : g[x]) if(to != fa) v.push_back(to); int n = v.size() - 1; pre[0] = suf[n + 1] = 0; for(int i = 1; i &lt;= n; i++) pre[i] = max(pre[i - 1], f1[v[i]]); for(int i = n; i &gt;= 1; i--) suf[i] = max(suf[i + 1], f1[v[i]]); for(int i = 1; i &lt;= n; i++) { if(n &gt;= 2) f2[v[i]] = max(pre[i - 1], suf[i + 1]) + 2; f2[v[i]] = max(f2[v[i]], f2[x] + 1); } for(auto &amp;to : g[x]) if(to != fa) dfs2(to, x); } SOSDP 解决求 $S$ 的贡献是所有子集贡献和的问题 //题意：给定一个数组 a，求有多少个 (i, j) 使得 a[i] | a[j] = a[i] void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; cnt(1e6 + 10); for(int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; cnt[x]++; } auto f = cnt; for(int i = 0; i &lt;= 20; i++) for(int j = 1; j &lt;= 1e6; j++) if(j &gt;&gt; i &amp; 1) f[j] += f[j ^ (1 &lt;&lt; i)];//在一个 i 下，一个数只会被转移一次 ll ans = 0; for(int i = 1; i &lt;= 1e6; i++) ans += 1ll * cnt[i] * f[i]; cout &lt;&lt; ans &lt;&lt; '\\n'; } 从自己的因子转移 for(int fac = 1; fac &lt;= n; fac++)//枚举因子 for(int i = fac; i &lt;= n; i += fac) f[i] += f[fac] + w;","categories":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}],"tags":[{"name":"板子","slug":"板子","permalink":"/tags/板子/"}],"keywords":[{"name":"模板","slug":"模板","permalink":"/categories/模板/"}]}]}