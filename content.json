{"meta":{"title":"learner'blog","subtitle":null,"description":"èŠ±æ— å‡‹é›¶ä¹‹æ—¥ï¼Œæ„æ— ä¼ é€’ä¹‹æ—¶ ã€‚çˆ±æƒ…äº˜å¤ä¸å˜ï¼Œç´«ç½—å…°ä¸ä¸–é•¿å­˜","author":"learner","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2024-03-27T13:00:23.062Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"learner && æ·¡ç‡ƒ ä¸&nbsp; learner &nbsp; ï¼ˆ ï¼‰ å¯¹è¯ä¸­... bot_ui_ini()","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2024-03-28T05:17:22.095Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"ç›´æ¥ä¸‹è½½ or æ‰«ç ä¸‹è½½ï¼š","keywords":"Androidå®¢æˆ·ç«¯"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"å¿µä¸¤å¥è¯— å™åˆ«æ¢¦ã€æ‰¬å·ä¸€è§‰ã€‚ ã€å®‹ä»£ã€‘å´æ–‡è‹±ã€Šå¤œæ¸¸å®«Â·äººå»è¥¿æ¥¼é›æ³ã€‹","keywords":"ç•™è¨€æ¿"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"è°¢è°¢é¥²ä¸»äº†å–µ~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakuraä¸»é¢˜ balabala","keywords":"Labå®éªŒå®¤"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"å‹äººå¸"},{"title":"music","date":"2024-03-08T05:20:00.000Z","updated":"2024-03-28T09:14:13.613Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"æˆ‘å–œæ¬¢çš„éŸ³ä¹"},{"title":"theme-sakura","date":"2023-03-23T07:08:00.000Z","updated":"2024-03-27T12:41:19.615Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexoä¸»é¢˜Sakuraä¿®æ”¹è‡ªWordPressä¸»é¢˜[Sakura](https://github.com/mashirozx/Sakura/)ï¼Œæ„Ÿè°¢åŸä½œè€…[Mashiro](https://2heng.xin/)","keywords":"Hexo ä¸»é¢˜ Sakura ğŸŒ¸"},{"title":"tags","date":"2024-04-02T13:02:55.000Z","updated":"2024-04-02T13:03:05.947Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2024-03-27T13:54:28.646Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: 'æ”¾é€æ—¶é—´: 2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: '2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} å›å¿† æ•…äº‹çš„å¼€å§‹ window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} æ”¾é€æ—¶é—´: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"Bç«™"}],"posts":[{"title":"cmake","slug":"19","date":"2024-06-10T07:58:55.435Z","updated":"2024-06-10T08:04:23.383Z","comments":true,"path":"2024/06/10/19/","link":"","permalink":"/2024/06/10/19/","excerpt":"","text":"cmakeä½¿ç”¨ 1.åˆ›å»º CMakeLists.txt æ–‡ä»¶å¹¶è¿›è¡Œç¼–è¾‘ 2.ä½¿ç”¨ cmake \\ . å‘½ä»¤ï¼Œ. æŒ‡çš„æ˜¯å½“å‰æ–‡ä»¶å¤¹ï¼Œç”Ÿæˆ Makefile æ–‡ä»¶ 3.ä½¿ç”¨ make å‘½ä»¤ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ CMakeLists.txt è¯­æ³• ç‰ˆæœ¬ cmake_minimum_required(VERSION 3.10)** æŒ‡å®šæœ€ä½ cmake ç‰ˆæœ¬ PROJECT å…³é”®å­— ç”¨æ¥æŒ‡å®šå·¥ç¨‹çš„åå­—å’Œæ”¯æŒçš„è¯­è¨€ PROJECT(HELLO)â€‹ å·¥ç¨‹åä¸º â€‹HELLOâ€‹ï¼Œé»˜è®¤æ”¯æŒæ‰€æœ‰è¯­è¨€ PROJECT(HELLO CXX)â€‹ å·¥ç¨‹åä¸º â€‹HELLOâ€‹ï¼Œæ”¯æŒè¯­è¨€ CXX PROJECT(HELLO CXX C JAVA)â€‹ å¤šç§è¯­è¨€ç”¨ç©ºæ ¼æˆ–åˆ†å·éš”å¼€ è¯¥æŒ‡å®šéšå¼å®šä¹‰äº†ä¸¤ä¸ª CMAKE å˜é‡ _BINARY_DIRï¼Œæ¯”å¦‚ HELLO _BINARY_DIRï¼Œä¹Ÿå¯ä»¥ç›´æ¥ç®€åŒ–ä½¿ç”¨ PROJECT _BINARY_DIR æ¥è¡¨ç¤ºï¼Œè¿™æ˜¯ç¼–è¯‘è·¯å¾„ _SOURCE_DIRï¼Œæ¯”å¦‚ HELLO _SOURCE_DIRï¼Œä¹Ÿå¯ä»¥ç›´æ¥ç®€åŒ–ä½¿ç”¨ PROJECT _SOURCE_DIR æ¥è¡¨ç¤ºï¼Œè¿™æ˜¯å·¥ç¨‹è·¯å¾„ åœ¨ MESSAGE å…³é”®å­—ä¸­å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™ä¸¤ä¸ªå˜é‡ï¼ŒæŒ‡å‘å½“å‰çš„å·¥ä½œç›®å½• SET å…³é”®å­— ç”¨æ¥æŒ‡å®šå˜é‡ï¼Œé»˜è®¤éƒ½æ˜¯å­—ç¬¦ä¸²ç±»å‹ SET(SRC_LIST main.cpp)â€‹ å…¶ä¸­â€‹ SRC_LIST â€‹å˜é‡åŒ…å« â€‹main.cppâ€‹ SET(SRC_LIST a.cpp b.cpp c.cpp)â€‹ SET(CMAKE_CXX_STANDARD 11) æŒ‡å®šc++ç‰ˆæœ¬ä¸º 11ï¼ŒCMAKE_CXX_STANDARDæ˜¯å®ä¸æ˜¯å˜é‡ MESSAGE å…³é”®å­— ç”¨æ¥åœ¨ç»ˆç«¯è¾“å‡ºä¿¡æ¯ ä¸»è¦åŒ…å«ä¸‰ç§ä¿¡æ¯ï¼š SEND_ERRORâ€‹ï¼Œäº§ç”Ÿé”™è¯¯ï¼Œç”Ÿæˆè¿‡ç¨‹è¢«è·³è¿‡ STAUSï¼Œè¾“å‡ºå‰ç¼€ä¸º â€“ çš„ä¿¡æ¯ FATAL_ERROR ï¼Œç«‹å³ç»ˆæ­¢æ‰€æœ‰ cmake è¿‡ç¨‹ ADD_EXECUTABLE å…³é”®å­— ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ ADD_EXECUTABLE(hello\\ \\{SRC_LIST}) ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶åä¸º hello ï¼Œæºæ–‡ä»¶è¯»å–å˜é‡ SRC_LIST ä¸­çš„å†…å®¹ ä¹Ÿå¯ä»¥ç›´æ¥å†™æˆ ADD_EXECUTABLE(hello\\ \\{SRC_LIST}) æ–‡ä»¶æœç´¢ file(GLOB/GLOB_RECURSE å˜é‡å æ–‡ä»¶è·¯å¾„å’Œç±»å‹) ç¬¬ä¸€ä¸ªå‚æ•°æŒ‡å®šå¦‚ä½•æœç´¢ï¼ŒGLOBè¡¨ç¤ºå½“å‰æ–‡ä»¶ä¸‹æœç´¢ï¼ŒGLOB_RECURSEè¡¨ç¤ºé€’å½’æœç´¢ ä¾‹ï¼šfile(GLOB MAIN_SRC /src/*.cpp) æŒ‡å®šå¤´æ–‡ä»¶è·¯å¾„ INCLUDE_DIRECTORIES(path) path ä¸ºå¤´æ–‡ä»¶è·¯å¾„ å®å®šä¹‰ add_definitions(-Då®åç§° â€¦) add_definitions(-Då®åç§°=100) ä½¿ç”¨ = æ¥è¿›è¡Œå®çš„åˆå§‹åŒ– å†…éƒ¨æ„å»ºå’Œå¤–éƒ¨æ„å»º å†…éƒ¨æ„å»ºï¼šç›´æ¥æ„å»ºï¼Œå› ä¸ºæ–‡ä»¶å¤šå¯¼è‡´ä¸æ•´æ´ å¤–éƒ¨æ„å»ºï¼šåœ¨ CMakeFile.txt æ‰€åœ¨ç›®å½•åˆ›å»ºä¸€ä¸ª build æ–‡ä»¶å¤¹ï¼Œåœ¨ build ç›®å½•ä¸‹ä½¿ç”¨ cmake \\ â€¦ å‘½ä»¤ï¼Œæ„å»ºåçš„æ–‡ä»¶éƒ½ä¼šæ”¾åœ¨ build æ–‡ä»¶å¤¹ä¸‹ï¼Œæ­¤æ—¶ç¼–è¯‘è·¯å¾„ä¸º ./build è€Œå·¥ç¨‹è·¯å¾„ä¸º build æ‰€åœ¨è·¯å¾„ è§„èŒƒ æ·»åŠ ä¸€ä¸ªå­ç›®å½• src ï¼Œç”¨æ¥æ”¾ç½®å·¥ç¨‹æºä»£ç  æ·»åŠ ä¸€ä¸ªå­ç›®å½• docï¼Œç”¨æ¥æ”¾ç½®å·¥ç¨‹æ–‡æ¡£ å·¥ç¨‹ç›®å½•ä¸‹æ·»åŠ  runhello.shï¼Œè¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶çš„è„šæœ¬ å·¥ç¨‹ç›®å½•ä¸‹æ·»åŠ æ–‡æœ¬æ–‡ä»¶ COPYRIGHTï¼ŒREADME å°†æ„å»ºåçš„ç›®æ ‡æ–‡ä»¶æ”¾å…¥æ„å»ºç›®å½•çš„ bin å­ç›®å½• å·¥ç¨‹ç›®å½• . â”œâ”€â”€ build â”œâ”€â”€ CMakeLists.txt â””â”€â”€ src â”œâ”€â”€ CMakeLists.txt â””â”€â”€ main.cpp å·¥ç¨‹ç›®å½•ä¸‹çš„ CMakeLists.txt PROJECT(HELLO) ADD_SUBDIRECTORY(src bin) src ä¸‹çš„ CMakeLists.txt ADD_EXECUTABLE(hello main.cpp) ADD_SUBDIRECTORY ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) è¿™ä¸ªæŒ‡ä»¤ç”¨äºæƒ³å½“å‰å·¥ç¨‹æ·»åŠ å­˜æ”¾æºæ–‡ä»¶çš„å­ç›®å½•ï¼Œå¹¶å¯ä»¥æŒ‡å®šäºŒè¿›åˆ¶æ–‡ä»¶å­˜æ”¾ä½ç½®ã€‚ADD_SUBDIRECTORY(src bin) ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶åœ¨ /build/binä¸‹ï¼ŒADD_SUBDIRECTORY(src)ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶åœ¨ /build/src ä¸‹ EXCLUDE_FROM_ALL å‡½æ•°ç¦æ­¢è¯¥å­ç›®å½•ä¸‹çš„ç›®æ ‡è¢«é»˜è®¤æ„å»ºï¼Œå’Œç›´æ¥ä¸å†™ADD_SUBDIRECTORYæ•ˆæœç›¸åŒ é™æ€åº“å’ŒåŠ¨æ€åº“çš„æ„å»º é™æ€åº“æ–‡ä»¶åç¼€ .aï¼Œwindowsä¸‹æ˜¯ .lib åŠ¨æ€åº“æ–‡ä»¶åç¼€ .soï¼Œwindowsä¸‹æ˜¯ .dll æŒ‡å®šå¤´æ–‡ä»¶è·¯å¾„ include_directories(path) ç”Ÿæˆåº“ ADD_LIBRARY(åº“åç§° STATIC æºæ–‡ä»¶) ADD_LIBRARY(åº“åç§° SHARE æºæ–‡ä»¶) æŒ‡å®šç”Ÿæˆè·¯å¾„ SET(LIBRARY_OUTPUT_PATH path) å…¨å±€é“¾æ¥åº“ link_libraries(åº“1 åº“2 â€¦) åç»­æ‰€æœ‰ç›®æ ‡éƒ½ä¼šé“¾æ¥è¿™äº›åº“ æŒ‡å®šåº“è·¯å¾„ link_directories(path1 path2 â€¦) ç³»ç»Ÿçš„åº“åªéœ€è¦åå­—å°±å¯ä»¥æ‰¾åˆ° è‡ªå®šä¹‰çš„åº“åˆ™è¿˜éœ€è¦æŒ‡å®šè·¯å¾„ æŒ‡å®šé“¾æ¥åº“ target_link_libraries(target æƒé™1 åº“1 æƒé™2 åº“2â€¦) target æŒ‡å®šè¦åŠ è½½åº“çš„æ–‡ä»¶åï¼Œå¯ä»¥ä¸ºæºæ–‡ä»¶ã€åŠ¨æ€åº“æ–‡ä»¶ã€å¯æ‰§è¡Œæ–‡ä»¶ã€‚ æƒé™ï¼šPRIVATEã€PUBLICã€INTERFACE é»˜è®¤æƒé™æ˜¯ PUBLIC target_link_libraries(B æƒé™ C) target_link_libraries(A B) è‹¥æƒé™ä¸º PUBLICï¼Œåˆ™ A ä¸­èƒ½è°ƒç”¨ C ä¸­çš„å‡½æ•° è‹¥æƒé™ä¸º PRIVETEï¼Œåˆ™ A ä¸­ä¸èƒ½è°ƒç”¨ C ä¸­çš„å‡½æ•° target_link_libraries(B æƒé™ C æƒé™ D) target_link_libraries(A B) è‹¥æƒé™ä¸º INTERFACEï¼Œåˆ™ A ä¸­ä¸èƒ½è°ƒç”¨ Cã€Dä¸­çš„å‡½æ•°ï¼ŒB ä¸­å¯ä»¥è°ƒç”¨ä½†ä¸çŸ¥é“å‡½æ•°æ¥è‡ªäº C è¿˜æ˜¯ Dã€‚ä¹Ÿå°±æ˜¯è¯´ Cã€Dä¸ä¼šè¢«é“¾æ¥åˆ° Bï¼Œåªä¼šå¯¼å‡ºç¬¦å·(ç¬¦å·å°±æ˜¯å‡½æ•°)ã€‚","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"/tags/cmake/"}],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"å­—ç¬¦ä¸²","slug":"11","date":"2024-06-04T07:54:55.449Z","updated":"2024-06-04T08:06:05.634Z","comments":true,"path":"2024/06/04/11/","link":"","permalink":"/2024/06/04/11/","excerpt":"","text":"KMP $\\pi[i]$ ä¸º $s[0â€¦i]$ çš„å‰ç¼€å‡½æ•°( æœ€é•¿çš„ç›¸ç­‰çš„çœŸå‰ç¼€(ä¸èƒ½æ˜¯ $s$ æœ¬èº«)ä¸çœŸåç¼€çš„é•¿åº¦ ) int pi[N]; void getPi(string s) // s ä¸‹æ ‡ä» 0 å¼€å§‹ { int n = s.size(); for (int i = 1; i &lt; n; i++) { int j = pi[i - 1]; while (j &gt; 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } } vector&lt;int&gt; kmp(string t, string s) // è¿”å› s åœ¨ t ä¸­çš„èµ·ç‚¹ä½ç½®ï¼Œpi æ•°ç»„è®°å¾—æ¥ s+t+1 çš„å¤§å° { string cur = s + '#' + t; int sz1 = t.size(), sz2 = s.size(); getPi(cur); vector&lt;int&gt; v; for (int i = sz2 + 1; i &lt;= sz1 + sz2; i++) if (pi[i] == sz2) v.push_back(i - 2 * sz2); return v; } å‰ç¼€å‡½æ•°åº”ç”¨ å­—ç¬¦ä¸²å‘¨æœŸ(å¾ªç¯èŠ‚) è‹¥ $s$ æœ‰é•¿åº¦ä¸º $r$ çš„å‰ç¼€å’Œé•¿åº¦ä¸º $r$ çš„åç¼€ç›¸ç­‰ï¼Œåˆ™ç§° $s$ æœ‰é•¿åº¦ä¸º $r(0 \\leq r &lt; |s|)$ çš„ $border$ $n - \\pi[n-1]ã€n-\\pi[\\pi[n-1]-1]â€¦$ æ˜¯ $s$ çš„å‘¨æœŸçš„ $border$ é•¿åº¦ $n - \\pi[n-1]$ æ˜¯ $s$ çš„æœ€å°å‘¨æœŸ ä¾‹å¦‚ $abaaa$ çš„æœ€å°å‘¨æœŸæ˜¯ $abaa $ ç»Ÿè®¡ $s$ çš„æ¯ä¸ªå‰ç¼€çš„å‡ºç°æ¬¡æ•° $s$ çš„å‰ç¼€åœ¨ $s$ ä¸­çš„å‡ºç°æ¬¡æ•° vector&lt;int&gt; ans(n + 1); for (int i = 0; i &lt; n; i++) ans[pi[i]]++; for (int i = n - 1; i &gt; 0; i--) ans[pi[i - 1]] += ans[i];//é•¿åº¦ä¸º i çš„å‰ç¼€å°†å¤„äºè‡ªå·±åç¼€çš„ç­”æ¡ˆè½¬ç§»ç»™å¤„äºè‡ªå·±çš„å‰ç¼€ for (int i = 0; i &lt;= n; i++) ans[i]++;//å‰ç¼€æœ¬èº«çš„ç­”æ¡ˆ $s$ çš„å‰ç¼€åœ¨ $t$ ä¸­çš„å‡ºç°æ¬¡æ•° ä¸ä¸Šè¿°é—®é¢˜ç›¸åŒï¼Œä½†ç°åœ¨åªéœ€å…³æ³¨ $i \\geq n+1$ çš„ $\\pi[i]$ ï¼Œä¹Ÿä¸éœ€è¦åŠ å‰ç¼€æœ¬èº«çš„ç­”æ¡ˆ ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æœ¬è´¨ä¸åŒçš„å­—ä¸²ä¸ªæ•° æ‰©å±•kmp $z[i]$ ä¸º $s[i,n-1]$ å’Œ $s$ çš„æœ€é•¿å…¬å…±å‰ç¼€ï¼Œ$z[0]=0$ #include&lt;bits/stdc++.h&gt;//æ±‚å­—ç¬¦ä¸² b çš„ z å‡½æ•°, å’Œ b ä¸ a çš„æ¯ä¸ªåç¼€çš„LCPé•¿åº¦ #define ll long long //(a + '#' + b) å¯æ±‚ a åœ¨ b ä¸­çš„å‡ºç°ä½ç½® using namespace std; vector&lt;int&gt; getZ(string s) { int n = s.size(); vector&lt;int&gt; z(n); for (int i = 1, l = 0, r = 0; i &lt; n; ++i) { if (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + 1) { z[i] = z[i - l]; } else { z[i] = max(0, r - i + 1); while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i]; } if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; } return z; } #define int ll signed main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string a, b; cin &gt;&gt; a &gt;&gt; b; auto t = getZ(b); t[0] = t.size(); int ans = 0; for(int i = 0; i &lt; t.size(); i++) ans = ans ^ ((i + 1) * (t[i] + 1)); cout &lt;&lt; ans &lt;&lt; '\\n'; t = getZ(b + &quot;#&quot; + a); ans = 0; for(int i = b.size() + 1; i &lt; t.size(); i++) ans = ans ^ ((i - b.size()) * (t[i] + 1)); cout &lt;&lt; ans &lt;&lt; '\\n'; } ACè‡ªåŠ¨æœº #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 10; struct node{ int alp[26], end, fail; string s; int cnt, id; }tree[150 * 70 + 10]; int tot; void insert(string s, int id)//æ³¨æ„å­—æ¯æ˜¯å¦æ˜¯å°å†™ï¼Œè®°å¾—build { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp]) tree[p].alp[temp] = ++tot; p = tree[p].alp[temp]; } tree[p].end++; tree[p].s = s; tree[p].id = id; } void build() { queue&lt;int&gt; que; for(int i = 0; i &lt; 26; i++) if(tree[0].alp[i]) que.push(tree[0].alp[i]); while(que.size()) { int u = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) { if(tree[u].alp[i]) { tree[tree[u].alp[i]].fail = tree[tree[u].fail].alp[i]; // failæ•°ç»„ï¼šåŒä¸€å­—ç¬¦å¯ä»¥åŒ¹é…çš„å…¶ä»–ä½ç½® que.push(tree[u].alp[i]); } else tree[u].alp[i] = tree[tree[u].fail].alp[i]; } } } void query(string t) { int u = 0; for (int i = 0; i &lt; t.size(); i++) { u = tree[u].alp[t[i] - 'a']; // è½¬ç§» for (int j = u; j; j = tree[j].fail) tree[j].cnt += tree[j].end; } } void solve() { int n; while(cin &gt;&gt; n, n) { for(int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; insert(s, i); } build(); string t; cin &gt;&gt; t; query(t); vector&lt;pair&lt;int, pair&lt;int, string&gt;&gt;&gt; v; for(int i = 0; i &lt;= tot; i++) if(tree[i].cnt) v.push_back({tree[i].cnt, {-tree[i].id, tree[i].s}}); sort(v.begin(), v.end(), greater&lt;pair&lt;int, pair&lt;int, string&gt;&gt;&gt;()); if(v.empty()) cout &lt;&lt; 0 &lt;&lt; '\\n'; else { cout &lt;&lt; v[0].first &lt;&lt; '\\n'; for(auto &amp;[cnt, it] : v) if(cnt == v[0].first) cout &lt;&lt; it.second &lt;&lt; '\\n'; } for(int i = 0; i &lt;= tot; i++) { for(int j = 0; j &lt; 26; j++) tree[i].alp[j] = 0; tree[i].cnt = tree[i].fail = tree[i].end = 0; } tot = 0; } } signed main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t = 1; // cin &gt;&gt; t; while (t--) solve(); return 0; } #include &lt;bits/stdc++.h&gt;// failæ ‘ä¼˜åŒ–ï¼Œæ±‚æ¯ä¸ªæ¨¡å¼ä¸²åœ¨æ–‡æœ¬ä¸²ä¸­å‡ºç°äº†å¤šå°‘æ¬¡ using namespace std; const int N = 2e5 + 10; int ans[N]; struct AC{//æ³¨æ„å­—æ¯æ˜¯å¦æ˜¯å°å†™ï¼Œè®°å¾—build struct node{ int alp[26], fail; int cnt; vector&lt;int&gt; id; }tree[N]; int tot; vector&lt;int&gt; g[N]; void insert(string s, int id) { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp]) tree[p].alp[temp] = ++tot; p = tree[p].alp[temp]; } tree[p].id.push_back(id); } void build() { queue&lt;int&gt; que; for(int i = 0; i &lt; 26; i++) if(tree[0].alp[i]) que.push(tree[0].alp[i]); while(que.size()) { int u = que.front(); que.pop(); for(int i = 0; i &lt; 26; i++) { if(tree[u].alp[i]) { tree[tree[u].alp[i]].fail = tree[tree[u].fail].alp[i]; // failæ•°ç»„ï¼šåŒä¸€å­—ç¬¦å¯ä»¥åŒ¹é…çš„å…¶ä»–ä½ç½® que.push(tree[u].alp[i]); } else tree[u].alp[i] = tree[tree[u].fail].alp[i];//ç›´æ¥åˆ°å¯åŒ¹é…å¤„ } } } void query(string t) { int u = 0; for (int i = 0; i &lt; t.size(); i++) { u = tree[u].alp[t[i] - 'a'];// u åœ¨åŸå­—å…¸æ ‘ä¸­å¯èƒ½ä¸å­˜åœ¨ï¼Œä½†å­—å…¸æ ‘ç»“æ„å·²ç»æ”¹å˜ï¼Œä¼šç›´æ¥æŒ‡å‘ä¸‹ä¸€ä¸ªåŒ¹é…ç‚¹ tree[u].cnt++; } } void dfs(int x)//æ±‚å­æ ‘å’Œ { for(auto &amp;to : g[x]) { dfs(to); tree[x].cnt += tree[to].cnt; } for(auto &amp;id : tree[x].id) ans[id] = tree[x].cnt; } void failTree() { for(int u = 1; u &lt;= tot; u++) g[tree[u].fail].push_back(u);//å¯¹ fail è¾¹å»ºå›¾(ä¸€å®šæ˜¯æ ‘) dfs(0); } }AC; void solve() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; AC.insert(s, i); } AC.build(); string t; cin &gt;&gt; t; AC.query(t); AC.failTree(); for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } signed main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t = 1; // cin &gt;&gt; t; while (t--) solve(); return 0; } äºŒç»´å“ˆå¸Œ const int N = 1e3 + 10; const int p1 = 23333; const int p2 = 233; const int mod = 998243453;//ä¸æ˜¯998244353 int n, m; string a[N];//åŸæ•°ç»„ ll h[N][N], pw1[N], pw2[N]; void init_Hash(int n, int m){//å°†ä¸‹æ ‡ä» (1,1) å¼€å§‹çš„çŸ©é˜µ a è¿›è¡Œå“ˆå¸Œ h[0][0] = 0; pw1[0] = pw2[0] = 1; for(int i = 1; i &lt;= m; i++){ h[0][i] = 0; pw1[i] = pw1[i - 1] * p1 % mod; } for(int i = 1; i &lt;= n; i++){ h[i][0] = 0; pw2[i] = pw2[i - 1] * p2 % mod; } for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) h[i][j] = (h[i][j - 1] * p1 % mod + a[i][j]) % mod; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) h[i][j] = (h[i - 1][j] * p2 % mod + h[i][j]) % mod; } ll get_hash(int x, int y, int xx, int yy)//è·å¾—å·¦ä¸Šè§’åæ ‡ä¸º(x,y),å³ä¸‹è§’åæ ‡ä¸º(xx,yy)çš„hashå€¼ { int len1 = yy - y + 1; int len2 = xx - x + 1; ll res = h[xx][yy]; res = (res - h[xx - len2][yy] * pw2[len2] % mod + mod) % mod; res = (res - h[xx][yy - len1] * pw1[len1] % mod + mod) % mod; res = (res + h[xx - len2][yy - len1] * pw2[len2] % mod * pw1[len1] % mod) % mod; return res; }","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"å¸¸è§ç»“è®º","slug":"16","date":"2024-06-04T07:54:52.408Z","updated":"2024-06-04T08:05:51.879Z","comments":true,"path":"2024/06/04/16/","link":"","permalink":"/2024/06/04/16/","excerpt":"","text":"a+b = a&amp;b + a|b a+b = a^b + 2(a&amp;b) min(x^y, y^z) &lt; x^zï¼Œ x &lt; y &lt; z //ä¸€ä¸ªæ•°ç»„ä¸­å–ä¸¤ä¸ªå…ƒç´ è®©ä»–ä»¬çš„å¼‚æˆ–å’Œæœ€å°ï¼Œä¸€å®šæ˜¯å–å¤§å°ç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´  $$ \\lfloor \\frac{ \\lfloor \\frac{x}{y} \\rfloor }{z} \\rfloor = \\lfloor \\frac{x}{yz} \\rfloor $$ $$ a è‡³å°‘æ•´é™¤ \\lceil \\frac{a+1}{x+1} \\rceil ä¼šå°äºç­‰äº x $$ $$ å¯¹äºä¸€ä¸ªä»»æ„çš„æ‹¬å·åºåˆ— \\ ä»¤ n ä¸º æ‹¬å·åºåˆ—é•¿åº¦ï¼Œm ä¸ºæ‹¬å·åºåˆ—å‰ç¼€æœ€å°å€¼(â€˜(â€™ æƒå€¼ä¸º 1ï¼Œ â€˜)â€™ æƒå€¼ä¸º -1)ï¼Œ sum ä¸ºæ‹¬å·åºåˆ—å’Œã€‚ \\ é‚£ä¹ˆæœ€é•¿åŒ¹é…å­åºåˆ—çš„æ‹¬å·åŒ¹é…æ•°ä¸º n - sum + 2m $$ $$ å…¸ä¸­å…¸ : ä¸€æ£µæ ‘çš„èŠ‚ç‚¹ size ç§ç±»åªæœ‰ \\sqrt{n} ä¸­ $$ $$ log(a)+log(b)=log(a*b) $$ $$ (a + bx) % n = tï¼Œå…¶ä¸­a,b,nä¸ºå¸¸æ•°,xä¸ºå˜é‡,tçš„æœ€å°éè´Ÿå€¼ä¸ºa%(gcd(b,n)) $$","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"åŸºç¡€çŸ¥è¯†","slug":"10","date":"2024-06-04T07:54:49.798Z","updated":"2024-06-04T08:06:08.481Z","comments":true,"path":"2024/06/04/10/","link":"","permalink":"/2024/06/04/10/","excerpt":"","text":"å¤´æ–‡ä»¶ #include &lt;algorithm&gt; //STLé€šç”¨ç®—æ³• #include &lt;bitset&gt;//STLä½é›†å®¹å™¨ #include &lt;cctype&gt; #include &lt;cerrno&gt; #include &lt;clocale&gt; #include &lt;cmath&gt; #include &lt;complex&gt; //å¤æ•°ç±» #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;deque&gt; //STLåŒç«¯é˜Ÿåˆ—å®¹å™¨ #include &lt;exception&gt; //å¼‚å¸¸å¤„ç†ç±» #include &lt;fstream&gt; #include &lt;functional&gt;//STLå®šä¹‰è¿ç®—å‡½æ•°ï¼ˆä»£æ›¿è¿ç®—ç¬¦ï¼‰ #include &lt;limits&gt; #include &lt;list&gt;//STLçº¿æ€§åˆ—è¡¨å®¹å™¨ #include &lt;map&gt; //STL æ˜ å°„å®¹å™¨ #include &lt;iomanip&gt; #include &lt;ios&gt;//åŸºæœ¬è¾“å…¥ï¼è¾“å‡ºæ”¯æŒ #include&lt;iosfwd&gt;//è¾“å…¥ï¼è¾“å‡ºç³»ç»Ÿä½¿ç”¨çš„å‰ç½®å£°æ˜ #include &lt;iostream&gt; #include &lt;istream&gt; //åŸºæœ¬è¾“å…¥æµ #include &lt;ostream&gt; //åŸºæœ¬è¾“å‡ºæµ #include &lt;queue&gt; //STLé˜Ÿåˆ—å®¹å™¨ #include &lt;set&gt; //STL é›†åˆå®¹å™¨ #include &lt;sstream&gt;//åŸºäºå­—ç¬¦ä¸²çš„æµ #include &lt;stack&gt; //STLå †æ ˆå®¹å™¨ #include &lt;stdexcept&gt; //æ ‡å‡†å¼‚å¸¸ç±» #include &lt;streambuf&gt;//åº•å±‚è¾“å…¥ï¼è¾“å‡ºæ”¯æŒ #include &lt;string&gt;//å­—ç¬¦ä¸²ç±» #include &lt;utility&gt; //STLé€šç”¨æ¨¡æ¿ç±» #include &lt;vector&gt;//STLåŠ¨æ€æ•°ç»„å®¹å™¨ #include &lt;cwchar&gt; #include &lt;cwctype&gt; å¿«è¯» ll read() { char ch; ll a = 0; while((ch = getchar()) == ' ' || ch == '\\n'); a+=ch-'0'; while((ch= getchar()) != ' ' &amp;&amp; ch != '\\n') { a *= 10; a += ch - '0'; } return a; } å¿«é€Ÿä¹˜ ll qmul(ll a, ll b, ll mod) //å¿«é€Ÿä¹˜ï¼Œ é˜²æ­¢çˆ†ll { ll ans = 0; while (b &gt; 0) { if (b &amp; 1) ans = (ans + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; } return ans; } éšæœºæ•° std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());//32ä½ std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());//64ä½,è¦ç”¨unsigned long long, 2^64-1 ç»„åˆæ•° ll fac[N], invfac[N]; ll qpow(ll base, ll pow) { ll ans = 1; while (pow) { if (pow &amp; 1) ans = ans * base % mod; pow &gt;&gt;= 1; base = base * base % mod; } return ans; } inline ll inv(ll x){ return qpow(x, mod - 2); } void init()//ä¸èƒ½å¿˜è®°initå’Œè°ƒNçš„å¤§å° { fac[0] = invfac[0] = 1; for(int i = 1; i &lt; N; i ++ ) fac[i] = fac[i - 1] * i % mod; invfac[N - 1] = qpow(fac[N - 1], mod - 2); for(int i = N - 2; i &gt;= 0; i -- ) invfac[i] = invfac[i + 1] * (1 + i) % mod; } ll C(int n, int m) { if (n &lt; 0 || m &lt; 0 || m &gt; n) return 0; return fac[n] * invfac[m] % mod * invfac[n - m] % mod; } åæ ‡ç³»æ—‹è½¬åç‚¹çš„åæ ‡å˜æ¢ ä¸ªæ•°æ•°é‡çº§ $n$ ä»¥å†…çš„ç´ æ•°ä¸ªæ•° : $\\frac{n}{In \\ n}$ ä»¤ $d(n)$ è¡¨ç¤º $n$ çš„å› æ•°ä¸ªæ•° å¯¹äºä»»æ„æ­£æ•´æ•° $n$ï¼Œ æœ‰ $d(n) \\leq \\sqrt{3n}$ å¯¹äº $n &gt; 1260$ ï¼Œæœ‰ $d(n) &lt; \\sqrt{n}$ å¯¹äº $10^{18}$ èŒƒå›´å†…çš„æ•°ï¼Œå› æ•°ä¸ªæ•°æœ€å¤šçº¦ä¸º $10^5$","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"æ•°å­¦","slug":"13","date":"2024-06-04T07:54:47.572Z","updated":"2024-06-04T08:05:59.921Z","comments":true,"path":"2024/06/04/13/","link":"","permalink":"/2024/06/04/13/","excerpt":"","text":"æ•°å­¦å…¬å¼ 1 + 1+2 + 1+2+3 + 1+2+3+4 + Â·Â·Â·Â·Â·Â· + 1+2+3+Â·Â·Â·+n = $\\frac{n*(n+1)*(n+2)}{6}$ $1^2$ + $2^2$ + $3^2$ + Â·Â·Â·Â·Â·Â· + $n^2$ = $\\frac{n*(n+1)*(2n+1)}{6}$ $1 + \\frac{1}{2} + \\frac{1}{3} + Â·Â·Â· + \\frac{1}{n - 1} = In(n) + 0.5772156649$(çº¦ç­‰äºï¼Œ nè¶Šå¤§è¯¯å·®è¶Šå°) æ¬§æ‹‰ç­› int isprime[N]; vector&lt;int&gt; prime; void sieve() { for (int i = 2; i &lt; N; i++) isprime[i] = 1; for (int i = 2; i &lt; N; i++) { if (isprime[i]) prime.push_back(i); for (int &amp;it : prime) { if (1ll * i * it &gt;= N) break; isprime[i * it] = 0; if (i % it == 0) break; } } } æ¬§æ‹‰å‡½æ•° æ€§è´¨ ï¼š nçš„æ‰€æœ‰å› æ•°çš„æ¬§æ‹‰å‡½æ•°ä¹‹å’Œç­‰äºnæœ¬èº« ll phi(ll x)//å®¹æ–¥åŸç† O(sqrt(n)) { if(x == 1) return 1; ll ans = x; for (ll i = 2; i * i &lt;= x; i++) { if (x % i == 0) { ans = ans / i * (i - 1); while (x % i == 0) x /= i; } } if (x &gt; 1) ans = ans / x * (x - 1); return ans; } ll phi[N], prime[N]; ll tot;//totè®¡æ•°ï¼Œè¡¨ç¤ºprime[N]ä¸­æœ‰å¤šå°‘è´¨æ•° void Euler() { phi[1] = 1; for (ll i = 2; i &lt; N; i++) { if (!phi[i]) { phi[i] = i - 1; prime[tot++] = i; } for (ll j = 0; j &lt; tot &amp;&amp; 1ll * i * prime[j] &lt; N; j++) { if (i % prime[j]) phi[i * prime[j]] = phi[i] * (prime[j] - 1); else { phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } çŸ©é˜µå¿«é€Ÿå¹‚ const int K = 2; struct Matrix { ll a[K][K]; Matrix() {} void clear() { memset(a, 0, sizeof a); }//å˜æˆ0çŸ©é˜µ void init()//åˆå§‹åŒ–ä¸ºå•ä½é˜µ { clear(); for (int i = 0; i &lt; K; i++) a[i][i] = 1; } Matrix operator * (const Matrix&amp; x) const { Matrix res; res.clear(); for (int i = 0; i &lt; K; i++) for (int j = 0; j &lt; K; j++) for (int k = 0; k &lt; K; k++) (res.a[i][j] += a[i][k] * x.a[k][j] % mod) %= mod; return res; } Matrix operator + (const Matrix&amp; x) const { Matrix res; res.clear(); for (int i = 0; i &lt; K; i++) for (int j = 0; j &lt; K; j++) res.a[i][j] = (a[i][j] + x.a[i][j]) % mod; return res; } }; Matrix qpow(Matrix base, int pow) { Matrix ans; ans.init(); while (pow) { if (pow &amp; 1) ans = ans * base; pow /= 2; base = base * base; } return ans; } void solve() { Matrix x; int p[2][2] = { 1, 1, 1, 0 }; memcpy(x.a, p, sizeof p); while (cin &gt;&gt; n, n != -1) { Matrix ans = qpow(x, n); cout &lt;&lt; ans.a[0][1] &lt;&lt; '\\n'; } } é«˜æ–¯æ¶ˆå…ƒ æ•´æ•°ç±»å‹è§£ int a[maxn][maxn]; int ans[maxn]; int GCD ( int a, int b ) { if ( ! b ) return a; return GCD ( b, a % b ); } int LCM ( int a, int b ) { return a / GCD ( a, b ) * b; } int Fabs ( int x ) { if ( x &lt; 0 ) return -x; return x; } int Gauss ( int equ, int var ) { // æ–¹ç¨‹æ•°ã€å¢å¹¿çŸ©é˜µå®½åº¦ï¼Œ ä¼ è¿›æ¥çš„æ˜¯ä¸‹æ ‡ä»1ï¼Œ1å¼€å§‹çš„å¢å¹¿çŸ©é˜µ for ( int i = 0;i &lt;= var;i ++ ) { ans[i] = 0; Free[i] = 1; } int row, col, MaxRow; col = 1; for ( row = 1;row &lt;= equ &amp;&amp; col &lt; var;row ++, col ++ ) { MaxRow = row; for ( int i = row + 1;i &lt;= equ;i ++ ) if ( Fabs ( a[i][col] ) &gt; Fabs ( a[MaxRow][col] ) ) MaxRow = i; if ( MaxRow != row ) { for ( int i = row;i &lt;= var;i ++ ) swap ( a[row][i], a[MaxRow][i] ); } if ( ! a[row][col] ) { row --; continue; } for ( int i = row + 1;i &lt;= equ;i ++ ) { if ( a[i][col] ) { int lcm = LCM ( Fabs ( a[i][col] ), Fabs ( a[row][col] ) ); int T1 = lcm / Fabs ( a[i][col] ); int T2 = lcm / Fabs ( a[row][col] ); if ( a[i][col] * a[row][col] &lt; 0 ) T2 = -T2; for ( int j = col;j &lt;= var;j ++ ) a[i][j] = a[i][j] * T1 - a[row][j] * T2; } } } for ( int i = row;i &lt;= equ;i ++ ) if ( a[i][col] ) return -1; int temp; if ( row &lt; var ) { return var - row; } for ( int i = var - 1;i &gt; 0;i -- ) { temp = a[i][var]; for ( int j = i + 1;j &lt; var;j ++ ) if ( a[i][j] ) temp -= a[i][j] * ans[j]; ans[i] = temp / a[i][i]; } return 0; } æµ®ç‚¹æ•° double a[222][222];//ä¸‹æ ‡ä» 0ï¼Œ0 å¼€å§‹ double ans[222],Free[222];//Freeå­˜æ”¾è‡ªç”±å…ƒ int Gauss ( int equ, int var ) {//æ–¹ç¨‹æ•°é‡ï¼Œå¢å¹¿çŸ©é˜µå®½åº¦-1(æœªçŸ¥æ•°ä¸ªæ•°) for ( int i = 0;i &lt;= var;i ++ ) { ans[i] = 0; Free[i] = 1; } int row, col, MaxRow; col = 0; for ( row = 0;row &lt; equ &amp;&amp; col &lt; var;row ++, col ++ ) { MaxRow = row; for ( int i = row + 1;i &lt; equ;i ++ ) if ( fabs ( a[i][col] ) &gt; fabs ( a[MaxRow][col] ) ) MaxRow = i; if ( MaxRow != row ) { for ( int i = row;i &lt;= var;i ++ ) swap ( a[row][i], a[MaxRow][i] ); } if ( fabs ( a[row][col] ) &lt; eps ) {//å¦‚æœç­‰äº0 row --; continue; } for ( int i = row + 1;i &lt; equ;i ++ ) { if ( fabs ( a[i][col] ) &gt; eps ) { double temp = a[i][col] / a[row][col]; for ( int j = col;j &lt;= var;j ++ ) a[i][j] -= a[row][j] * temp; a[i][col] = 0; } } } for ( int i = row;i &lt; equ;i ++ ) if ( fabs ( a[i][col] ) &gt; eps ) return -1; double temp; if ( row &lt; var ) { for ( int i = row - 1;i &gt;= 0;i -- ) { int free_num = 0, idx; for ( int j = 0;j &lt; var;j ++ ) if ( a[i][j] &amp;&amp; Free[j] ) { free_num ++; idx = j; } if ( free_num &gt; 1 ) continue; temp = a[i][var]; for ( int j = 0;j &lt; var;j ++ ) { if ( a[i][j] &amp;&amp; j != idx ) temp -= a[i][j] * ans[j]; } ans[idx] = temp / a[i][idx];//è§£å‡ºéè‡ªç”±å…ƒ Free[idx] = 0; } return var - row;//è‡ªç”±å…ƒçš„æ•°é‡ï¼ŒFree[i] ä¸º 1 åˆ™ä¸ºè‡ªç”±å…ƒ } for ( int i = var - 1;i &gt;= 0;i -- ) { temp = a[i][var]; for ( int j = i + 1;j &lt; var;j ++ ) if ( a[i][j] ) temp -= a[i][j] * ans[j]; ans[i] = temp / a[i][i]; } return 0; } æ¨¡çº¿æ€§æ–¹ç¨‹ç»„ï¼ˆå–æ¨¡ï¼‰ int a[N][N], ans[N]; int Gauss(int equ, int var) // ä¸‹æ ‡ä» 0,0 å¼€å§‹ï¼Œequ æ–¹ç¨‹ä¸ªæ•°ï¼ŒvaræœªçŸ¥æ•°ä¸ªæ•° { for(int i = 0; i &lt;= var; i++) ans[i] = 0; int row, col = 0; for (row = 0; row &lt; equ &amp;&amp; col &lt; var; row++, col++) { int MaxRow = row; for (int i = row + 1; i &lt; equ; i++) { if (Abs(a[i][col]) &gt; Abs(a[MaxRow][col])) MaxRow = i; } if (row != MaxRow) { for (int i = row; i &lt;= var; i++) swap(a[row][i], a[MaxRow][i]); } if (!a[row][col]) { row--; continue; } for (int i = row + 1; i &lt; equ; i++) { if (a[i][col]) { int T = a[i][col] * qpow(a[row][col], mod - 2) % mod; for (int j = col; j &lt;= var; j++) a[i][j] = (a[i][j] - a[row][j] * T % mod + mod) % mod; } } } for (int i = row; i &lt; equ; i++)//æ— è§£ { if (a[i][col]) return -1; } if (row &lt; var) return var - row;//å¤šè§£ for (int i = var - 1; i &gt;= 0; i--)//xä¸ºç­”æ¡ˆ { int temp = a[i][var]; for (int j = i + 1; j &lt; var; j++) { if (a[i][j]) { temp -= a[i][j] * ans[j]; temp = (temp % mod + mod) % mod; } } ans[i] = temp * qpow(a[i][i], mod - 2) % mod; } return 0; } å¼‚æˆ– bitset&lt;222&gt; a[222]; int ans[222], Free[222], cnt; int Gauss(int equ,int var){//ä¸‹æ ‡ä» 0,0 å¼€å§‹ï¼Œæ–¹ç¨‹æ•°é‡ï¼Œå¢å¹¿çŸ©é˜µå®½åº¦-1(æœªçŸ¥æ•°ä¸ªæ•°) int row, col, MaxRow; col = 0; for(row = 0; row &lt; equ &amp;&amp; col &lt; var; row++, col++) { MaxRow = row; for(int i = row + 1; i &lt; equ; i++) if(abs(a[i][col]) &gt; abs(a[MaxRow][col])) MaxRow=i; if(MaxRow != row) swap(a[row], a[MaxRow]); if(a[row][col] == 0) { row--; Free[++cnt]=col; continue; } for(int i = row + 1; i &lt; equ; i++) if(a[i][col]) a[i] ^= a[row]; } for(int i = row; i &lt; equ; i++) if(a[i][col]) return -1; if(row&lt;var) return var-row; for(int i = var - 1; i &gt;= 0; i--) { ans[i] = a[i][var]; for(int j = i + 1; j &lt; var; j++) if(a[i][j]) ans[i] ^= (a[i][j] &amp;&amp; ans[j]); } return 0; } è¡Œåˆ—å¼æ±‚å€¼ int a[N][N]; int calDet(int n, int mod)// a æ•°ç»„ä¸‹æ ‡ä» 1,1 å¼€å§‹ï¼Œæ–¹é˜µ { int i, j, k, r = 1, fh = 0, l; for(i = 1; i &lt;= n; i++) { k = i; for(j = i; j &lt;= n; j++) if(a[j][i]) {k = j; break;} if(a[k][i] == 0) return 0; for(++j; j &lt;= n; j++) if(a[j][i] &amp;&amp; a[j][i] &lt; a[k][i]) k = j; if(i != k) {swap(a[k], a[i]); fh ^= 1;} for(j = i + 1; j &lt;= n; j++) { if(a[j][i] &gt; a[i][i]) {swap(a[j], a[i]); fh ^= 1;} while(a[j][i]) { l = a[i][i] / a[j][i]; for(k = i; k &lt;= n; k++) a[i][k] = (a[i][k] + (ll)(mod - l) * a[j][k]) % mod; swap(a[j], a[i]); fh ^= 1; } } r = (ll)r * a[i][i] % mod; } if(fh) return (mod - r) % mod; return r; } çŸ©é˜µæ±‚é€† å–æ¨¡ #include&lt;bits/stdc++.h&gt; using namespace std; const int N=505; const int mod=1e9+7; int a[N][N&lt;&lt;1];//å¼€å®½åº¦å¼€ä¸¤å€, å¼€å§‹è¦å°†[1, n]åˆå§‹åŒ–ä¸ºæ±‚é€†çŸ©é˜µï¼Œ[n + 1, 2 * n] åˆå§‹åŒ–ä¸ºå•ä½é˜µ, æœ€å[n + 1, 2 * n]æ˜¯é€†çŸ©é˜µ int n; int ppow(int a,int b,int mod){ int ans=1%mod;a%=mod; while(b){ if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod; b&gt;&gt;=1; } return ans; } int Gauss_rev(int n){ for(int i=1;i&lt;=n;i++){ for(int j=i;j&lt;=n;j++){//æ‰¾ç¬¬iåˆ—éé›¶çš„è¡Œæ¢ä¸Šæ¥ if(a[j][i]){ swap(a[i],a[j]); break; } } if(!a[i][i])return 0;//æ— è§£ int kk=ppow(a[i][i],mod-2,mod);//é€†å…ƒ for(int j=i;j&lt;=n*2;j++){//å½“å‰è¡Œæ¯ä¸€åˆ—éƒ½é™¤ä»¥a[i][i] a[i][j]=1ll*a[i][j]*kk%mod; } for(int j=1;j&lt;=n;j++){//å…¶ä»–è¡Œ if(j!=i){ kk=a[j][i]; for(int k=i;k&lt;=n*2;k++){ a[j][k]=(a[j][k]-1ll*kk*a[i][k]%mod+mod)%mod; } } } } return 1; } signed main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ scanf(&quot;%d&quot;,&amp;a[i][j]); } a[i][i+n]=1; } if(!Gauss_rev(n)){ puts(&quot;No Solution&quot;); }else{ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ printf(&quot;%d &quot;,a[i][j+n]); } puts(&quot;&quot;); } } return 0; } å¼‚æˆ– bitset&lt;N * 2&gt; a[N];//å¼€å®½åº¦å¼€ä¸¤å€, å¼€å§‹è¦å°†[1, n]åˆå§‹åŒ–ä¸ºæ±‚é€†çŸ©é˜µï¼Œ[n + 1, 2 * n] åˆå§‹åŒ–ä¸ºå•ä½é˜µ, æœ€å[n + 1, 2 * n]æ˜¯é€†çŸ©é˜µ int Gauss_inv(int n) { for (int c = 1; c &lt;= n; c++) { int t = c; for (int i = c; i &lt;= n; i++) { if (a[i][c]) { t = i; break; } } if (a[t][c] == 0) return 0;//ä¸å­˜åœ¨é€†çŸ©é˜µ swap(a[t], a[c]); for (int i = 1; i &lt;= n; i++) if (a[i][c] &amp;&amp; i != c) a[i] ^= a[c]; } return 1; } çº¿æ€§åŸº void add(ll x) { for(int i=60;i&gt;=0;i--) { if(x&amp;(1ll&lt;&lt;i))//æ³¨æ„ï¼Œå¦‚æœiå¤§äº31ï¼Œå‰é¢çš„1çš„åé¢ä¸€å®šè¦åŠ ll { if(d[i]) x^=d[i]; else { d[i]=x; break;//æ’å…¥æˆåŠŸå°±é€€å‡º //æ²¡æœ‰breakå°±è¯´æ˜æ’å…¥ä¸æˆåŠŸï¼Œæ„å‘³ç€ x å¯ä»¥æœ‰å½“å‰çš„çº¿æ€§åŸºå¼‚æˆ–å¾—åˆ° } } } }//æœ€ådæ•°ç»„å°±æ˜¯çº¿æ€§åŸº å¦‚ä½•æ±‚æœ€å¤§å€¼ å®Œæ•´çš„è¯´ï¼Œæ˜¯å¦‚ä½•æ±‚åœ¨ä¸€ä¸ªåºåˆ—ä¸­ï¼Œå–è‹¥å¹²ä¸ªæ•°ï¼Œä½¿å¾—å®ƒä»¬çš„å¼‚æˆ–å’Œæœ€å¤§ã€‚ é¦–å…ˆæ„é€ å‡ºè¿™ä¸ªåºåˆ—çš„çº¿æ€§åŸºï¼Œç„¶åä»çº¿æ€§åŸºçš„æœ€é«˜ä½å¼€å§‹ï¼Œå‡å¦‚å½“å‰çš„ç­”æ¡ˆå¼‚æˆ–çº¿æ€§åŸºçš„è¿™ä¸ªå…ƒç´ å¯ä»¥å˜å¾—æ›´å¤§ï¼Œé‚£ä¹ˆå°±å¼‚æˆ–å®ƒï¼Œç­”æ¡ˆçš„åˆå€¼ä¸º 0 ll ans() { ll anss = 0; for(int i = 60; i &gt;= 0; i--)//è®°å¾—ä»çº¿æ€§åŸºçš„æœ€é«˜ä½å¼€å§‹ if((anss ^ d[i]) &gt; anss) anss ^= d[i]; return anss; } å¦‚ä½•æ±‚æœ€å°å€¼ æ³¨æ„ï¼Œè¿™é‡ŒæŒ‡çš„æ˜¯ç”¨çº¿æ€§åŸºå†…çš„å…ƒç´ èƒ½å¼‚æˆ–å‡ºçš„æœ€å°å€¼ã€‚ æ˜¾ç„¶å°±æ˜¯æœ€å°çš„ d [ i ]äº†ï¼Œå› ä¸ºæœ€å°çš„ d [ i ]æ— è®ºå¼‚æˆ–è°éƒ½ä¼šå˜å¤§ã€‚ å¦‚æœæ˜¯æ±‚æ•´ä¸ªåºåˆ—èƒ½å¼‚æˆ–å‡ºçš„æœ€å°å€¼è€Œä¸æ˜¯è¿™ä¸ªåºåˆ—çš„çº¿æ€§åŸºèƒ½å¼‚æˆ–å‡ºçš„æœ€å°å€¼çš„è¯ï¼Œè¦å¦å¤–çœ‹ä¸€çœ‹æœ‰æ²¡æœ‰å…ƒç´ ä¸èƒ½æ’å…¥çº¿æ€§åŸºï¼Œå¦‚æœæœ‰ï¼Œé‚£ä¹ˆæœ€å°å€¼å°±æ˜¯ 0ï¼Œå¦åˆ™ä¾ç„¶æ˜¯æœ€å°çš„ d [ i ]ã€‚ ä»ä¸€ä¸ªåºåˆ—ä¸­å–ä»»æ„ä¸ªå…ƒç´ è¿›è¡Œå¼‚æˆ–ï¼Œæ±‚èƒ½å¼‚æˆ–å‡ºçš„æ‰€æœ‰æ•°å­—ä¸­ç¬¬ $k$ å°çš„é‚£ä¸ªã€‚ void work()//å¤„ç†çº¿æ€§åŸº { for(int i=1;i&lt;=60;i++) for(int j=1;j&lt;=i;j++) if(d[i]&amp;(1ll&lt;&lt;(j-1)))d[i]^=d[j-1]; } ll k_th(ll k) { if(k==1&amp;&amp;tot&lt;n)return 0;//ç‰¹åˆ¤ä¸€ä¸‹ï¼Œå‡å¦‚k=1ï¼Œå¹¶ä¸”åŸæ¥çš„åºåˆ—å¯ä»¥å¼‚æˆ–å‡º0ï¼Œå°±è¦è¿”å›0ï¼Œtotè¡¨ç¤ºçº¿æ€§åŸºä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œnè¡¨ç¤ºåºåˆ—é•¿åº¦ if(tot&lt;n)k--;//ç±»ä¼¼ä¸Šé¢ï¼Œå»æ‰0çš„æƒ…å†µï¼Œå› ä¸ºçº¿æ€§åŸºä¸­åªèƒ½å¼‚æˆ–å‡ºä¸ä¸º0çš„è§£ work(); ll ans=0; for(int i=0;i&lt;=60;i++) if(d[i]!=0) { if(k%2==1)ans^=d[i]; k/=2; } return ans; } åº·æ‰˜å±•å¼€ æ›¼å“ˆé¡¿è·ç¦» $dis(a, b) = |i_a - i_b| + |j_a - j_b|$ â€‹ $ = max(i_a - i_b, i_b - i_a) + max(j_a - j_b, j_b - j_a)$//åšç¬›å¡å°”ç§¯ â€‹ $ = max(|(i_a + j_a) - (i_b + j_b)|, |(i_a - j_a) - (i_b - j_b)|)$ ä»¤ $z_a = i_a + j_a, w_a = i_a - j_a, z_b = i_b + j_b, w_b = i_b - j_b$; $dis(a, b) = |z_a - z_b| + |w_a - w_b|$ å¹³é¢ä¸Šè‹¥æ±‚ä¸€ä¸ªç‚¹$(x, y)$åˆ°ä¸€ä¸ªç‚¹é›†çš„æœ€å¤§æ›¼å“ˆé¡¿è·ç¦» åˆ™åªéœ€è¦ç»´æŠ¤ $z$çš„æœ€å¤§å€¼æœ€å°å€¼ï¼Œ$w$çš„æœ€å¤§å€¼æœ€å°å€¼ æœ€ç»ˆç­”æ¡ˆä¸º $max(z_{max} - z_x, z_x - z_{min}, w_{max} - w_x, w_x - w_{min})$ ä¾‹é¢˜ ï¼š æ±‚ä¸€ä¸ªä½ç½®ï¼Œä½¿å¾—å…¶åˆ°æ‰€æœ‰é»‘ç‚¹æœ€å¤§æ›¼å“ˆé¡¿è·ç¦»æœ€å°ï¼Œæˆ‘ä»¬æšä¸¾ä½ç½®ï¼Œä¹‹åæœ€å¤§è·ç¦»å–minå³å¯ã€‚ //https://codeforces.com/contest/1689/problem/D #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-4; const ll mod = 1e9 + 7; const ll N = 1e3 + 5; ll n, m; char g[1005][1005]; void solve() { cin &gt;&gt; n &gt;&gt; m; cin.ignore(); for (ll i = 1; i &lt;= n; i++) for (ll j = 1; j &lt;= m; j++) cin &gt;&gt; g[i][j]; ll zmi = inf, zmx = -inf, wmi = inf, wmx = -inf; for (ll i = 1; i &lt;= n; i++) { for (ll j = 1; j &lt;= m; j++) { if(g[i][j] == 'B') { zmi = min(zmi, i + j); zmx = max(zmx, i + j); wmi = min(wmi, i - j); wmx = max(wmx, i - j); } } } ll dis = inf; pair&lt;ll, ll&gt; ans; for (ll i = 1; i &lt;= n; i++) { for (ll j = 1; j &lt;= m; j++) { ll zx = i + j; ll wx = i - j; ll diss = max({ zmx - zx, zx - zmi, wmx - wx, wx - wmi }); if (diss &lt; dis) { dis = diss; ans = { i, j }; } } } cout &lt;&lt; ans.first &lt;&lt; ' ' &lt;&lt; ans.second &lt;&lt; '\\n'; } signed main() { IOS; ll t = 1; cin &gt;&gt; t; while (t--) solve(); return 0; } æ›¼å“ˆé¡¿è·ç¦»å’Œåˆ‡æ¯”é›ªå¤«è·ç¦»çš„è½¬åŒ– æ›¼å“ˆé¡¿è·ç¦»è½¬åˆ‡æ¯”é›ªå¤«è·ç¦» $(x,y)-&gt;(x+y, x-y)$ åˆ‡æ¯”é›ªå¤«è·ç¦»è½¬æ›¼å“ˆé¡¿è·ç¦» $(x, y) -&gt; (\\frac{x+y}{2}, \\frac{x-y}{2})$ è´¨å› æ•°åˆ†è§£æ±‚ç»™å®šæ­£æ•´æ•°çš„å› æ•°ä¸ªæ•° æ­£æ•´æ•°å› æ•°ä¸ªæ•°çš„å¿«é€Ÿæ±‚æ³• ä»¥72ä¸ºä¾‹ï¼Œå°†72è¿›è¡Œè´¨å› æ•°åˆ†è§£ï¼Œ72 = $22233$ = $2^3 * 3^2$ å°†åº•æ•°2çš„å¹‚æ¬¡å’Œåº•æ•°3çš„å¹‚æ¬¡åˆ†åˆ«åŠ 1å†ç›¸ä¹˜ å¾—åˆ°72çš„å› æ•°ä¸ªæ•° = (3+1) * (2+1) = 12 å¯¹ç‰¹æ®Šçš„æ•°å¦‚ 1ï¼Œè´¨æ•°å‡æˆç«‹ min_25ç­› â€‹ æ±‚å¤§åŒºé—´ç´ æ•°ä¸ªæ•° #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; const int S = 1e6; // S = sqrt(N);Næ˜¯èŒƒå›´ int isprime[S]; vector&lt;int&gt; prime; ll v[S], f[S]; double inv[S]; void sieve() { fill(isprime + 2, isprime + S, 1); for (int i = 2; i &lt; S; ++i) { if (isprime[i]) prime.push_back(i); for (auto &amp;p : prime) { if (i * p &gt;= S) break; isprime[i * p] = 0; if (i % p == 0) break; } } } ll get(long long n) { // è¿”å› [1,n] çš„ç´ æ•°ä¸ªæ•° if (n &lt;= 1) return 0; int lim = sqrt(n); int cnt = 0; for (ll i = 1; i &lt;= n; i = n / (n / i) + 1) v[cnt++] = n / i; auto getid = [&amp;](long long x) { return x &lt;= lim ? cnt - x : n / x - 1; }; for (int i = 0; i &lt; cnt; ++i) f[i] = v[i] - 1; for (int i = 0; prime[i] &lt;= lim; ++i) for (int j = 0; j &lt; cnt &amp;&amp; 1ll * prime[i] * prime[i] &lt;= v[j]; ++j) f[j] -= f[getid(v[j] * inv[prime[i]] + 1e-9)] - i; return f[0]; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); for (int i = 1; i &lt; S; ++i) inv[i] = 1.0 / i; sieve(); ll n; cin &gt;&gt; n; cout &lt;&lt; get(n) &lt;&lt; '\\n'; return 0; } Miller_Rabin åˆ¤æ–­å¤§æ•°æ˜¯å¦ä¸ºç´ æ•° #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline ll mul(ll x, ll y, ll mod) { return (__int128)x * y % mod; } inline ll qpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y &gt;&gt;= 1, x = mul(x, x, mod)) if (y &amp; 1) res = mul(res, x, mod); return res; } const int pr[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}; bool Miller_Rabin(ll x)//O(7log) { if (x &lt; 3 || x % 2 == 0) return x == 2; int r = 0; ll k = x - 1; while(k % 2 == 0) k /= 2, ++r; for (int T = 0; T &lt;= 6; T++) { ll p = pr[T]; if (p % x == 0) continue; ll v = qpow(p, k, x); if (v == 1) continue; int j; for (j = 1; j &lt;= r; j++, v = mul(v, v, x)) if (v == x - 1) break; if (j &gt; r) return 0; } return 1; } void solve() { ll x; while(cin &gt;&gt; x) cout &lt;&lt; (isprime(x) ? &quot;Y&quot; : &quot;N&quot;) &lt;&lt; '\\n'; } Pollard rho å¯ä»¥åˆ†è§£å‡ºå¤§æ•°çš„è´¨å› å­(æ”¹ get)ï¼Œç”¨ $Pollard rho$ æ‰¾å‡ºä¸€ä¸ªå› å­ $x$ï¼Œç„¶åæ¥ç€å¯¹ $x$ å’Œ $\\frac{n}{x}$ ç”¨ $Pollard rho$ æ¥åˆ†è§£ ä»¥ä¸‹ä»£ç ä¸ºæ‰¾å‡ºå¤§æ•°çš„æœ€å¤§è´¨å› å­ #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; ll max_factor, n; ll gcd(ll a, ll b){ return b ? gcd(b, a % b) : a; } inline ll mul(ll x, ll y, ll mod) { return (__int128)x * y % mod; } inline ll qpow(ll x, ll y, ll mod) { ll res = 1; for (; y; y &gt;&gt;= 1, x = mul(x, x, mod)) if (y &amp; 1) res = mul(res, x, mod); return res; } const int pr[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}; bool Miller_Rabin(ll x)//åˆ¤æ–­ç´ æ•° O(7log) { if (x &lt; 3 || x % 2 == 0) return x == 2; int r = 0; ll k = x - 1; while(k % 2 == 0) k /= 2, ++r; for (int T = 0; T &lt;= 6; T++) { ll p = pr[T]; if (p % x == 0) continue; ll v = qpow(p, k, x); if (v == 1) continue; int j; for (j = 1; j &lt;= r; j++, v = mul(v, v, x)) if (v == x - 1) break; if (j &gt; r) return 0; } return 1; } ll Pollard_Rho(ll x) //è¿”å› x çš„ä¸€ä¸ªå› å­ï¼Œ O(n^(1/4)) { ll s = 0, t = 0; ll c = rand() % (x - 1) + 1; ll val = 1; for (int goal = 1; ; goal *= 2, s = t, val = 1)// å€å¢ä¼˜åŒ– { for (int step = 1; step &lt;= goal; ++step) { t = ((__int128)t * t + c) % x; val = mul(val, abs(t - s), x); if (step % 127 == 0) { ll d = gcd(val, x); if (d &gt; 1) return d; } } ll d = gcd(val, x); if (d &gt; 1) return d; } } void get(ll x) { if (x &lt;= max_factor || x &lt; 2) return; if (Miller_Rabin(x)) { // å¦‚æœxä¸ºè´¨æ•° max_factor = max(max_factor, x); // æ›´æ–°ç­”æ¡ˆ return; } ll p = x; while (p &gt;= x) p = Pollard_Rho(x); // ä½¿ç”¨è¯¥ç®—æ³• while (x % p == 0) x /= p; get(x), get(p); // ç»§ç»­å‘ä¸‹åˆ†è§£xå’Œp } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { srand((unsigned)time(NULL)); max_factor = 0; scanf(&quot;%lld&quot;, &amp;n); get(n); if (max_factor == n) // æœ€å¤§çš„è´¨å› æ•°å³è‡ªå·± printf(&quot;Prime\\n&quot;); else printf(&quot;%lld\\n&quot;, max_factor); } return 0; }","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"æ•°è®º","slug":"15","date":"2024-06-04T07:54:45.299Z","updated":"2024-06-04T08:05:54.983Z","comments":true,"path":"2024/06/04/15/","link":"","permalink":"/2024/06/04/15/","excerpt":"","text":"åŒä½™ â€‹ è‹¥$a\\equiv b(mod\\ m)$ï¼Œ $a\\equiv b(mod\\ n)$ åˆ™ $a\\equiv b(mod\\ (n,m))$ â€‹ è‹¥$(k, m) = d$ï¼Œ$ka \\equiv kb(mod\\ m)$ï¼Œåˆ™ $a \\equiv b(mod\\ \\frac{m}{d})$ ç®€åŒ–å‰©ä½™ç³» æ‰€æœ‰$n$æ»¡è¶³$0&lt;n\\leq m, (n,m)=1$ æ„æˆäº†ä¸€ä¸ªæ¨¡$m$çš„ç®€åŒ–å‰©ä½™ç³» è®°è¿™æ ·çš„$n$çš„ä¸ªæ•°ä¸º$\\varphi(m)$ $\\varphi(m)=m\\prod_{p|m}(1-\\frac{1}{p})$ ll eular(ll n)//æ±‚å•ä¸ªæ•° { ll ans = n; for(int i=2; i*i &lt;= n; ++i) { if(n%i == 0) { ans = ans/i*(i-1); while(n%i == 0) n/=i; } } if(n &gt; 1) ans = ans/n*(n-1); return ans; } int m[n],phi[n],p[n],nump; //m[i]æ ‡è®°iæ˜¯å¦ä¸ºç´ æ•°;pæ˜¯å­˜æ”¾ç´ æ•°çš„æ•°ç»„;numpæ˜¯å½“å‰ç´ æ•°ä¸ªæ•°;phi[i]ä¸ºæ¬§æ‹‰å‡½æ•° void eular() { phi[1]=1; for (int i=2;i&lt;=n;i++) { if (!m[i])//iä¸ºç´ æ•° { p[++nump]=i;//å°†iåŠ å…¥ç´ æ•°æ•°ç»„pä¸­ phi[i]=i-1;//å› ä¸ºiæ˜¯ç´ æ•°,ç”±ç‰¹æ€§å¾—çŸ¥ } for (int j=1;j&lt;=nump&amp;&amp;p[j]*i&lt;=n;j++) //ç”¨å½“å‰å·²å¾—åˆ°çš„ç´ æ•°æ•°ç»„pç­›,ç­›å»p[j]*i { m[p[j]*i]=1;//å¯ä»¥ç¡®å®ši*p[j]ä¸æ˜¯ç´ æ•° if (i%p[j]==0) //çœ‹p[j]æ˜¯å¦æ˜¯içš„çº¦æ•°,å› ä¸ºç´ æ•°p[j],ç­‰äºåˆ¤æ–­iå’Œp[j]æ˜¯å¦äº’è´¨ { phi[p[j]*i]=phi[i]*p[j]; //ç‰¹æ€§2 break; } else phi[p[j]*i]=phi[i]*(p[j]-1); //äº’è´¨,ç‰¹æ€§3å…¶,p[j]-1å°±æ˜¯phi[p[j]] } } } è´¹é©¬å°å®šç† æ¬§æ‹‰å®šç† è‹¥$(a,m)=1$ï¼Œåˆ™$a^{\\varphi(m)} \\equiv 1(mod\\ m)$ ç‰¹æ®Šçš„ï¼Œè‹¥$m$ä¸ºè´¨æ•°ï¼Œåˆ™$\\varphi(m)=m-1$ï¼Œ$a^{m-1}\\equiv1(mod\\ m)$ï¼ˆè´¹é©¬å°å®šç†ï¼‰ é€†å…ƒ $O(n)$æ±‚$1\\thicksim n$çš„é€†å…ƒ : â€‹ $inv[i]=(p-\\frac{p}{i})*inv[p\\ mod\\ i] mod\\ p$ è£´èœ€å®šç† å¯¹äºä¸å®šæ–¹ç¨‹ $ax + by = m$, åˆ™å…¶æœ‰æ•´æ•°è§£çš„å……è¦æ¡ä»¶ä¸º$gcd(a, b) | m$ å¯¹äº$\\forall x, y \\in Z$ å‡½æ•°$f(x,y) = ax + by$çš„æœ€å°æ­£æ•´æ•°å–å€¼ä¸º $f(x, y) = gcd(x, y)$ æ‰©å±•æ¬§å‡ é‡Œå¾— å¯æ±‚å‡º $ax + by = gcd(a,b)$çš„ä¸€ç»„è§£ é€šé¡¹ : $a*(x + k * \\frac{b}{gcd(a,b)}) + b * (y + (-k) * \\frac{a}{gcd(a,b)}) = gcd(a,b)$ int exgcd(int a, int b, int&amp; x, int&amp; y) { if (b == 0) { x = 1; y = 0; return a; } int xx, yy; int d = exgcd(b, a % b, xx, yy); x = yy; y = xx - a / b * yy; return d; } $exgcd$ æœ€ç»ˆè¿”å› $gcd(a,b)$ è§£çº¿æ€§åŒä½™æ–¹ç¨‹ $ax\\equiv n(mod \\ b)$ $a,b,n$ ä¸ºç»™å®šçš„æ•´æ•°ï¼Œ$x$ ä¸ºæœªçŸ¥æ•°ï¼Œéœ€è¦ä»åŒºé—´ $[0,n-1]$ ä¸­æ±‚è§£ $x$ è‹¥ $gcd(a,b)$ ä¸å¯æ•´é™¤ $n$ ï¼Œåˆ™æ–¹ç¨‹æ— è§£ æ‰©å±•æ¬§å‡ é‡Œå¾—æ±‚è§£: å°† $ax\\equiv n(mod \\ b)$ ç­‰ä»·æˆ $ax+by=n$ ï¼Œå…¶ä¸­ $x,y$ ä¸ºæœªçŸ¥æ•° å¯¹äº $ax+by=n$ å…ˆæ±‚å‡ºä¸€ç»„è§£ $x_0,y_0$ï¼Œå³ $ax_0+by_0=gcd(a,b)$ é‚£ä¹ˆå°±å¾—åˆ°æ–¹ç¨‹ $a\\frac{n}{gcd(a,b)}x_0+b\\frac{n}{gcd(a,b)}y_0=n$ï¼Œ$\\frac{n}{gcd(a,b)}x_0$ å’Œ $\\frac{n}{gcd(a,b)}y_0$ æ˜¯åŸæ–¹ç¨‹çš„ä¸€ç»„è§£ æœ€å°æ•´æ•°è§£ä¸º $(x_0 \\ mod \\ t + t) \\ mod \\ t$ï¼Œå…¶ä¸­ $t = \\frac{b}{gcd(a,b)}$ ä¸­å›½å‰©ä½™å®šç†ï¼ˆCRTï¼‰ è§£çº¿æ€§åŒä½™æ–¹ç¨‹ç»„ åªå¯æ±‚è§£æ¨¡æ•°ä¸¤ä¸¤äº’è´¨ ll n, a[20], m[20]; ll qmul(ll a, ll b, ll mod) //å¿«é€Ÿä¹˜ï¼Œ é˜²æ­¢çˆ†ll { ll ans = 0; while (b &gt; 0) { if (b &amp; 1) ans = (ans + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; } return ans; } ll exgcd(int a, int b, int&amp; x, int&amp; y) { if (!b) { x = 1; y = 0; return a; } ll d = exgcd(b, a % b, x, y); ll temp = x; x = y; y = temp - a / b * y; return d; } ll crt() { ll ans = 0, M = 1; for (int i = 1; i &lt;= n; i++) M *= m[i]; for (int i = 1; i &lt;= n; i++) { ll x, y; ll Mi = M / m[i]; exgcd(Mi, m[i], x, y); //å¤„ç†åxå³ä¸ºMiçš„é€†å…ƒ x = (x % m[i] + m[i]) % m[i]; //é˜²æ­¢xä¸ºè´Ÿæ•° ans = (ans + qmul(qmul(Mi, a[i], M), x, M)) % M; //æ¨¡Må¾—åˆ°å”¯ä¸€è§£ } return (ans + M) % M; } void solve() { cin &gt;&gt; n; for (ll i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; m[i]; for (int i = 1; i &lt;= n; i++) a[i] = (a[i] % m[i] + m[i]) % m[i]; //a[i]å¯èƒ½ä¸ºè´Ÿæ•°ï¼Œéœ€è¦é¢„å¤„ç† cout &lt;&lt; crt(); } excrt å¢é‡æ³•ï¼ˆexcrtï¼‰ï¼Œå¯ä»¥å¤„ç†ä»»æ„æ¨¡æ•°ï¼Œä½†$lcm(æ‰€æœ‰æ¨¡æ•°)$è¦åœ¨ä¸èƒ½çˆ†æ•°æ®ç±»å‹ ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) { if (b == 0) { x = 1; y = 0; return a; } ll xx, yy; ll d = exgcd(b, a % b, xx, yy); x = yy; y = xx - a / b * yy; return d; } void merge(ll&amp; a, ll&amp; b, ll c, ll d) { ll x, y; ll g = exgcd(b, d, x, y); if ((c - a) % g != 0) { a = b = -1; return; } d /= g; ll t0 = ((c - a) / g) % d * x % d; if (t0 &lt; 0) t0 += d; a = b * t0 + a; b = b * d; } void solve() { int n; cin &gt;&gt; n; ll a = 0, b = 1;//x mod b = a for (int i = 1; i &lt;= n; i++) { int c, d;//x mod d = c cin &gt;&gt; d &gt;&gt; c; merge(a, b, c, d); } cout &lt;&lt; a &lt;&lt; '\\n'; } å°†åˆæ•°çš„é—®é¢˜å˜ä¸ºç´ æ•°å¹‚çš„é—®é¢˜ ç»™å®š $n$ ä¸ªæ–¹ç¨‹ï¼Œ$x\\equiv a_i\\ (mod\\ m_i)$ ï¼Œåˆ¤æ–­æ–¹ç¨‹æ˜¯å¦æœ‰è§£ æ¨¡ä¸€ä¸ªæ•° å’Œ æ¨¡è¿™ä¸ªæ•°çš„æ‰€æœ‰ç´ æ•°å¹‚ç­‰ä»· å¯ä»¥å°†æ¯ä¸ª$m_i$è½¬åŒ–ä¸ºç´ æ•°å¹‚çš„å½¢å¼ï¼Œå¦‚$x \\equiv 3(mod\\ 12)$å¯ä»¥è½¬åŒ–ä¸º â€‹ $x \\equiv 4(mod\\ 3)$ â€‹ $x \\equiv 0(mod\\ 3)$ ï¼ˆåŒæ—¶æ»¡è¶³ï¼‰ æ–¹ç¨‹ç»„æœ‰è§£åˆ™è¯´æ˜åŸå¼æœ‰è§£ è‹¥å­˜åœ¨åŒä¸€ç´ æ•°çš„å¤šç§å¹‚æ¬¡ï¼Œåˆ™è§£$x$æ—¶åªéœ€è€ƒè™‘æœ€é«˜å¹‚æ¬¡ï¼ˆä½†ä»éœ€æ£€éªŒå…¶å®ƒå¹‚æ¬¡çš„æ­£ç¡®æ€§ï¼‰ void solve() { map&lt;ll, vector&lt;pair&lt;int, int&gt;&gt;&gt; mp; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { ll a; cin &gt;&gt; a &gt;&gt; m; for (int j = 2; j * j &lt;= m; j++) { if (m % j == 0) { ll p = j, pe = 1; //peä¸ºç´ æ•°å¹‚ while (m % j == 0) m /= j, pe *= j; mp[p].push_back({ pe, a % pe }); //æ”¾å…¥ç´ æ•°å¹‚å’Œå–ä½™åçš„ç»“æœ } } if (m != 1) mp[m].push_back({ m, a % m }); } for (auto x : mp) { auto e = x.second; ll v = max_element(all(e))-&gt;second; //æ‰¾åˆ°æœ€é«˜æ¬¡å¹‚ for (auto i : e) { if (v % i.first != i.second) //æ£€éªŒä½å¹‚æ¬¡çš„æ­£ç¡®æ€§ï¼Œè‹¥ç»“æœä¸åŒè¯´æ˜æ— è§£ { cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return; } } } cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; } æ‰©å±•Luscaå®šç† int m, T, M, phipe; pair&lt;int, int&gt; x[110]; ll pr[110]; ll ans[N], a[N], b[N], fac[1010000]; ll qpowmod(ll base, ll pow, ll mod) { base %= mod; ll ans = 1; while (pow) { if (pow &amp; 1) ans = ans * base % mod; pow &gt;&gt;= 1; base = base * base % mod; } return ans; } ll cntp, cnts; ll cal(ll a, int p, int pe, int w)//åˆ†è§£é˜¶ä¹˜ï¼ˆå°†pä»é˜¶ä¹˜ä¸­åˆ†è§£å‡ºæ¥ï¼‰ { ll val = 1; while (a) { cntp += (a / p) * w; cnts += (a / pe) * w; val = val * fac[a % pe] % pe; a /= p; } return val; } ll C(ll a, ll b, int p, int pe) { cntp = cnts = 0; ll f1 = cal(a, p, pe, 1);//f1,f2,f3ä¸ºæ¯æ¬¡å‰©ä¸‹çš„ä¹˜ç§¯ ll f2 = cal(b, p, pe, -1); ll f3 = cal(a - b, p, pe, -1); ll v1 = f1 * qpowmod(f2 * f3 % pe, phipe - 1, pe) % pe; ll v2 = qpowmod(p, cntp, pe);//p ll v3 = qpowmod(fac[pe], cnts, pe);//æ•´ç»„çš„ return v1 * v2 % pe * v3 % pe; } void solve()//Tç»„æµ‹è¯•æ ·ä¾‹ï¼Œæ¨¡æ•°ç›¸åŒ { cin &gt;&gt; m &gt;&gt; T; M = m; int tot = 0; for (int i = 2; i &lt;= m; i++)//åˆ†è§£è´¨æ•°ï¼Œ è‹¥mè¾ƒå¤§ï¼Œ åˆ™ i * i &lt;= m, æœ€åå†åˆ¤if(m &gt; 1) { if (m % i == 0) { int p = i, pe = 1; while (m % i == 0) { m /= i; pe *= i; } x[++tot] = { p, pe }; } } for (int i = 1; i &lt;= tot; i++)//CRT { int pe = x[i].second; ll Mi = M / pe; for (int c = Mi; c &lt; M; c += Mi)//ä¹Ÿå¯ä»¥ç”¨exgcdæ±‚ { if (c % pe == 1) { pr[i] = c; break; } } } for (int i = 1; i &lt;= T; i++) cin &gt;&gt; a[i] &gt;&gt; b[i]; for (int i = 1; i &lt;= tot; i++) { int p = x[i].first, pe = x[i].second; fac[0] = 1; for (int j = 1; j &lt;= pe; j++) { if (j % p == 0) fac[j] = fac[j - 1]; else fac[j] = fac[j - 1] * j % pe; } phipe = pe / p * (p - 1);//ç”¨äºåé¢æ±‚é€†å…ƒ for (int j = 1; j &lt;= T; j++) ans[j] = (ans[j] + C(a[j], b[j], p, pe) * pr[i] % M) % M; } for (int i = 1; i &lt;= T; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; }","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"æ•°æ®ç»“æ„","slug":"14","date":"2024-06-04T07:54:43.413Z","updated":"2024-06-04T08:05:57.686Z","comments":true,"path":"2024/06/04/14/","link":"","permalink":"/2024/06/04/14/","excerpt":"","text":"å¹¶æŸ¥é›† struct DSU { vector&lt;int&gt; fa, sz; DSU(int n) : fa(n+1), sz(n + 1, 1) { iota(fa.begin(), fa.end(), 0); } int find(int x){ while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x; } bool same(int x, int y) { return find(x) == find(y); } bool merge(int x, int y){ x = find(x); y = find(y); if (x == y) return false; if (sz[x] &gt; sz[y]) swap(x, y); sz[y] += sz[x]; fa[x] = y; return true; } int size(int x) { return sz[find(x)]; } }; æ ‘çŠ¶æ•°ç»„ struct BIT { int n; vector&lt;int&gt; c; BIT(int sz) : n(sz), c(sz + 1) {}; int lowbit(int x) { return x &amp; -x; } void add(int x, int val) { while (x &lt;= n) c[x] += val, x += lowbit(x); } int getsum(int x){ int ans = 0; while (x) ans += c[x], x -= lowbit(x); return ans; } int query(int l, int r){ return getsum(r) - getsum(l - 1); } int kth(int k) {//å¤§äºç­‰äºkçš„æœ€å°ä½ç½® int res = 0, x = 0; for (int i = log2(n); i &gt;= 0; --i) { x += 1 &lt;&lt; i; if (x &gt;= n || res + c[x] &gt;= k) x -= 1 &lt;&lt; i; else res += c[x]; } return x + 1; } }; çº¿æ®µæ ‘ å•ç‚¹ä¿®æ”¹ åŒºé—´å’ŒæŸ¥è¯¢ struct SegTree { struct node { int l, r, sum; }tree[N &lt;&lt; 2];//å››å€å¤§å° void push_up(int p) { tree[p].sum = tree[p &lt;&lt; 1].sum + tree[p &lt;&lt; 1 | 1].sum; } void build(int l, int r, int p) { tree[p].l = l, tree[p].r = r; if (l == r) { tree[p].sum = a[l]; return; } int mid = (l + r) / 2; build(l, mid, p &lt;&lt; 1); build(mid + 1, r, p &lt;&lt; 1 | 1); push_up(p); } void update(int pos, int val, int p)//å•ç‚¹ä¿®æ”¹ï¼Œç›´æ¥ä¿®æ”¹å€¼ { int l = tree[p].l, r = tree[p].r; if (l == r) { tree[p].sum = val; return; } int mid = (l + r) / 2; if (pos &lt;= mid) update(pos, val, p &lt;&lt; 1); else update(pos, val, p &lt;&lt; 1 | 1); push_up(p); } int query(int ql, int qr, int p)//æŸ¥è¯¢åŒºé—´å’Œ { int l = tree[p].l, r = tree[p].r; if (ql &lt;= l &amp;&amp; qr &gt;= r) { return tree[p].sum; } int mid = (l + r) / 2; int ans = 0; if (ql &lt;= mid) ans += query(ql, qr, p &lt;&lt; 1); if (qr &gt; mid) ans += query(ql, qr, p &lt;&lt; 1 | 1); return ans; } }; åŒºé—´ä¿®æ”¹ åŒºé—´æŸ¥è¯¢ æœ€å¤§å€¼ struct SegTree { struct node { int l, r, mx, lazy; }tree[N &lt;&lt; 2]; void build(int l, int r, int p) { tree[p].l = l, tree[p].r = r; tree[p].mx = tree[p].lazy = 0; if (l == r) return; int mid = (l + r) / 2; build(l, mid, p &lt;&lt; 1); build(mid + 1, r, p &lt;&lt; 1 | 1); } void push_up(int p) { tree[p].mx = max(tree[p &lt;&lt; 1].mx, tree[p &lt;&lt; 1 | 1].mx); } void push_down(int p) { if (!tree[p].lazy) return; tree[p &lt;&lt; 1].mx += tree[p].lazy; tree[p &lt;&lt; 1 | 1].mx += tree[p].lazy; tree[p &lt;&lt; 1].lazy += tree[p].lazy; tree[p &lt;&lt; 1 | 1].lazy += tree[p].lazy; tree[p].lazy = 0; } void update(int ul, int ur, int val, int p) { int l = tree[p].l, r = tree[p].r; if (ul &lt;= l &amp;&amp; ur &gt;= r) { tree[p].mx += val; tree[p].lazy += val; return; } push_down(p); int mid = (l + r) / 2; if (ul &lt;= mid) update(ul, ur, val, p &lt;&lt; 1); if (ur &gt; mid) update(ul, ur, val, p &lt;&lt; 1 | 1); push_up(p); } int query(int ql, int qr, int p) { int l = tree[p].l, r = tree[p].r; if (ql &lt;= l &amp;&amp; qr &gt;= r) return tree[p].mx; push_down(p); int mid = (l + r) / 2; int ans = 0; if (ql &lt;= mid) ans = max(ans, query(ql, qr, p &lt;&lt; 1)); if (qr &gt; mid) ans = max(ans, query(ql, qr, p &lt;&lt; 1 | 1)); return ans; } }sg; ä¸»å¸­æ ‘ï¼ˆ å¯æŒä¹…åŒ–æƒå€¼çº¿æ®µæ ‘ ï¼‰ int n, m, a[N], b[N];///æ±‚åŒºé—´[l,r]ä¸­çš„ç¬¬kå¤§å…ƒç´  struct node{ int ls, rs, sum;//lsï¼šå·¦å„¿å­ç¼–å· lrï¼šå³å„¿å­ç¼–å· sumï¼šå…ƒç´ ä¸ªæ•° }tree[N&lt;&lt;5];//ä¸€èˆ¬å¼€32å€å¤§å° int rt[N], sz;//rt[i]ï¼šç¬¬iä¸ªæ ¹èŠ‚ç‚¹ç¼–å· sz ï¼šèŠ‚ç‚¹æ•°é‡ void update(int l, int r, int &amp;x, int y, int p) { x = ++sz; tree[x] = tree[y];//å…ˆå°†èŠ‚ç‚¹åŸç‚¹ä¿¡æ¯å¤åˆ¶ tree[x].sum++;//å…ƒç´ ä¸ªæ•°å¢åŠ  if(l == r) return; int mid = (l + r) / 2; if(p &lt;= mid) update(l, mid, tree[x].ls, tree[y].ls, p); else update(mid + 1, r, tree[x].rs, tree[y].rs, p); } int query(int l, int r, int x, int y, int k) { int temp = tree[tree[y].ls].sum - tree[tree[x].ls].sum;//å·¦åŠè¾¹å…ƒç´ ä¸ªæ•° if(l == r) return l; int mid = (l + r) / 2; if(temp &gt;= k) return query(l, mid, tree[x].ls, tree[y].ls, k); else return query(mid+1, r, tree[x].rs, tree[y].rs, k - temp); } void solve() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; b[i] = a[i]; } sort(b + 1, b + 1 + n); int len = unique(b + 1, b + 1 + n) - b - 1;//ç¦»æ•£åŒ–æ•°æ® for(int i = 1; i &lt;= n; i++) { int p = lower_bound(b + 1, b + 1 + len, a[i]) - b;//å¯»æ‰¾a[i]ç¦»æ•£åŒ–åçš„æ•°æ® update(1, len, rt[i], rt[i-1], p); } while(m--) { ll l, r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; b[query(1, len, rt[l-1], rt[r], k)] &lt;&lt; '\\n'; } } å­—å…¸æ ‘ å­—ç¬¦ä¸² int tot;//ç‚¹æ•° struct node{ int alp[26];//alp[i]è‹¥ä¸ºæ­£æ•°ï¼Œåˆ™æœ‰å¯é€šå‘å¯¹åº”å­—æ¯çš„ç‚¹ int isend;//è¯¥ç‚¹æ˜¯å¦å¯ä»¥ä½œä¸ºç»ˆç‚¹ }tree[N];//å¼€æ¨¡å¼ä¸²ä¸ªæ•°*é•¿åº¦çš„å¤§å° void insert(string s) { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp]) tree[p].alp[temp] = ++tot; p = tree[p].alp[temp]; } tree[p].isend = 1; } bool search(string s) { int p = 0; for(int i = 0; i &lt; s.size(); i++) { int temp = s[i] - 'a'; if(!tree[p].alp[temp])//æ²¡æœ‰å¯¹åº”çš„ç‚¹ return false; p = tree[p].alp[temp]; } if(tree[p].isend)//åˆ¤æ–­è¯¥ç‚¹æ˜¯å¦å¯ä½œä¸ºç»ˆç‚¹ return true; return false; } void solve() { cin&gt;&gt;n; string s; for(ll i = 1; i &lt;= n; i++) { cin&gt;&gt;s; insert(s); } map&lt;string, ll&gt; mp; cin&gt;&gt;q; while(q--) { cin&gt;&gt;s; bool f = search(s); if(!f) cout&lt;&lt;&quot;WRONG&quot;&lt;&lt;'\\n'; else { mp[s]++; if(mp[s] == 2) { cout&lt;&lt;&quot;REPEAT&quot;&lt;&lt;'\\n'; mp[s] = 1; } else cout&lt;&lt;&quot;OK&quot;&lt;&lt;'\\n'; } }//æ´›è°·P2580 } äºŒè¿›åˆ¶ #include&lt;bits/stdc++.h&gt;//cf 817E #define ll long long using namespace std; const int N = 1e5 + 5; ll n; struct node { ll bit[2]; ll cnt; }tree[N &lt;&lt; 5];å¼€æ¨¡å¼ä¸²ä¸ªæ•°*é•¿åº¦çš„å¤§å° ll sz; void insert(ll num) { ll p = 0; for (ll i = 31; i &gt;= 0; i--) { if (!tree[p].bit[(num &gt;&gt; i) &amp; 1]) tree[p].bit[(num &gt;&gt; i) &amp; 1] = ++sz; p = tree[p].bit[(num &gt;&gt; i) &amp; 1]; tree[p].cnt++; } } void del(ll num) { ll p = 0; for (ll i = 31; i &gt;= 0; i--) { if (!tree[p].bit[(num &gt;&gt; i) &amp; 1]) return; p = tree[p].bit[(num &gt;&gt; i) &amp; 1]; tree[p].cnt--; } } ll search(ll num1, ll num2) { ll p = 0; ll ans = 0; for (ll i = 31; i &gt;= 0; i--) { ll x = (num1 &gt;&gt; i) &amp; 1; ll y = (num2 &gt;&gt; i) &amp; 1; if (x == 1) { if (y == 1) { ans += tree[tree[p].bit[1]].cnt; p = tree[p].bit[0]; } else if (y == 0) p = tree[p].bit[1]; } else if (x == 0) { if (y == 1) { ans += tree[tree[p].bit[0]].cnt; p = tree[p].bit[1]; } else if (y == 0) p = tree[p].bit[0]; } if (!p) break; } return ans; } void solve() { cin &gt;&gt; n; while (n--) { ll op; cin &gt;&gt; op; if (op == 1) { ll x; cin &gt;&gt; x; insert(x); } else if (op == 2) { ll x; cin &gt;&gt; x; del(x); } else { ll x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; search(x, y) &lt;&lt; '\\n'; } } } int main() { solve(); return 0; } STè¡¨ ä¸€ç»´STè¡¨ æœ€å¤§/å°å€¼ï¼Œ gcdï¼Œ æŒ‰ä½æˆ– int mx[21][N], Log[N]; void init_ST() { for (int j = 1; j &lt;= 20; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) mx[j][i] = max(mx[j - 1][i], mx[j - 1][i + (1 &lt;&lt; (j - 1))]); Log[1] = 0; for (int i = 2; i &lt;= n; i++) Log[i] = Log[i / 2] + 1; } int query(int l, int r) { int k = Log[r - l + 1]; return max(mx[k][l], mx[k][r - (1 &lt;&lt; k) + 1]); } äºŒç»´STè¡¨ int mi[N][N][21][21], Log[N]; void init_ST() { for (int i = 0; i &lt;= 20; i++){ for (int j = 0; j &lt;= 20; j++){ if (i == 0 and j == 0) continue; for (int k = 1; k &lt;= n - (1 &lt;&lt; i) + 1; k++){ for (int p = 1; p &lt;= m - (1 &lt;&lt; j) + 1; p++){ if (i == 0) mi[k][p][i][j] = min(mi[k][p][i][j - 1], mi[k][p + (1 &lt;&lt; j - 1)][i][j - 1]); else mi[k][p][i][j] = min(mi[k][p][i - 1][j], mi[k + (1 &lt;&lt; i - 1)][p][i - 1][j]); } } } } Log[1] = 0; for (int i = 2; i &lt;= n; i++) Log[i] = Log[i / 2] + 1; } int query(int r1, int c1, int r2, int c2) { int k1 = Log[r2 - r1 + 1]; int k2 = Log[c2 - c1 + 1]; return min({mi[r1][c1][k1][k2], mi[r2 - (1 &lt;&lt; k1) + 1][c1][k1][k2], mi[r1][c2 - (1 &lt;&lt; k2) + 1][k1][k2], mi[r2 - (1 &lt;&lt; k1) + 1][c2 - (1 &lt;&lt; k2) + 1][k1][k2]}); } è«é˜Ÿ è«é˜Ÿ //https://codeforces.com/contest/1484/problem/D #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-4; const ll mod = 1e9 + 7; const ll N = 5e4 + 5; ll n, m, a[N], len, pos[N], res, num[N], ans[N], le[N]; struct node { ll l, r, id; bool operator &lt; (const node&amp; a) const { if (pos[l] != pos[a.l]) return pos[l] &lt; pos[a.l]; if (pos[l] % 2) return r &lt; a.r; return r &gt; a.r; } }q[N]; void add(ll x) { res -= num[a[x]] * (num[a[x]] - 1) / 2; num[a[x]]++; res += num[a[x]] * (num[a[x]] - 1) / 2; } void del(ll x) { res -= num[a[x]] * (num[a[x]] - 1) / 2; num[a[x]]--; res += num[a[x]] * (num[a[x]] - 1) / 2; } ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; } void solve() { cin &gt;&gt; n &gt;&gt; m; len = sqrt(n); for (ll i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; pos[i] = (i + len - 1) / len; } for (ll i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; } sort(q + 1, q + 1 + m); for (ll i = 1, l = 1, r = 0; i &lt;= m; i++) { while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); ans[q[i].id] = res; le[q[i].id] = q[i].r - q[i].l + 1; } for (ll i = 1; i &lt;= m; i++) { if (!ans[i]) { cout &lt;&lt; &quot;0/1&quot; &lt;&lt; '\\n'; continue; } ll x = le[i] * (le[i] - 1) / 2; ll g = gcd(ans[i], x); cout &lt;&lt; ans[i] / g &lt;&lt; &quot;/&quot; &lt;&lt; x / g &lt;&lt; '\\n'; } } signed main() { IOS; ll t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } å›æ»šè«é˜Ÿ //https://vjudge.net/contest/501795#problem/D #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-4; const ll mod = 1e9 + 7; const ll N = 1e5 + 5; ll n, m, len, pos[N], a[N], num[N], num2[N], ans[N], b[N]; struct node { ll l, r, id; bool operator &lt; (const node&amp; a) const { if (pos[l] != pos[a.l]) return pos[l] &lt; pos[a.l]; return r &lt; a.r; } }q[N]; void add(ll x, ll&amp; res) { num[x]++; res = max(res, num[x] * b[x]); } void del(ll x) { num[x]--; } void solve() { cin &gt;&gt; n &gt;&gt; m; len = sqrt(n); for (ll i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; b[i] = a[i]; pos[i] = (i + len - 1) / len; } sort(b + 1, b + 1 + n); ll cnt = unique(b + 1, b + 1 + n) - b - 1;//ç¦»æ•£åŒ– for (ll i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b; for (ll i = 1; i &lt;= m; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; } sort(q + 1, q + 1 + m); ll res = 0, l = 1, r = 0, last = 0; for (ll i = 1; i &lt;= m; i++) { //å·¦å³åŒºé—´éƒ½åœ¨åŒä¸€ä¸ªå—å†…,é•¿åº¦è¾ƒå°ç›´æ¥æš´åŠ› if (pos[q[i].l] == pos[q[i].r]) { ll res2 = 0; for (ll j = q[i].l; j &lt;= q[i].r; j++) { num2[a[j]]++; res2 = max(res2, num2[a[j]] * b[a[j]]); } ans[q[i].id] = res2; for (ll j = q[i].l; j &lt;= q[i].r; j++) num2[a[j]]--; continue; } //å¦‚æœå½“å‰è¯¢é—®å—å·å’Œå‰ä¸€æ¬¡ä¸åŒï¼Œå°†å·¦æŒ‡é’ˆç§»åŠ¨åˆ°å½“å‰å—æœ€å³ç«¯+1ï¼Œå³æŒ‡é’ˆç§»åŠ¨åˆ°å½“å‰å—å³ç«¯ if (last != pos[q[i].l]) { ll R = min(n, pos[q[i].l] * len); while (r &gt; R) del(a[r--]); while (l &lt; R + 1) del(a[l++]); res = 0; last = pos[q[i].l]; } while (r &lt; q[i].r) add(a[++r], res); ll templ = l; ll temp_res = res; //ç­”æ¡ˆå¤‡ä»½ while (templ &gt; q[i].l) add(a[--templ], temp_res); ans[q[i].id] = temp_res; //å›æ»š while (templ &lt; l) del(a[templ++]); } for (ll i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } signed main() { IOS; ll t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } æ ‘ä¸Šè«é˜Ÿ int n, m, a[N]; int tot, fa[N], dep[N], sz[N], hson[N], top[N], rnk[N]; int li[N * 2], st[N], ed[N]; int pos[N * 2]; int ans[N], res, cnt[N], use[N]; vector&lt;int&gt; g[N]; vector&lt;int&gt; v; struct Query { int l, r, id, lca; bool operator &lt; (Query a) { if (pos[l] != pos[a.l]) return pos[l] &lt; pos[a.l]; if (pos[l] % 2) return r &lt; a.r; return r &gt; a.r; } }q[N]; void dfs1(int x, int father, int d) { dep[x] = d; hson[x] = -1; sz[x] = 1; for (auto to : g[x]) { if (to == father) continue; fa[to] = x; dfs1(to, x, d + 1); sz[x] += sz[to]; if (hson[x] == -1 || sz[to] &gt; sz[hson[x]]) hson[x] = to; } } void dfs2(int x, int t) { top[x] = t; st[x] = ++tot; li[tot] = x; rnk[tot] = x; if (hson[x] != -1) dfs2(hson[x], t); for (auto to : g[x]) { if (to == fa[x] || to == hson[x]) continue; dfs2(to, to); } ed[x] = ++tot; li[tot] = x; } int Lca(int x, int y) { while (top[x] != top[y]) { if (dep[top[x]] &gt; dep[top[y]]) x = fa[top[x]]; else y = fa[top[y]]; } if (dep[x] &gt; dep[y]) swap(x, y); return x; } void cal(int x) { if (use[x] == 0) { cnt[a[x]]++; if (cnt[a[x]] == 1) res++; } else { cnt[a[x]]--; if (cnt[a[x]] == 0) res--; } use[x] ^= 1; } void solve() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1, u, v; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } for (int i = 1; i &lt;= n; i++) v.push_back(a[i]); sort(all(v)); v.erase(unique(all(v)), v.end()); for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(all(v), a[i]) - v.begin(); dfs1(1, -1, 1); dfs2(1, 1); int len = sqrt(n) + 1; for (int i = 1; i &lt;= n * 2; i++) pos[i] = (i - 1) / len + 1; for (int i = 1, x, y; i &lt;= m; i++) { cin &gt;&gt; x &gt;&gt; y; q[i].id = i; if (st[x] &gt; st[y]) swap(x, y); q[i].lca = Lca(x, y); if (q[i].lca == x)//x, yåœ¨ä»¥xä¸ºæ ¹çš„å­æ ‘ä¸­ { q[i].l = st[x]; q[i].r = st[y]; q[i].lca = 0; } else { q[i].l = ed[x]; q[i].r = st[y]; } } sort(q + 1, q + 1 + m); for (int i = 1, l = 1, r = 0; i &lt;= m; i++) { while (l &gt; q[i].l) cal(li[--l]); while (r &lt; q[i].r) cal(li[++r]); while (l &lt; q[i].l) cal(li[l++]); while (r &gt; q[i].r) cal(li[r--]); if (q[i].lca) cal(q[i].lca); ans[q[i].id] = res; if (q[i].lca) cal(q[i].lca); } for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } æ ‘é“¾å‰–åˆ† é‡é“¾å‰–åˆ† int tot, fa[N], dep[N], sz[N], hson[N], top[N], dfn[N], rnk[N]; vector&lt;int&gt; g[N]; void dfs1(int x, int father, int d) { dep[x] = d; hson[x] = -1; sz[x] = 1; for (auto to : g[x]) { if (to == father) continue; fa[to] = x; dfs1(to, x, d + 1); sz[x] += sz[to]; if (hson[x] == -1 || sz[to] &gt; sz[hson[x]]) hson[x] = to; } } void dfs2(int x, int t) { top[x] = t;//æ‰€åœ¨é‡é“¾çš„æœ€é«˜ç‚¹t dfn[x] = ++tot; rnk[tot] = x; if (hson[x] == -1) return; dfs2(hson[x], t); for (auto to : g[x]) { if (to == fa[x] || to == hson[x]) continue; dfs2(to, to); } } int Qmx(int x, int y) { int ans = -inf, fx = top[x], fy = top[y]; while (fx != fy) { if (dep[fx] &gt; dep[fy]) { ans = max(ans, st.query_mx(dfn[fx], dfn[x], 1)); x = fa[fx]; fx = top[x]; } else { ans = max(ans, st.query_mx(dfn[fy], dfn[y], 1)); y = fa[fy]; fy = top[y]; } } if (dfn[x] &lt; dfn[y]) swap(x, y); ans = max(ans, st.query_mx(dfn[y], dfn[x], 1)); return ans; } void Update(int x, int y, int val) { int fx = top[x], fy = top[y]; while (fx != fy) { if (dep[fx] &gt; dep[fy]) { st.update(dfn[fx], dfn[x], val, 1); x = fa[fx]; fx = top[x]; } else { st.update(dfn[fy], dfn[y], val, 1); y = fa[fy]; fy = top[y]; } } if (dfn[x] &gt; dfn[y]) swap(x, y); st.update(dfn[x], dfn[y], val, 1); } CDQåˆ†æ²» ç¦»çº¿è§£å†³ä¸‰ç»´ååºé—®é¢˜ï¼Œ è§£å†³å’Œç‚¹å¯¹æœ‰å…³çš„é—®é¢˜ åŸåˆ™ ï¼šå‰ä¸€åŠæ›´æ–°åä¸€åŠ //https://www.luogu.com.cn/problem/P3157 #include&lt;bits/stdc++.h&gt; #include&lt;unordered_map&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const int inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-8; const ll mod = 998244353; const int N = 1e5 + 5; int n, m, rk[N]; struct node { int val, del; int ans; }a[N]; struct BIT { int b[N]; int lowbit(int x) { return x &amp; (-x); } void add(int x, int val) { while (x &lt; N) { b[x] += val; x += lowbit(x); } } int getsum(int x) { int ans = 0; while (x) { ans += b[x]; x -= lowbit(x); } return ans; } int query(int l, int r) { return getsum(r) - getsum(l - 1); } }b; void cdq(int l, int r) { if (l == r) return; int mid = (l + r) / 2; cdq(l, mid); cdq(mid + 1, r); int i = l; int j = mid + 1; while (i &lt;= mid) { while (a[i].val &gt; a[j].val &amp;&amp; j &lt;= r) { b.add(a[j].del, 1); j++; } a[i].ans += b.query(a[i].del + 1, m + 1); i++; } i = l; j = mid + 1; while (i &lt;= mid) { while (a[i].val &gt; a[j].val &amp;&amp; j &lt;= r) { b.add(a[j].del, -1); j++; } i++; } i = mid; j = r; while (j &gt;= mid + 1) { while (a[i].val &gt; a[j].val &amp;&amp; i &gt;= l) { b.add(a[i].del, 1); i--; } a[j].ans += b.query(a[j].del + 1, m + 1); j--; } i = mid; j = r; while (j &gt;= mid + 1) { while (a[i].val &gt; a[j].val &amp;&amp; i &gt;= l) { b.add(a[i].del, -1); i--; } j--; } sort(a + l, a + 1 + r, [](node&amp; a, node&amp; b) { return a.val &lt; b.val; }); } void solve() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].val, rk[a[i].val] = i, a[i].del = m + 1; for (int i = 1, x; i &lt;= m; i++) { cin &gt;&gt; x; a[rk[x]].del = i; } ll res = 0; for (int i = 1; i &lt;= n; i++) { res += b.query(a[i].val + 1, n); b.add(a[i].val, 1); } for (int i = 1; i &lt;= n; i++) b.add(a[i].val, -1); cdq(1, n); sort(a + 1, a + 1 + n, [](node&amp; a, node&amp; b) { return a.del &lt; b.del; }); for (int i = 1; i &lt;= m; i++) { cout &lt;&lt; res &lt;&lt; '\\n'; res -= a[i].ans; } } signed main() { IOS; int t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } //https://codeforces.com/contest/1045/problem/G #include&lt;bits/stdc++.h&gt; #include&lt;unordered_map&gt; #include&lt;array&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const int inf = 0x3f3f3f3f; const ll INF = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-8; const ll mod = 998244353; const int N = 1e5 + 5; int n, k; ll ans; struct node { int x, r, q, L, R; }a[N]; struct BIT { int b[N]; int lowbit(int x) { return x &amp; (-x); } void add(int x, int val) { while (x &lt; N) { b[x] += val; x += lowbit(x); } } int getsum(int x) { int ans = 0; while (x) { ans += b[x]; x -= lowbit(x); } return ans; } int query(int l, int r) { return getsum(r) - getsum(l - 1); } }b; void cdq(int l, int r) { if (l == r) return; int mid = (l + r) / 2; cdq(l, mid); cdq(mid + 1, r); int i = mid + 1; int L = l, R = l; while (i &lt;= r) { while (L &lt;= mid &amp;&amp; a[L].q &lt; a[i].q - k) b.add(a[L++].x, -1); while (R &lt;= mid &amp;&amp; a[R].q &lt;= a[i].q + k) b.add(a[R++].x, 1); ans += b.query(a[i].L, a[i].R); i++; } while (L &lt; R) b.add(a[L++].x, -1); sort(a + l, a + r + 1, [](node&amp; a, node&amp; b) { return a.q &lt; b.q; }); } int p[N]; void solve() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i].x &gt;&gt; a[i].r &gt;&gt; a[i].q; a[i].L = max(0, a[i].x - a[i].r); a[i].R = min(inf, a[i].x + a[i].r); p[i] = a[i].x; } sort(p + 1, p + 1 + n); int len = unique(p + 1, p + 1 + n) - p - 1; for (int i = 1; i &lt;= n; i++) { a[i].x = lower_bound(p + 1, p + 1 + len, a[i].x) - p; a[i].L = lower_bound(p + 1, p + 1 + len, a[i].L) - p; a[i].R = upper_bound(p + 1, p + 1 + len, a[i].R) - p - 1; } sort(a + 1, a + 1 + n, [](node&amp; a, node&amp; b) { return a.r &gt; b.r; }); cdq(1, n); cout &lt;&lt; ans &lt;&lt; '\\n'; } signed main() { IOS; int t = 1; //cin &gt;&gt; t; while (t--) solve(); return 0; } æ¬§æ‹‰åº æ¬§æ‹‰åº1 è¿™ä¸€ç§æ¬§æ‹‰åºç›¸å½“äºæ˜¯åœ¨dfsçš„æ—¶å€™ï¼Œå¦‚æœæŸä¸ªèŠ‚ç‚¹å…¥æ ˆï¼Œå°±æŠŠè¿™ä¸ªèŠ‚ç‚¹è®°å½•ä¸‹æ¥ï¼Œç›´åˆ°åé¢çš„æ“ä½œä¸­è¿™ä¸ªèŠ‚ç‚¹å‡ºæ ˆï¼Œå†è®°å½•ä¸€æ¬¡è¿™ä¸ªèŠ‚ç‚¹ æ¬§æ‹‰åº2 è¿™ä¸€ç§æ¬§æ‹‰åºç›¸å½“äºæ˜¯åœ¨dfsçš„æ—¶å€™ï¼Œå¦‚æœå‚¨å­˜èŠ‚ç‚¹çš„æ ˆå˜åŒ–ä¸€æ¬¡ï¼Œå°±æŠŠæ ˆé¡¶çš„èŠ‚ç‚¹ç¼–å·è®°å½•ä¸‹æ¥,ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯å½“è®¿é—®å®Œä¸€ä¸ªèŠ‚ç‚¹çš„å­æ ‘ï¼Œåˆ™éœ€è¦è¿”å›ä¸€æ¬¡è¯¥èŠ‚ç‚¹ æ ‘ä¸Šå¯å‘å¼åˆå¹¶ /* é¢˜æ„ ï¼šç»™å‡ºä¸€æ£µ n ä¸ªèŠ‚ç‚¹ä»¥ 1 ä¸ºæ ¹çš„æ ‘ï¼ŒèŠ‚ç‚¹ u çš„é¢œè‰²ä¸º c[u] ç°åœ¨å¯¹äºæ¯ä¸ªç»“ç‚¹ u è¯¢é—® u å­æ ‘é‡Œä¸€å…±å‡ºç°äº†å¤šå°‘ç§ä¸åŒçš„é¢œè‰²ã€‚ */ int n, a[N], c[N]; int ans[N]; vector&lt;int&gt; g[N]; int hson[N], L[N], R[N], sz[N], tot, rk[N]; int cnt[N], res; void dfs(int x, int fa) { hson[x] = -1; sz[x] = 1; L[x] = ++tot; rk[tot] = x; for (int &amp;to : g[x]) { if (to == fa) continue; dfs(to, x); sz[x] += sz[to]; if (hson[x] == -1 || sz[to] &gt; sz[hson[x]]) hson[x] = to; } R[x] = tot; } void add(int x) { cnt[c[x]]++; if(cnt[c[x]] == 1) res++; } void del(int x) { cnt[c[x]]--; if(cnt[c[x]] == 0) res--; } void dsu(int x, int fa, bool keep) { for (int &amp;to : g[x])// è®¡ç®—è½»å„¿å­çš„ç­”æ¡ˆ if (to != fa &amp;&amp; hson[x] != to) dsu(to, x, false); if (hson[x] != -1)// è®¡ç®—é‡å„¿å­ç­”æ¡ˆå¹¶ä¿ç•™è®¡ç®—è¿‡ç¨‹ä¸­çš„æ•°æ®ï¼ˆç”¨äºç»§æ‰¿ï¼‰ dsu(hson[x], x, true); for (int &amp;to : g[x])// æŠŠè½»å„¿å­(è½»å­æ ‘)çš„è´¡çŒ®åŠ è¿›å»,è¿™æ ·è¿™é¢—å­æ ‘çš„è´¡çŒ®å°±å…¨åœ¨äº† { if (to != fa &amp;&amp; hson[x] != to) { //for(int i = L[to]; i &lt;= R[to]; i++) cal(); for (int i = L[to]; i &lt;= R[to]; i++) add(rk[i]); } } add(x);// å°†å½“å‰ç‚¹çš„è´¡çŒ®åŠ è¿›å» //cal(x) ans[x] = res; // è®¡ç®—ä»¥ x ä¸ºæ ¹çš„ç­”æ¡ˆ if (!keep)//å¦‚æœå½“å‰å­æ ‘çš„æ˜¯ fa çš„è½»å„¿å­ï¼Œåˆ™åˆ é™¤å½“å‰å­æ ‘çš„è´¡çŒ® { for (int i = L[x]; i &lt;= R[x]; i++) del(rk[i]); } } void solve() { cin &gt;&gt; n; for (int i = 1, u, v; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } for(int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i]; dfs(1, -1); dsu(1, -1, false); int m; cin &gt;&gt; m; while(m--) { int x; cin &gt;&gt; x; cout &lt;&lt; ans[x] &lt;&lt; '\\n'; } } ç‚¹åˆ†æ²» // é¢˜æ„:ç»™å®šä¸€æ£µæœ‰ n ä¸ªç‚¹çš„æ ‘ï¼Œè¯¢é—®æ ‘ä¸Šè·ç¦»ä¸º k çš„ç‚¹å¯¹æ˜¯å¦å­˜åœ¨ã€‚ //Oï¼ˆnlognlognï¼‰ const int inf = 0x3f3f3f3f; const int N = 1e4 + 10; int n, m; int dis[N], vis[N], num, root, MX, sz[N], tot; vector&lt;pair&lt;int, int&gt;&gt; g[N]; int q[105], ans[105]; void getroot(int x, int fa)// æ‰¾é‡å¿ƒ { sz[x] = 1; int mx = 0; for (auto &amp;now : g[x]) { int to = now.first; if (to == fa || vis[to]) continue; getroot(to, x); sz[x] += sz[to]; mx = max(mx, sz[to]); } mx = max(mx, num - sz[x]); if (mx &lt; MX) { MX = mx; root = x; } } void getdis(int x, int fa, int d) { dis[++tot] = d; for (auto &amp;[to, w] : g[x]) { if (vis[to] || to == fa) continue; getdis(to, x, d + w); } } int cal(int x, int k)//O(logn) { int res = 0; for (int l = 1; l &lt;= tot; l++)//åˆå¹¶ç”¨äºŒåˆ†ä¿è¯å¤æ‚åº¦ res += upper_bound(dis + 1, dis + 1 + tot, k - dis[l]) - lower_bound(dis + 1, dis + 1 + tot, k - dis[l]); return res; } int ok[105];// è®°å½•è¯¢é—®æ˜¯å¦å·²ç»å­˜åœ¨ç­”æ¡ˆäº† void divide(int x)//O(nlogn)ï¼Œæ±‚è§£ä»¥å½“å‰æ‰€æ±‚å­æ ‘ä¸­ï¼Œç»è¿‡ x çš„è·¯å¾„çš„ç­”æ¡ˆ { tot = 0; getdis(x, -1, 0);// æ±‚å½“å‰å­æ ‘ä¸­æ¯ä¸ªç‚¹åˆ° x çš„è·ç¦» sort(dis + 1, dis + 1 + tot); for (int i = 1; i &lt;= m; i++) if(!ok[i]) ans[i] += cal(x, q[i]); // è®¡ç®—ç»è¿‡ x çš„è·¯å¾„çš„æ¡æ•° // å› ä¸ºæ˜¯é€šè¿‡ dis è®¡ç®—å‡ºçš„è·¯å¾„æ•°ï¼Œå¯èƒ½ä¸¤ä¸ªç«¯ç‚¹éƒ½ä½äº x çš„åŒä¸€ä¸ªå„¿å­ï¼Œæ­¤æ—¶è·¯å¾„æ˜¯éæ³•çš„ vis[x] = 1; for (auto &amp;[to, w] : g[x]) { if (vis[to]) continue; tot = 0; getdis(to, -1, w);//ä»¥ w ä¸ºèµ·å§‹è·ç¦»ï¼Œä¿è¯è·¯å¾„é•¿åº¦ç›¸åŒ sort(dis + 1, dis + 1 + tot); for (int i = 1; i &lt;= m; i++) if(!ok[i]) ans[i] -= cal(x, q[i]); // å‡å»éæ³•è·¯å¾„æ•°ï¼Œå› ä¸ºæ­¤æ—¶ dis çš„ç«¯ç‚¹éƒ½åœ¨åŒä¸€ä¸ªå„¿å­ä¸­ } for (int i = 1; i &lt;= m; i++) if (ans[i]) ok[i] = 1; // å‡å»éæ³•è·¯å¾„åï¼Œè‹¥ä»æœ‰é•¿åº¦ä¸º k çš„è·¯å¾„å­˜åœ¨åˆ™æœ‰ç­”æ¡ˆ for (auto &amp;[to, w] : g[x]) //å­é—®é¢˜ { if (vis[to]) continue; num = sz[to]; MX = inf; getroot(to, -1); divide(root); } } void solve() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1, u, v, w; i &lt; n; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back({ v, w }); g[v].push_back({ u, w }); } for (int i = 1; i &lt;= m; i++) cin &gt;&gt; q[i];// ç¦»çº¿ num = n, MX = inf; getroot(1, -1); divide(root); for (int i = 1; i &lt;= m; i++) cout &lt;&lt; (ans[i] ? &quot;AYE&quot; : &quot;NAY&quot;) &lt;&lt; '\\n'; } #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; /* ç¦»çº¿å¤„ç†è¯¢é—®ï¼Œè¯¢é—® u, v ä¼šåœ¨ è·¯å¾„ä¸ŠæŸä¸ªç‚¹ä½œä¸ºé‡å¿ƒæ—¶æ±‚è§£ï¼Œä¸ç„¶å°†è¯¢é—®ä¸¢ç»™å­æ ‘ */ const int N = 5e5 + 10; int n, q; ll c[N]; vector&lt;int&gt; g[N]; vector&lt;array&lt;int, 3&gt;&gt; qry[N]; int vis[N], sz[N], root, bel[N];//bel è®°å½•å¤„äºæ ¹çš„é‚£æ£µå­æ ‘ä¸­//æ¿å­éƒ¨åˆ† ll f[N][60]; int dp[N][60]; int ans[N]; void get_sz(int x, int fa)//æ¿å­éƒ¨åˆ† { sz[x] = 1; for(auto &amp;to : g[x]) { if(to == fa || vis[to]) continue; get_sz(to, x); sz[x] += sz[to]; } } int find(int x, int fa, int s)//æ‰¾é‡å¿ƒ//æ¿å­éƒ¨åˆ† { for(auto &amp;to : g[x]) { if(to == fa || vis[to] || 2 * sz[to] &lt;= s) continue; return find(to, x, s); } return x; } void dfs(int x, int fa)// calï¼Œå¤„ç†ç­”æ¡ˆ { for(auto &amp;to : g[x]) { if(to == fa || vis[to]) continue; bel[to] = (x == root ? to : bel[x]); for(int i = 0; i &lt; 60; i++) { if(dp[x][i] == -1 || !(c[x] &amp; c[to])) dp[to][i] = -1; else if(f[x][i] &amp; c[to]) { dp[to][i] = dp[x][i] + 1; f[to][i] = f[x][i] &amp; c[to]; } else { dp[to][i] = dp[x][i] + 2; f[to][i] = c[x] &amp; c[to]; } } dfs(to, x); } } void divide(int x) { auto Q = move(qry[x]); get_sz(x, -1);//æ¿å­éƒ¨åˆ† x = find(x, -1, sz[x]);// x ä¸ºé‡å¿ƒ //æ¿å­éƒ¨åˆ† for(int i = 0; i &lt; 60; i++) { if(c[x] &gt;&gt; i &amp; 1) { dp[x][i] = 0; f[x][i] = 1ll &lt;&lt; i; } else dp[x][i] = -1; } root = x;//æ¿å­éƒ¨åˆ† bel[x] = x;//æ¿å­éƒ¨åˆ† dfs(x, -1); for(auto &amp;[u, v, id] : Q) { if(bel[u] == bel[v]) qry[bel[u]].push_back({u, v, id}); else { for(int i = 0; i &lt; 60; i++) { if(dp[u][i] != -1 &amp;&amp; dp[v][i] != -1) { int res = dp[u][i] + dp[v][i]; if(ans[id] == -1 || ans[id] &gt; res) ans[id] = res; } } } } vis[x] = 1;//æ¿å­éƒ¨åˆ† for(auto &amp;to : g[x]) if(!vis[to]) divide(to);//æ¿å­éƒ¨åˆ† } void solve() { cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i]; for(int i = 1; i &lt; n; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); } for(int i = 1; i &lt;= q; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; qry[1].push_back({u, v, i}); } for(int i = 1; i &lt;= q; i++) ans[i] = -1; divide(1);//æ¿å­éƒ¨åˆ† for(int i = 1; i &lt;= q; i++) cout &lt;&lt; ans[i] &lt;&lt; '\\n'; } signed main() { ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); solve(); return 0; }","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"æ ‘å½¢æ¿å­","slug":"17","date":"2024-06-04T07:54:41.714Z","updated":"2024-06-04T08:05:48.901Z","comments":true,"path":"2024/06/04/17/","link":"","permalink":"/2024/06/04/17/","excerpt":"","text":"æ ‘çš„é‡å¿ƒ æ‰¾åˆ°ä¸€ä¸ªç‚¹,å…¶æ‰€æœ‰çš„å­æ ‘ä¸­æœ€å¤§çš„å­æ ‘èŠ‚ç‚¹æ•°æœ€å°‘,é‚£ä¹ˆè¿™ä¸ªç‚¹å°±æ˜¯è¿™æ£µæ ‘çš„é‡å¿ƒ void getroot(int x, int fa) { son[x] = 1; int mx = 0; for (auto &amp;to : g[x]) { if (to == fa || vis[to]) continue; getroot(to, x); son[x] += son[to]; mx = max(mx, son[to]); } mx = max(mx, num - son[x]); if (mx &lt; MX) { MX = mx; root = x; } } æ ‘çš„ç›´å¾„ ï¼ˆdfsï¼‰ å…ˆä»å›¾ä¸Šä»»æ„ä¸€ç‚¹ï¼Œæœç´¢æ•´æ£µæ ‘ï¼Œæ‰¾åˆ°è·ç¦»è¯¥ç‚¹æœ€è¿œçš„ç‚¹ï¼Œå†ç”¨è·ç¦»è¯¥ç‚¹æœ€è¿œçš„ç‚¹æœç´¢ä¸€æ¬¡ï¼Œå³å¯å¾—åˆ°æ ‘çš„ç›´å¾„ã€‚ void dfs(int x, int fa) { for (int &amp;to : g[x]) { if (to != fa) { dis[to] = dis[x] + 1; dfs(to, x); } } } int diameter() { for (int i = 1; i &lt;= n; i++) dis[i] = 0; dfs(1, -1); int mx = 0, st = 1; for (int i = 1; i &lt;= n; i++) if (dis[i] &gt; mx) mx = dis[i], st = i; for (int i = 1; i &lt;= n; i++) dis[i] = 0; dfs(st, -1); mx = 0; for (int i = 1; i &lt;= n; i++) mx = max(dis[i], mx); return mx; } æœ€å°ç”Ÿæˆæ ‘ï¼ˆMSTï¼‰ Kruskal ç¨€ç–å›¾ï¼ˆè¾¹æ•°å°‘æ›´æœ‰æ•ˆç‡ï¼‰ // nä¸ºç‚¹æ•°mä¸ºè¾¹æ•° struct DSU { // å¹¶æŸ¥é›†æ¨¡æ¿ int n; vector&lt;int&gt; dsu_fa; DSU(int _n) : n(_n) { for (int i = 0; i &lt;= n; i++) { dsu_fa.push_back(i); } } int find(int x) { if (x != dsu_fa[x]) dsu_fa[x] = find(dsu_fa[x]); return dsu_fa[x]; } bool merge(int x, int y) { x = find(x), y = find(y); dsu_fa[x] = y; return (x != y); } bool same(int x, int y) { return find(x) == find(y); } }; vector&lt;pair&lt;int,pair&lt;int,int&gt;&gt;&gt; e(m) // å­˜è¾¹(w,(u,v)) int kruskal() { DSU dsu(n); sort(e.begin(), e.end()); int res = 0, cnt = 0; for (const auto &amp;pi: e) { int u = pi.second.first, v = pi.second.second, w = pi.first; if (dsu.merge(u, v)) res += w, cnt++; if (cnt == n - 1) break; } return res; } Prim ç¨ å¯†å›¾ï¼ˆè¾¹æ•°å¤šæ›´æœ‰æ•ˆç‡ï¼‰ int n, m, e[N][N]; ll mst[N], lowcost[N];//lowcost[i]ï¼šç»ˆç‚¹ä¸ºiçš„æœ€å°èŠ±è´¹ï¼Œè‹¥lowcast[i] = 0ï¼Œåˆ™è¡¨ç¤ºiç‚¹å·²åœ¨å½“å‰æ‰€å»ºçš„å›¾ä¸­ï¼›mst[i]ï¼šç»ˆç‚¹ä¸ºiçš„æœ€å°èŠ±è´¹æ‰€å¯¹åº”çš„èµ·ç‚¹ int prim() { ll sum = 0; for(int i = 2; i &lt;= n; i++) { lowcost[i] = e[1][i]; // mst[i] = 1; } //mst[1] = 0; for(int i = 2; i &lt;= n; i++) { int minid = -1; ll mi = inf; for(int j = 2; j &lt;= n; j++) { if(lowcost[j] &amp;&amp; lowcost[j] &lt; mi) { minid = j; mi = lowcost[j]; } } if(minid == -1) return inf;//å›¾ä¸è”é€šè¿”å›inf sum += lowcost[minid]; lowcost[minid] = 0; for(int j = 2; j &lt;= n; j++) { if(e[minid][j] &lt; lowcost[j]) { lowcost[j] = e[minid][j]; // mst[j] = minid; } } } return sum; } è™šæ ‘ inline bool cmp(const int &amp;a, const int &amp;b){ return dfn[a] &lt; dfn[b]; } void build()//äºŒæ¬¡æ’åº { sort(all(v), cmp); for(auto &amp;it : v) t.push_back(it); for(int i = 1; i &lt; v.size(); i++) t.push_back(LCA(v[i - 1], v[i]));//lca å’Œå…³é”®ç‚¹æ”¾å…¥ï¼ŒæŒ‰dfnæ’åº sort(all(t), cmp); t.erase(unique(all(t)), t.end()); for(int i = 1; i &lt; t.size(); i++)//lca å’Œ y å»ºè¾¹ { int lca = LCA(t[i - 1], t[i]); int val = dis(lca, t[i]); G[lca].push_back({t[i], val}); G[t[i]].push_back({lca, val}); } }","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"è®¡æ•°","slug":"18","date":"2024-06-04T07:54:39.775Z","updated":"2024-06-04T09:08:18.257Z","comments":true,"path":"2024/06/04/18/","link":"","permalink":"/2024/06/04/18/","excerpt":"","text":"ç»„åˆæ•°æ€§è´¨ 1. â€‹ $C_n^0 + C_n^1 + C_n^2 Â·Â·Â· + C_n^{n-1} + C_n^n = 2^n$ 2. â€‹ $C_n^0 + C_n^2 + C_n^4 Â·Â·Â· = C_n^1 + C_n^3 + C_n^5 Â·Â·Â· = 2 ^{n-1}$ 3. â€‹ $0 * C_n^0 + 1 * C_n^1 + 2 * C_n^2 + Â·Â·Â· + n * C_n^n = n * 2^{n-1}$ 4. â€‹ $C_n^m = \\frac{n}{m} * C_{n-1}^{m-1}$ â€‹ $C_n^{m+1} = \\frac{n-m}{m+1}C_n^m$ 5. â€‹ $({C_n^0})^2 + ({C_n^1})^2 + Â·Â·Â· + ({C_n^n})^2 = C_{2n}^n$ 6. â€‹ $\\sum_{i=0}^n C_i^k = C_{n+1}^{k+1}$ 7. â€‹ $C_n^m$ä¸ºå¥‡æ•°æ—¶æœ‰ $n$ &amp; $m = m$ â€‹ æ¨¡æ•°ä¸º2æ—¶ä¹Ÿæ»¡è¶³$n$ &amp; $m = m $(æ ¹æ®å¢å¡æ–¯å®šç†)ï¼Œå¯å°†é—®é¢˜è½¬åŒ–æˆäºŒè¿›åˆ¶ä¸‹çš„é—®é¢˜ï¼Œç„¶åè€ƒè™‘æ•°ä½dp 8. â€‹ $C_n^k * C_k^r = C_n^r * C_{n-r}^{k-r}(k \\geq r)$ 9. $C_{n+r+1}^{r} = C_{n}^{0}+C_{n+1}^{1}+Â·Â·Â·+C_{n+r-1}^{r-1}+C_{n+r}^{r}$ $C_{n+r+1}^{n+1} = C_{n}^{n}+C_{n+1}^{n}+Â·Â·Â·+C_{n+r}^{n}$ 10. $\\sum_{i=0}^{i=s}C_s^i*i = s2^{s-1}$ 11. $\\sum_{i=0}^{min(x,y)}C_x^iC_y^i = C_{x+y}^x$ 12. $\\sum_{i=0}^{k}C_{n}^{i}C_m^{k-i}=C_{n+m}^{k}$ äºŒé¡¹å¼å®šç† â€‹ 1.ä¸€èˆ¬äºŒé¡¹å¼å®šç†($n$ä¸ºéè´Ÿæ•´æ•°) â€‹ $(a + b) ^ n = \\sum_{k=0}^{n} C_n^k a ^ kb^{n-k}$ äºŒé¡¹å¼åæ¼” äºŒé¡¹å¼åæ¼”ä¸ºä¸€ç§åæ¼”å½¢å¼ï¼Œå¸¸ç”¨äºé€šè¿‡ â€œæŒ‡å®šæŸè‹¥å¹²ä¸ªâ€ æ±‚ â€œæ°å¥½è‹¥å¹²ä¸ªâ€ çš„é—®é¢˜ã€‚ è€ƒè™‘è§£å†³è‡³å°‘ã€è‡³å¤šçš„é—®é¢˜ï¼Œè¿™ä¸ªé—®é¢˜è§£å†³å°±æ˜¯ $f(n)$ çš„å€¼ã€‚ä¸€èˆ¬æ˜¯ä¼šæ¯”è¾ƒå¥½æ±‚çš„ï¼Œç”¨ç‚¹æ•°å­¦æ–¹æ³•æˆ–è€…DPå°±å¯ä»¥è§£å†³ã€‚ç„¶åï¼Œç”¨äºŒé¡¹å¼åæ¼”ï¼Œæ±‚å‡º $g(n)$ã€‚è¿™å°±æ˜¯æ°å¥½çš„æ–¹æ¡ˆæ•° å½¢å¼é›¶ $f(n)=\\sum_{i=0}^{n}(-1)^iC_n^ig(i) \\Longleftrightarrow g(n)=\\sum_{i=0}^{n}(-1)^iC_n^if(i)$ å½¢å¼ä¸€ $f(n)=\\sum_{i=m}^{n}C_n^ig(i) \\Longleftrightarrow g(n)=\\sum_{i=m}^{n}(-1)^{n-i}C_n^if(i)$ å½¢å¼äºŒ $f(n)=\\sum_{i=n}^{m}C_i^ng(i) \\Longleftrightarrow g(n)=\\sum_{i=n}^{m}(-1)^{i-n}C_i^nf(i)$ ç»„åˆæ„ä¹‰ : è®° $f(n)$ è¡¨ç¤º â€œé’¦å®šé€‰ $n$ ä¸ªâ€ï¼Œ$g(n)$ è¡¨ç¤º â€œæ°å¥½é€‰ $n$ ä¸ªâ€ï¼Œåˆ™å¯¹äºä»»æ„çš„ $iâ‰¥n$ ï¼Œ$g(i)$ åœ¨ $f(n)$ ä¸­è¢«è®¡ç®—äº† $C_i^n$ æ¬¡ï¼Œæ•… $f(n)=\\sum_{i=n}^{m}C_i^n g(i)$ ï¼Œå…¶ä¸­ $m$ æ˜¯æ•°ç›®ä¸Šç•Œã€‚ å¤šé‡é›†åˆçš„æ’åˆ—æ•° æœ‰$n$ç§ç‰©å“ï¼Œæ¯ç§ç‰©å“æœ‰$c_i$ä¸ªï¼Œå°†ç‰©å“å…¨æ’åˆ—çš„æ–¹æ¡ˆæ•°ä¸º $\\frac{\\sum_{i=1}^{n} c_i}{\\prod_{i=1}^{n} c_i}$ å¤šé‡é›†çš„ç»„åˆæ•° æœ‰$n$ç§ç‰©å“ï¼Œæ¯ç§ç‰©å“æœ‰$c_i$ä¸ªï¼Œä»ä¸­é€‰å‡º $m \\ (m \\leq c_i)$ ä¸ªç‰©å“çš„æ–¹æ¡ˆæ•°ä¸º $C_{m + n - 1}^{n - 1}$ è‹¥æ²¡æœ‰å¯¹äº $m$ çš„é™åˆ¶ å¤šé¡¹å¼ $dp_{i+1,j}=dp_{i+1,j-1}+dp_{i,j}-dp_{i,j-1-c_i}$ $dp_{ij} : $å‰ $i$ ç§ç‰©å“æ‹¿äº† $j$ ä¸ªçš„æ–¹æ¡ˆæ•° åœ¨è®¡æ•°DPä¸­ï¼Œä¸ºäº†é¿å…é‡å¤è®¡ç®—ï¼ŒåŒä¸€ç±»ç‰©å“å¾€å¾€è¦ä¸€èµ·å¤„ç† é”™æ’ $f(n) = (n - 1)(f(n - 1) + f(n - 2))$ â€‹ $= nf(n-1) +(-1)^n$ éšç€å…ƒç´ çš„å¢åŠ ï¼Œä¸€ä¸ªéšæœºæ’åˆ—æ˜¯é”™æ’çš„æ¦‚ç‡æ¥è¿‘$\\frac{1}{e}$ åœ†æ’åˆ— ä» $n$ ä¸ªä¸åŒå…ƒç´ ä¸­é€‰å– $r$ ä¸ªå…ƒç´ ï¼Œä¸åˆ†é¦–å°¾åœ°å›´æˆä¸€ä¸ªåœ†åœˆçš„æ’åˆ—å«åšåœ†æ’åˆ—ï¼Œå…¶æ’åˆ—æ–¹æ¡ˆæ•°ä¸º $\\frac{A_n^r}{r}$ å¯é‡å¤ç»„åˆæ•° å¤šé‡é›†çš„æ’åˆ—æ•°$(r &lt; n_i)$ $H_n^r = C_{n+r-1}^r$ åˆ†è£…é—®é¢˜ å°† $n$ ä¸ªçƒæ”¾å…¥ $r$ ä¸ªç›’å­ç§°ä¸ºåˆ†è£…é—®é¢˜ $n$ ä¸ªçƒå®Œå…¨ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ä¸ç›¸åŒï¼Œå…è®¸ç©ºç›’ ï¼š $C_{n+r-1}^{r-1}$ $n$ ä¸ªçƒå®Œå…¨ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ä¸ç›¸åŒï¼Œä¸å…è®¸ç©ºç›’ ï¼š$C_{n-1}^{r-1}$ $n$ ä¸ªçƒå®Œå…¨ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ç›¸åŒï¼Œå…è®¸ç©ºç›’ ï¼š$\\sum _{k=1}^{r}P(n,k)$ï¼Œåˆ†æ‹†æ•° $n$ ä¸ªçƒå®Œå…¨ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ç›¸åŒï¼Œä¸å…è®¸ç©ºç›’($n \\geq r $) ï¼š$P(n,r)$ï¼Œåˆ†æ‹†æ•° $n$ ä¸ªçƒå®Œå…¨ä¸ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ä¸ç›¸åŒï¼Œå…è®¸ç©ºç›’ ï¼š$r^n$ $n$ ä¸ªçƒå®Œå…¨ä¸ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ä¸ç›¸åŒï¼Œä¸å…è®¸ç©ºç›’ : $r!S(n,r)$ï¼Œç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° $n$ ä¸ªçƒå®Œå…¨ä¸ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ç›¸åŒï¼Œå…è®¸ç©ºç›’ ï¼š$\\sum _{k=1}^{r}S(n,k)$ï¼Œç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° $n$ ä¸ªçƒå®Œå…¨ä¸ç›¸åŒï¼Œ$r$ ä¸ªç›’å­å®Œå…¨ç›¸åŒï¼Œä¸å…è®¸ç©ºç›’: $S(n,r)$ï¼Œç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° Lucas å®šç† â€‹ è‹¥$p$æ˜¯è´¨æ•°ï¼Œåˆ™å¯¹äºä»»æ„æ•´æ•° $1 \\leq m \\leq n$, æœ‰ï¼š $C_n^m \\equiv C_{n \\ mod \\ p}^{m \\ mod \\ p} * C_{n/p}^{m/p}(mod \\ p)$ â€‹ ä¹Ÿå°±æ˜¯æŠŠ $n$ å’Œ $m$ è¡¨ç¤ºæˆ $p$ è¿›åˆ¶æ•°ï¼Œ å¯¹ $p$ è¿›åˆ¶ä¸‹çš„æ¯ä¸€ä½åˆ†åˆ«è®¡ç®—ç»„åˆæ•°ï¼Œæœ€åå†ä¹˜èµ·æ¥ ll C(ll n, ll m) { if (m &lt; 0 || m &gt; n) return 0; if (m == 0) return 1; if (m &lt; p &amp;&amp; n &lt; p) return fac[n] * invfac[m] % p * invfac[n - m] % p; return C(n / p, m / p) * C(n % p, m % p) % p; } è‹¥$(_a^{a+b}) \\neq 0$ï¼Œåˆ™è¯´æ˜$a + b$åœ¨$p$è¿›åˆ¶é‡ŒåŠ æ³•ä¸è¿›ä½ æ–æ³¢é‚£å¥‘æ•°åˆ— æ€§è´¨ $\\sum_{i=1}^nf_i = f_{n+2}-1$ $\\sum_{i=1}^nf_{2i-1} = f_{2n}$ $\\sum_{i=1}^nf_{2i} = f_{2n+1} - 1$ $\\sum_{i=1}^n(f_i)^2 = f_nf_{n+1}$ $f_{n+m} = f_{n-1}f_{m-1} + f_nf_m$ $(f_n)^2 = (-1)^{n-1} + f_{n-1}f_{n+1}$ $f_{2n-1} = (f_n)^2 - (f_{n-2})^2$ $f_n = \\frac{f_{n+2} + f_{n-2}}{3}$ $\\frac{f_i}{f_{i-1}} \\thickapprox \\frac{\\sqrt{5} - 1}{5} \\thickapprox 0.618$ $f_n = \\frac{(\\frac{1+\\sqrt{5}}{2})^n - (\\frac{1-\\sqrt{5}}{2})^n}{\\sqrt{5}}$ Catalanæ•°åˆ— $Cat_n = Cat_0 * Cat_{n-1} + Cat_1 * Cat_{n-2} + Â·Â·Â· + Cat_{n-1}*Cat_0(n \\geq 2)$ $ = Cat_{n-1} * \\frac{4n-2}{n+1}$ $= C_{2n}^{n} - C_{2n}^{n-1}$ $ = \\frac{C_{2n}^{n}}{n+1}$ Cat = {1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670} â€‹ åº”ç”¨ï¼š 1.nä¸ªå·¦æ‹¬å·å’Œnä¸ªå³æ‹¬å·ç»„æˆçš„åˆæ³•æ‹¬å·åºåˆ—çš„æ•°é‡ä¸º $Cat_n$ 2.$1,2,Â·Â·Â·,n$ ç»è¿‡ä¸€ä¸ªæ ˆï¼Œ å½¢æˆçš„åˆæ³•å‡ºæ ˆåºåˆ—çš„æ•°é‡ä¸º $Cat_n$ 3.n ä¸ªèŠ‚ç‚¹æ„æˆçš„ä¸åŒäºŒå‰æ ‘çš„æ•°é‡ä¸º $Cat_n$ 4.åœ¨å¹³é¢ç›´è§’åæ ‡ç³»ä¸Šï¼Œ æ¯ä¸€æ­¥åªèƒ½å‘ä¸Šæˆ–å‘å³èµ°ï¼Œ ä»$(0,0)$èµ°åˆ°$(n,n)$å¹¶ä¸”é™¤ä¸¤ä¸ªç«¯ç‚¹å¤–ä¸æ¥è§¦ç›´çº¿$y = x$çš„è·¯çº¿æ•°é‡ä¸º $2Cat_{n-1}$ 5.åœ¨å¹³é¢ç›´è§’åæ ‡ç³»ä¸Šï¼Œ æ¯ä¸€æ­¥åªèƒ½å‘ä¸Šæˆ–å‘å³èµ°ï¼Œ ä»$(0,0)$èµ°åˆ°$(n,n)$ï¼Œåœ¨ä»»ä¸€æ—¶åˆ»ï¼Œå‘å³èµ°çš„æ¬¡æ•°ä¸èƒ½å°‘äºå‘ä¸Šèµ°çš„æ¬¡æ•°ï¼Œæ–¹æ¡ˆæ•°ä¸º $Cat_{n}$ 6.åœ¨åœ†ä¸Šé€‰æ‹©$2n$ä¸ªç‚¹ï¼Œå°†è¿™äº›ç‚¹æˆå¯¹è¿æ¥èµ·æ¥ä½¿å¾—æ‰€å¾—åˆ°çš„$n$æ¡çº¿æ®µä¸ç›¸äº¤çš„æ–¹æ³•æ•°ä¸º $Cat_n$ 7.ä¸€ä¸ªæœ‰$n$ä¸ªå®šç‚¹çš„å‡¸å¤šè¾¹å½¢åŒºåŸŸåˆ’åˆ†æˆä¸‰è§’å½¢åŒºåŸŸçš„æ–¹æ³•æ•°ä¸º$Cat_{n-2}$ æ–¯ç‰¹æ—æ•°(Stirling) ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•° $s(n,m)$ï¼Œä¹Ÿè®°ä¸º $[_m^n]$ã€‚è¡¨ç¤ºå°† $n$ ä¸ªä¸åŒå…ƒç´ æ„æˆ $m$ ä¸ªåœ†æ’åˆ—çš„æ–¹æ¡ˆæ•°ã€‚åŒæ—¶è¿˜åˆ†ä¸ºæ— ç¬¦å·ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•° $s_u(n,m)$ å’Œæœ‰ç¬¦å·ç¬¬ä¸€ç±»ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•° $s_s(n,m)$ã€‚ ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° $S(n,m)$ï¼Œä¹Ÿè®°ä¸º ${_m^n}$ã€‚è¡¨ç¤ºå°† $n$ ä¸ªä¸åŒçš„å…ƒç´ åˆ’åˆ†æˆ $m$ ä¸ªé›†åˆçš„æ–¹æ¡ˆæ•°ã€‚ ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•° â€‹ ${m^n} = {{m-1}^{n-1}} + m{_{\\ \\ m}^{n-1}}$ â€‹ ${m^n} = \\sum{i=0}^{m}\\frac{(-1)^{m-i}i^n}{i!(m-i)!}$ ç¬¬ä¸€ç±»æ–¯ç‰¹æ—æ•° â€‹ $[m^n] = [{m-1}^{n-1}] + (n-1)[_{\\ \\ m}^{n-1}]$ ä¸Šå‡å¹‚ â€‹ $x^{\\bar{n}} = \\prod_{k=0}^{n-1}(x+k) = x(x+1)(x+2)\\dots(x+n-1)$ â€‹ 1).ä¸Šå‡å¹‚è½¬æ™®é€šå¹‚ â€‹ $x^{\\bar{n}} = \\sum_{k=0}^n[_k^n]x^k$ â€‹ 2).æ™®é€šå¹‚è½¬ä¸Šå‡å¹‚ â€‹ $x^n = \\sum_{k=0}^n(-1)^{n-k}x^{\\bar{k}}$ ä¸‹é™å¹‚ â€‹ $x^{\\underline{n}} = \\frac{x!}{(x-n)!} = \\prod_{k=0}^{n-1}(x-k)$ â€‹ 1).ä¸‹é™å¹‚è½¬æ™®é€šå¹‚ â€‹ $x^{\\underline{n}} = \\sum_{k=0}^n_k^n^{n-k}x^k$ â€‹ 2).æ™®é€šå¹‚è½¬ä¸‹é™å¹‚ â€‹ $x^n = \\sum_{k=0}^{n}{_k^n}x^{\\underline{k}}$ è´å°”æ•° $B_n$ è¡¨ç¤ºå°† $n$ ä¸ªé›†åˆåˆ’åˆ†æˆè‹¥å¹²ä¸ªéç©ºé›†åˆçš„æ–¹æ¡ˆæ•°ã€‚ $B_n = \\sum_{i=0}^{n-1}C_{n-1}^{i}B_i$ $B_n = \\frac{1}{e}\\sum_{i \\geq0}\\frac{i^n}{i!}$ $B_n = \\sum_{i=0}^nS(n,i)$ $B_n$ ç­‰äºç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ç¬¬ $n$ è¡Œä¹‹å’Œ å¯¹äºè´¨æ•°$p$ ï¼Œ$B_{p^m+n} = mB_n + B_{n+1}$ Bellæ•°åˆ—æ¨¡è´¨æ•° $p$ æ„ä¹‰ä¸‹çš„å¾ªç¯èŠ‚é•¿åº¦ä¸º $\\frac{p^p-1}{p-1}$ B = {1, 1, 2, 5, 15, 52, 203} è´å°”ä¸‰è§’ ç”¨ä»¥ä¸‹æ–¹æ³•æ„é€ ä¸€ä¸ªä¸‰è§’çŸ©é˜µï¼ˆå½¢å¼ç±»ä¼¼æ¨è¾‰ä¸‰è§’å½¢ï¼‰ ç¬¬ä¸€è¡Œç¬¬ä¸€é¡¹ä¸º 1 $(a_{1,1} = 1)$ å¯¹äº $n &gt; 1$ï¼Œç¬¬ $n$ è¡Œç¬¬ä¸€é¡¹ç­‰äºç¬¬ $n - 1$ è¡Œçš„ç¬¬ $n - 1$ é¡¹ $(a_{n,1} = a_{n-1,n-1})$ å¯¹äº $m, n &gt; 1$ï¼Œç¬¬ $n$ è¡Œçš„ç¬¬ $m$ é¡¹ç­‰äºå®ƒå·¦è¾¹å’Œåä¸Šè§’ä¸¤æ•°ä¹‹å’Œ $(a_{n,m} = a_{n,m-1} + a_{n-1,m-1})$ 1 1 2 2 3 5 5 7 10 15 15 20 27 37 52 52 67 87 114 151 203 æ¯è¡Œçš„é¦–é¡¹æ˜¯è´å°”æ•°ã€‚å¯ä»¥åˆ©ç”¨è¿™ä¸ªä¸‰è§’å½¢é€’æ¨æ±‚å‡ºBellæ•° åˆ†æ‹†æ•° $p_n$ : è‡ªç„¶æ•° $n$ çš„åˆ†æ‹†ä¸ºå¤šä¸ªæ­£æ•´æ•°çš„å’Œçš„æ–¹æ¡ˆæ•°ï¼Œ ç‰¹æ®Šçš„ $p_0 = 1$ è¯¥é€’æ¨å…¬å¼æ—¶é—´å¤æ‚åº¦ä¸º$O(n\\sqrt{n})$ ä¹Ÿå¯ä»¥ç”¨å®Œå…¨èƒŒåŒ… $O(n^2)$æ±‚è§£ $ p_n$ $k$ éƒ¨åˆ†æ‹†æ•°,$p(n,k)$: è‡ªç„¶æ•° $n$ åˆ†æ‹†ä¸º $k$ ä¸ªæ­£æ•´æ•°çš„å’Œçš„æ–¹æ¡ˆæ•° $p(n,k)=\\sum_{j=0}^{k}p(n-k,j)$ $p(n,k) = p(n-1,k-1) + p(n-k,k)$ ç”¨è¯¥é€’æ¨å¼æ—¶é—´å¤æ‚åº¦ä¸º $O(nk)$ æœ€å¤§ $k$ åˆ†æ‹†æ•° ï¼šè‡ªç„¶æ•° $n$ åˆ†æ‹†åæœ€å¤§çš„æ­£æ•´æ•°ä¸º $k$ çš„æ–¹æ¡ˆæ•° æ ¹æ® Ferrers å›¾ä¸å…±è½­å¯çŸ¥ï¼Œ $n$ çš„æœ€å¤§ $k$ æ‹†åˆ†æ•°ç­‰äº $k$ éƒ¨åˆ†æ‹†æ•°ï¼Œéƒ½ä¸º $p(n,k)$ äº’å¼‚æ‹†åˆ†æ•°($pd_n$) ï¼šè‡ªç„¶æ•° $n$ æ‹†åˆ†åå„éƒ¨åˆ†ä¸ç›¸åŒçš„æ‹†åˆ†æ•° äº’å¼‚$k$éƒ¨åˆ†æ‹†æ•°,$pd(n,k)$ : è‡ªç„¶æ•° $n$ æ‹†åˆ†ä¸º $k$ ä¸ªéƒ¨åˆ†ï¼Œä¸”å„éƒ¨åˆ†ä¸åŒçš„æ–¹æ¡ˆæ•° $pd(n,k)=pd(n-k,k-1)+pd(n-k,k)$ cayleyå®šç† (å‡¯è±å®šç†): â€‹ æœ‰nä¸ªæ ‡å¿—èŠ‚ç‚¹çš„æ ‘çš„æ•°é‡ç­‰äº$n^{n-2}$ ç”Ÿæˆå‡½æ•° æ³°å‹’å±•å¼€å¼ $\\frac{1}{1-x}=1+x^2+x^3+x^4 + \\dots$ $\\frac{1}{(1-x)^2}=1+2x+3x^2+ \\dots$ $e^x = 1+\\frac{x}{1!}+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\dots$ $e^{-x} = 1-\\frac{x}{1!}+\\frac{x^2}{2!}-\\frac{x^3}{3!}+\\dots$ $e^{px}=1+p\\frac{x}{1!}+p^2\\frac{x^2}{2!}+p^3\\frac{x^3}{3!}+\\dots$ $\\frac{e^x+e^{-x}}{2}=1+\\frac{x^2}{2!}+\\frac{x^4}{4!}+\\dots$ $\\frac{e^x-e^{-x}}{2}=\\frac{x}{1!}+\\frac{x^3}{3!}+\\frac{x^5}{5!}+\\dots$ 1.æ™®é€šå‹æ¯å‡½æ•°(OGF) æ™®é€šå‹æ¯å‡½æ•°çš„ä¹˜æ³•å’Œâ€œå¤šé‡é›†çš„ç»„åˆé—®é¢˜â€æœ‰å…³ â€‹ æŠŠä¸€ä¸ªæ•°åˆ—çš„æ™®é€šå‹æ¯å‡½æ•°ä¹˜ä»¥ $1+x+x^2+x^3+ \\dots$ ç›¸å½“äºæ±‚å…¶å‰ç¼€å’Œ â€‹ æŠŠä¸€ä¸ªæ•°åˆ—çš„æ™®é€šå‹æ¯å‡½æ•°ä¹˜ä»¥ $1-x$ ç›¸å½“äºæ±‚å…¶å·®åˆ† 2.æŒ‡æ•°å‹æ¯å‡½æ•°(EGF) æŒ‡æ•°å‹æ¯å‡½æ•°çš„ä¹˜æ³•å’Œâ€œå¤šé‡é›†çš„æ’åˆ—é—®é¢˜â€æœ‰å…³ã€‚","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"å¸¸è§åºåˆ—","slug":"12","date":"2024-06-04T07:54:37.002Z","updated":"2024-06-04T08:06:03.303Z","comments":true,"path":"2024/06/04/12/","link":"","permalink":"/2024/06/04/12/","excerpt":"","text":"å¸¸è§åºåˆ— f = {1, 1, 1, 3, 16, 125, 1296, 16807, 262144, 4782969, 100000000} f[i] = i ^ (i - 2)//å‰å‡ é¡¹ç‰¹åˆ¤ f = {1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670} //å¡ç‰¹å…°æ•°åˆ— f = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55}//æ–æ³¢é‚£å¥‘æ•°åˆ— B = {1, 1, 2, 5, 15, 52, 203}//è´å°”æ•°","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"STL","slug":"9","date":"2024-06-04T07:54:33.754Z","updated":"2024-06-04T08:06:10.722Z","comments":true,"path":"2024/06/04/9/","link":"","permalink":"/2024/06/04/9/","excerpt":"","text":"ios::sync_with_stdio(false);//åŒæ­¥æµ cin.tie(0); vector v.insert(v.begin()+2, 1); // æŒ‡å®šä½ç½®ï¼Œæ’å…¥å…ƒç´ ï¼ŒO(n) vector&lt;ll&gt;::iterator it = find(v.begin(),v.end(),num); //è¿”å›çš„æ˜¯ä¸€ä¸ªè¿­ä»£å™¨æŒ‡é’ˆ,è‹¥æœªæ‰¾åˆ°è¿”å›v.end(); rotate(v.begin(), it, v.end()); ////rotate : å°†v.begin() ä¸ v.end()ä¹‹é—´çš„å…ƒç´ ä»it(itä¸ºå­˜åœ¨ä¸begin å’Œ end é—´çš„ä¸€ä¸ªè¿­ä»£å™¨)ä½ç½®è¿›è¡Œå·¦æ—‹è½¬, itæ‰€æŒ‡å…ƒç´ ä¸ºæ—‹è½¬åçš„é¦–å…ƒç´  ////rotate(v.begin(), v.begin() + 3, v.end()); //// 1 2 3 4 5 6 //// 4 5 6 1 2 3 string string aa = &quot;12345&quot;; s.append(aa, 0, 2); // å°†å­—ç¬¦ä¸²aaç¬¬0ä½å¼€å§‹çš„2ä¸ªå­—ç¬¦ä¸²è¿½åŠ åˆ°æ˜¯så°¾éƒ¨ aa = s.substr(0, 2); // å°†å­—ç¬¦ä¸²sä»ç¬¬0ä½å¼€å§‹çš„2ä¸ªå­—ç¬¦ä¸²èµ‹å€¼ç»™aa s.length() s.size() s = cin.get(); // è¯»å…¥ä¸€ä¸ªå­—ç¬¦ getline(cin, s); // è¯»å…¥ä¸€è¡Œ vector&lt;string&gt; vs; // stringç­‰éƒ½å¯ä»¥æ”¾å…¥ s.find(&quot;a&quot;) // åœ¨sä¸­æ‰¾&quot;a&quot;ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½® s.find(&quot;a&quot;, 1) // ä»ä¸‹æ ‡1å¼€å§‹åœ¨sä¸­&quot;a&quot;ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½® s.find(&quot;a&quot;) == s.npos // æ‰¾ä¸åˆ°è¿”å›npos ï¼ˆ1ï¼‰s.erase(pos,n);//åˆ é™¤ä»poså¼€å§‹çš„nä¸ªå­—ç¬¦ï¼Œæ¯”å¦‚erase(0,1)å°±æ˜¯åˆ é™¤ç¬¬ä¸€ä¸ªå­—ç¬¦ ï¼ˆ2ï¼‰s.erase(position);//åˆ é™¤positionå¤„çš„ä¸€ä¸ªå­—ç¬¦(positionæ˜¯ä¸ªstringç±»å‹çš„è¿­ä»£å™¨) ï¼ˆ3ï¼‰s.erase(first,last);//åˆ é™¤ä»firståˆ°lastä¹‹é—´çš„å­—ç¬¦ï¼ˆfirstå’Œlastéƒ½æ˜¯è¿­ä»£å™¨ï¼‰ set $O(\\log{size})$ #include &lt;set&gt; // é›†åˆ è‡ªåŠ¨å»é‡ è‡ªåŠ¨æ’åº å†…éƒ¨ä½¿ç”¨çº¢é»‘æ ‘å®ç° æ’å…¥ã€æŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯logçº§åˆ«çš„ {2, 1, 1} -&gt; {1, 2} set&lt;int&gt; s; multiset&lt;int&gt; ms; // ä¸å»é‡ï¼ˆæ³¨æ„åˆ é™¤æ“ä½œï¼‰ {1, 1, 2} erase(1) -&gt; {2} erase(iterator) s.insert(2); // æ’å…¥å…ƒç´ O(1) s.erase(2); // åˆ é™¤å…ƒç´  set&lt;int&gt;::iterator it; for (it = s.begin(); it != s.end(); ++it) {} set&lt;int&gt;::reverse_iterator rit; rit = prev(rit)//ä¸Šä¸€ä¸ª for (rit = s.rbegin(); rit != s.rend(); ++rit) {} for (auto v : s) s.lower_bound(2); s.upper_bound(2); // æ‰¾ä¸åˆ°ä¼šè¿”å›s.end() s.find(2) == s.end() s.count(2) clear(); set&lt;pair&lt;ll, ll&gt;&gt; s; ll a = s.lower_bound(make_pair(a, b));//å…ˆæ‰¾a,å†æ‰¾b setçš„lower_bound æ¯” std::lower_boundæ•ˆç‡é«˜å¾ˆå¤š bitset bitset&lt;4&gt;s1(string(&quot;1001&quot;)); bitset&lt;4&gt;s2(string(&quot;0011&quot;)); cout&lt;&lt;s1.count()&lt;&lt;endl;//ç”¨äºè®¡ç®—s1ä¸­1çš„ä¸ªæ•° cout&lt;&lt;s1.size()&lt;&lt;endl;//s1çš„ä½æ•° cout&lt;&lt;s1.test(0)&lt;&lt;endl;//ç”¨äºæ£€æŸ¥s1[0]æ˜¯0 or 1å¹¶è¿”å›0 or 1 cout&lt;&lt;s1.any()&lt;&lt;endl;//æ£€æŸ¥s1ä¸­æ˜¯å¦æœ‰1ï¼Œå¹¶è¿”å›1or0 cout&lt;&lt;s1.all()&lt;&lt;endl;//æ£€æŸ¥s1ä¸­æ˜¯å¦å…¨éƒ¨ä¸º1ï¼Œå¹¶è¿”å›0or1 cout&lt;&lt;s1.none()&lt;&lt;endl;//æ£€æŸ¥s1ä¸­æ˜¯å¦å…¨ä¸ä¸º1ï¼Œå¹¶è¿”å›0or1 cout&lt;&lt;s1.flip(2)&lt;&lt;endl;//å°†å‚æ•°ä½å–åï¼Œ0å˜1ï¼Œ1å˜0 cout&lt;&lt;s1.flip()&lt;&lt;endl;//ä¸æŒ‡å®šå‚æ•°æ—¶ï¼Œæ¯ä¸€ä½å–å cout&lt;&lt;s1.set()&lt;&lt;endl;//ä¸æŒ‡å®šå‚æ•°æ—¶ï¼Œæ¯ä¸€ä½å˜ä¸ºï¼‘ cout&lt;&lt;s1.set(3,1)&lt;&lt;endl;//æŒ‡å®šä¸¤ä½å‚æ•°æ—¶ï¼Œå°†ç¬¬ä¸€å‚æ•°ä½çš„å…ƒç´ å˜ä¸ºç¬¬äºŒå‚æ•°çš„å€¼ï¼Œç¬¬äºŒå‚æ•°ä½åªèƒ½ä¸º0or1 cout&lt;&lt;s1.set(3)&lt;&lt;endl;//åªæœ‰ä¸€ä¸ªå‚æ•°æ—¶ï¼Œå°†å‚æ•°ä¸‹æ ‡å¤„å˜ä¸ºï¼‘ cout&lt;&lt;s1.reset(4)&lt;&lt;endl;//ä¸€ä¸ªå‚æ•°æ—¶å°†å‚æ•°ä¸‹æ ‡å¤„å˜ä¸ºï¼ cout&lt;&lt;s1.reset()&lt;&lt;endl;//ä¸ä¼ å‚æ•°æ—¶å°†bitsetçš„æ¯ä¸€ä½å˜ä¸ºï¼ string s = s1.to_string(); //å°†bitsetè½¬æ¢æˆstring unsigned long a = s1.to_ulong(); //å°†bitsetè½¬æ¢æˆunsigned long unsigned long long b = s1.to_ullong(); //å°†bitsetè½¬æ¢æˆunsigned long long cout&lt;&lt;s&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; merge merge(first1, last1, first2, last2, now, cmp)//å°†ä¸¤ä¸ª æœ‰åº çš„åºåˆ—åˆå¹¶ä¸ºä¸€ä¸ª æœ‰åº çš„åºåˆ— //first1 æ˜¯ç¬¬ä¸€ä¸ªå®¹å™¨çš„é¦–è¿­ä»£å™¨ //last1 æ˜¯ç¬¬ä¸€ä¸ªå®¹å™¨çš„æœ«è¿­ä»£å™¨ //first2 æ˜¯ç¬¬äºŒä¸ªå®¹å™¨çš„é¦–è¿­ä»£å™¨ //last2 æ˜¯ç¬¬äºŒä¸ªå®¹å™¨çš„æœ«è¿­ä»£å™¨ //now åˆå¹¶ä¹‹åè¦å­˜æ”¾çš„å®¹å™¨é¦–åœ°å€ //cmpä¸ºæ¯”è¾ƒå‡½æ•°ï¼Œ ä¸å†™cmpåˆ™é»˜è®¤å‡åº vector&lt;ll&gt; v; v.resize(new size);//é…åˆmergeä½¿ç”¨ï¼Œä¸ç„¶ä¼šæŠ¥é”™ iota #include &lt;iostream&gt; // std::cout #include &lt;numeric&gt; // std::iota int main () { int numbers[10]; std::iota (numbers,numbers+10,100);////ä»val(æ­¤å¤„ä¸º100)å¼€å§‹é€ä¸ªåŠ ä¸€ for (int&amp; i:numbers) std::cout &lt;&lt; ' ' &lt;&lt; i;/////100 101 102 103 104 105 106 107 108 109 std::cout &lt;&lt; '\\n'; return 0; } ä½è¿ç®—å‡½æ•° __builtin_ctz()//è¿”å›äºŒè¿›åˆ¶ä¸‹æœ«å°¾0çš„ä¸ªæ•° __buitlin_ctzll()//è¿”å›äºŒè¿›åˆ¶æœ«å°¾0çš„ä¸ªæ•° __buitlin_clz()//è¿”å›äºŒè¿›åˆ¶ä¸‹å‰å¯¼0çš„ä¸ªæ•°ï¼Œæ€»é•¿32 __buitlin_clzll()//è¿”å›äºŒè¿›åˆ¶ä¸‹å‰å¯¼0çš„ä¸ªæ•°ï¼Œæ€»é•¿64 __builtin_popcount()//è¿”å›äºŒè¿›åˆ¶ä¸‹1çš„ä¸ªæ•° __builtin_ffs()//è¿”å›äºŒè¿›åˆ¶ä¸‹æœ€åä¸€ä¸ª1çš„ä½ç½®(æœ€åä¸€ä¸ªä½ç½®æ˜¯1) nth_element nth_element(v.begin(), v.begin() + k, v.end(), cmp); å°†ç¬¬ k å¤§çš„å…ƒç´ (æ’åºåæ”¾åœ¨v.begin()+k-1ä¸Šçš„å…ƒç´ )æ”¾åœ¨ v.begin()+k-1 ä¸Šï¼Œå‰é¢çš„å…ƒç´ éƒ½æ¯”å®ƒå°ï¼Œåé¢çš„éƒ½æ¯”å®ƒå¤§ v.erase+remove_if bool isZero(int num){return num == 0;} int main(){ vector&lt;int&gt; v{1,2,0,3,4,0,0,5,6,7,8,9,0,0,8,0,9}; remove_if(v.begin(),v.end(),isZero); for(vector&lt;int&gt;::iterator it = v.begin();it!=v.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; return 0; } // è¿™é‡Œçš„è¾“å‡ºä¸ºï¼š1 2 3 4 5 6 7 8 9 8 9 9 0 0 8 0 9 //å¯ä»¥ç†è§£ä¸ºç”¨remove_ifå°†å®¹å™¨ä¸­ç¬¦åˆremoveæ¡ä»¶çš„å…ƒç´ ç§»å»ï¼Œä½†å®¹å™¨çš„sizeä¸ä¼šæ”¹å˜ã€‚ //æ¯”å¦‚ä¾‹ä¸­æœ‰6ä¸ª0ï¼Œæœ€åå…­ä¸ªä½ç½®æ˜¯åŸåºåˆ—æœ€åå…­ä¸ªå…ƒç´ ï¼Œå¯ä»¥é…åˆ erase è¿›è¡Œåˆ é™¤ vector&lt;int&gt; v{1,2,0,3,4,0,0,5,6,7,8,9,0,0,8,0,9}; v.erase(remove_if(v.begin(),v.end(),isZero),v.end()); //å¾—åˆ°åºåˆ—ï¼š1 2 3 4 5 6 7 8 9 8 9","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"æ‰¾ä¸¤ä¸ªå‡åºæ•°ç»„çš„ä¸­ä½æ•°","slug":"7","date":"2024-06-04T07:51:49.681Z","updated":"2024-06-04T07:53:19.919Z","comments":true,"path":"2024/06/04/7/","link":"","permalink":"/2024/06/04/7/","excerpt":"","text":"LeetCode 4 ï¼š æ‰¾ä¸¤ä¸ªå‡åºæ•°ç»„çš„ä¸­ä½æ•°(ç¬¬ k å°) solutionï¼šæ¯æ¬¡åˆ ä¸€åŠ int getkth(int l1, int l2, vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2, int k) { if(l1 == nums1.size()) return nums2[l2 + k - 1]; if(l2 == nums2.size()) return nums1[l1 + k - 1]; if(k == 1) return min(nums1[l1], nums2[l2]); int mid = k / 2; int r1 = min(nums1.size() - 1, l1 + mid - 1); int r2 = min(nums2.size() - 1, l2 + mid - 1); if(nums1[r1] &lt;= nums2[r2]) return getkth(r1 + 1, l2, nums1, nums2, k - (r1 - l1 + 1)); return getkth(l1, r2 + 1, nums1, nums2, k - (r2 - l2 + 1)); } double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int totlen = nums1.size() + nums2.size(); if((totlen) &amp; 1) return getkth(0, 0, nums1, nums2, totlen / 2 + 1); return (getkth(0, 0, nums1, nums2, totlen / 2) + getkth(0, 0, nums1, nums2, totlen / 2 + 1)) / 2.0; }","categories":[{"name":"é¢˜ç›®","slug":"é¢˜ç›®","permalink":"/categories/é¢˜ç›®/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"/tags/LeetCode/"}],"keywords":[{"name":"é¢˜ç›®","slug":"é¢˜ç›®","permalink":"/categories/é¢˜ç›®/"}]},{"title":"è®¾è®¡æ¨¡å¼","slug":"6","date":"2024-06-04T06:58:29.241Z","updated":"2024-06-04T07:49:33.528Z","comments":true,"path":"2024/06/04/6/","link":"","permalink":"/2024/06/04/6/","excerpt":"","text":"å¸¸è§çš„ä¸ƒç§è®¾è®¡æ¨¡å¼ å•ä¾‹æ¨¡å¼ã€å·¥å‚æ–¹æ³•æ¨¡å¼ã€æŠ½è±¡å·¥å‚æ¨¡å¼ã€ä»£ç†æ¨¡å¼ã€è£…é¥°å™¨æ¨¡å¼ã€è§‚å¯Ÿè€…æ¨¡å¼ã€è´£ä»»é“¾æ¨¡å¼ è½¯ä»¶è®¾è®¡ä¸ƒå¤§åŸåˆ™ï¼ˆOOPåŸåˆ™ï¼‰ å¼€é—­åŸåˆ™ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ã€‚ é‡Œæ°æ›¿æ¢åŸåˆ™ï¼šä¸è¦ç ´åç»§æ‰¿ä½“ç³»ï¼Œå­ç±»é‡å†™æ–¹æ³•åŠŸèƒ½å‘ç”Ÿæ”¹å˜ï¼Œä¸åº”è¯¥å½±å“çˆ¶ç±»æ–¹æ³•çš„å«ä¹‰ã€‚ ä¾èµ–å€’ç½®åŸåˆ™ï¼šè¦é¢å‘æ¥å£ç¼–ç¨‹ï¼Œä¸è¦é¢å‘å®ç°ç¼–ç¨‹ã€‚ å•ä¸€èŒè´£åŸåˆ™ï¼šæ§åˆ¶ç±»çš„ç²’åº¦å¤§å°ã€å°†å¯¹è±¡è§£è€¦ã€æé«˜å…¶å†…èšæ€§ã€‚ æ¥å£éš”ç¦»åŸåˆ™ï¼šè¦ä¸ºå„ä¸ªç±»å»ºç«‹å®ƒä»¬éœ€è¦çš„ä¸“ç”¨æ¥å£ã€‚ è¿ªç±³ç‰¹æ³•åˆ™ï¼šä¸€ä¸ªç±»åº”è¯¥ä¿æŒå¯¹å…¶å®ƒå¯¹è±¡æœ€å°‘çš„äº†è§£ï¼Œé™ä½è€¦åˆåº¦ã€‚ åˆæˆå¤ç”¨åŸåˆ™ï¼šå¤šç”¨ç»„åˆè®¾è®¡ç±»ï¼Œå°‘ç»§æ‰¿ å•ä¾‹æ¨¡å¼(Singleton Pattern) â‘ å•ä¾‹ç±»åªæœ‰ä¸€ä¸ªå®ä¾‹å¯¹è±¡ â‘¢å•ä¾‹ç±»å¯¹å¤–æä¾›ä¸€ä¸ªè®¿é—®è¯¥å•ä¾‹çš„å…¨å±€è®¿é—®ç‚¹ â‘£ã€ä¼˜ç‚¹ å•ä¾‹æ¨¡å¼å¯ä»¥ä¿è¯å†…å­˜é‡Œåªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå‡å°‘äº†å†…å­˜çš„å¼€é”€ã€‚ å¯ä»¥é¿å…å¯¹èµ„æºçš„å¤šé‡å ç”¨ã€‚ å•ä¾‹æ¨¡å¼è®¾ç½®å…¨å±€è®¿é—®ç‚¹ï¼Œå¯ä»¥ä¼˜åŒ–å’Œå…±äº«èµ„æºçš„è®¿é—®ã€‚ â‘¤ã€ç¼ºç‚¹ å•ä¾‹æ¨¡å¼ä¸€èˆ¬æ²¡æœ‰æ¥å£ï¼Œæ‰©å±•å›°éš¾ã€‚ å•ä¾‹æ¨¡å¼çš„åŠŸèƒ½ä»£ç é€šå¸¸å†™åœ¨ä¸€ä¸ªç±»ä¸­ï¼Œå¦‚æœåŠŸèƒ½è®¾è®¡ä¸åˆç†ï¼Œåˆ™å¾ˆå®¹æ˜“è¿èƒŒå•ä¸€èŒè´£åŸåˆ™ æ‡’æ±‰æ¨¡å¼ å»¶æ—¶åŠ è½½ï¼Œ ç”±è°ƒç”¨è€…å®ä¾‹ï¼Œå¤šçº¿ç¨‹æƒ…å†µä¸‹ä¼šå­˜åœ¨çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Œéœ€è¦åŠ äº’æ–¥é”è¿›è¡Œé˜²æŠ¤ #include&lt;iostream&gt; #include&lt;mutex&gt; using namespace std; /*å•ä¾‹æ¨¡å¼ï¼šæ„é€ å‡½æ•°ç§æœ‰åŒ–ï¼Œå¯¹å¤–æä¾›ä¸€ä¸ªæ¥å£*/ //çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼ class Lazysingleton { public: static Lazysingleton* getinstance() { if (instance == nullptr) { i_mutex.lock(); if (instance == nullptr) { instance = new Lazysingleton(); } i_mutex.unlock();//è§£é” } return instance; } private: static Lazysingleton* instance; static mutex i_mutex;//é” Lazysingleton(){} Lazysingleton(const Singleton&amp;) = delete; Lazysingleton&amp; operator=(const Lazysingleton&amp;) = delete; }; Lazysingleton* Lazysingleton::instance=nullptr; mutex Lazysingleton::i_mutex;//ç±»å¤–åˆå§‹åŒ– int main() { Lazysingleton* lhsinglep5 = Lazysingleton::getinstance(); Lazysingleton* lhsinglep6 = Lazysingleton::getinstance(); cout &lt;&lt; lhsinglep5 &lt;&lt; endl; cout &lt;&lt; lhsinglep6 &lt;&lt; endl; return 0; } é¥¿æ±‰æ¨¡å¼ #include&lt;iostream&gt; using namespace std; /*å•ä¾‹æ¨¡å¼ï¼šæ„é€ å‡½æ•°ç§æœ‰åŒ–ï¼Œå¯¹å¤–æä¾›ä¸€ä¸ªæ¥å£*/ //é¥¿æ±‰æ¨¡å¼ï¼šä¸ç®¡ç”¨ä¸ç”¨å¾—åˆ°ï¼Œéƒ½æ„é€ å‡ºæ¥ã€‚æœ¬èº«å°±æ˜¯çº¿ç¨‹å®‰å…¨çš„ class hungrysingleton { public: static hungrysingleton* getinstance() { return instance; } private: static hungrysingleton* instance; hungrysingleton() {} hungrysingleton(const hungrysingleton&amp;) = delete; hungrysingleton&amp; operator=(const hungrysingleton&amp;) = delete; }; hungrysingleton* hungrysingleton::instance = new hungrysingleton(); int main() { hungrysingleton* ehsinglep3 = hungrysingleton::getinstance(); hungrysingleton* ehsinglep4 = hungrysingleton::getinstance(); cout &lt;&lt; ehsinglep3 &lt;&lt; endl; cout &lt;&lt; ehsinglep4 &lt;&lt; endl; return 0; }","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"SQL","slug":"5","date":"2024-06-04T06:56:14.867Z","updated":"2024-06-04T07:49:27.473Z","comments":true,"path":"2024/06/04/5/","link":"","permalink":"/2024/06/04/5/","excerpt":"","text":"CREATE DATABASE æ•°æ®åº“å; USE æ•°æ®åº“å; CREATE TABLE è¡¨å( åˆ—å1 ç±»å‹, åˆ—å2 ç±»å‹ ); å¢ insert into è¡¨å(å‚æ•°1,å‚æ•°2...) values (å‚æ•°1å€¼,å‚æ•°2å€¼...); è¿™ç§æ–¹å¼æ˜¯ç»™éƒ¨åˆ†å‚æ•°æˆ–æ‰€æœ‰å‚æ•°èµ‹å€¼ insert into è¡¨å values (å‚æ•°1å€¼,å‚æ•°2å€¼...); è¿™ç§æ–¹å¼å¿…é¡»ç»™æ‰€æœ‰å‚æ•°èµ‹å€¼ åˆ  delete from è¡¨å; åˆ é™¤è¡¨ä¸­æ‰€æœ‰æ•°æ® delete from è¡¨å where æ¡ä»¶; åˆ é™¤è¡¨ä¸­æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„æ•°æ® æ”¹ update è¡¨å set å‚æ•°1=å‚æ•°1å€¼,å‚æ•°2=å‚æ•°2å€¼,...; æ”¹å˜è¡¨ä¸­æ‰€æœ‰æ•°æ® update è¡¨å set å‚æ•°1=å‚æ•°1å€¼,å‚æ•°2=å‚æ•°2å€¼,... where æ¡ä»¶; æ”¹å˜è¡¨ä¸­æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„æ•°æ® æŸ¥ select * from è¡¨å; æŸ¥è¯¢è¡¨ä¸­æ‰€æœ‰æ•°æ® select * from è¡¨å where æ¡ä»¶; æŸ¥è¯¢è¡¨ä¸­æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„æ•°æ® select å‚æ•°1,å‚æ•°2... from è¡¨å; æŸ¥è¯¢è¡¨ä¸­éƒ¨åˆ†å‚æ•° select å‚æ•°1,å‚æ•°2... from è¡¨å where æ¡ä»¶; æŸ¥è¯¢è¡¨ä¸­æ»¡è¶³æ¡ä»¶çš„éƒ¨åˆ†å‚æ•° å»é‡ select distinct class_id from students; æ’åº select name, age from students order by age asc; select name, score from students order by score desc; SELECT * FROM students ORDER BY CASE WHEN gender = 'ç”·' THEN 1 WHEN gender = 'å¥³' THEN 2 ELSE 3 END; æˆªæ–­ -- LIMIT ååªè·Ÿä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºè¦æˆªæ–­çš„æ•°æ®æ¡æ•°ï¼ˆä¸€æ¬¡è·å–å‡ æ¡ï¼‰ select task_name, due_date from tasks limit 2; -- LIMIT åè·Ÿ 2 ä¸ªæ•´æ•°ï¼Œä¾æ¬¡è¡¨ç¤ºä»ç¬¬å‡ æ¡æ•°æ®å¼€å§‹ã€ä¸€æ¬¡è·å–å‡ æ¡ select task_name, due_date from tasks limit 2, 2; æ¡ä»¶åˆ†æ”¯ --æ¡ä»¶åˆ†æ”¯è¯­æ³• /*CASE WHEN (æ¡ä»¶1) THEN ç»“æœ1 * WHEN (æ¡ä»¶2) THEN ç»“æœ2 * ... * ELSE å…¶ä»–ç»“æœ END */ --å°†å­¦ç”ŸæŒ‰ç…§å¹´é¾„åˆ’åˆ†ä¸ºä¸‰ä¸ªå¹´é¾„ç­‰çº§ï¼ˆage_levelï¼‰ SELECT name, CASE WHEN (age &gt; 60) THEN 'è€åŒå­¦' WHEN (age &gt; 20) THEN 'å¹´è½»' ELSE 'å°åŒå­¦' END AS age_level FROM student ORDER BY name asc; IFNULL expression çš„å€¼ä¸æ˜¯ NULLï¼Œè¿”å›expressionçš„å€¼ï¼Œä¸ç„¶è¿”å› alternative_value IFNULL(expression, alternative_value); SELECT contactname, IFNULL(bizphone, homephone) AS phone FROM contacts; ä¸€å®šè¦é…åˆ as ä½¿ç”¨ï¼Œä¸ç„¶å­—æ®µåå°±æ˜¯ â€œIFNULL(bizphone, homephone)â€ èšåˆå‡½æ•° COUNTï¼šè®¡ç®—æŒ‡å®šåˆ—çš„è¡Œæ•°æˆ–éç©ºå€¼çš„æ•°é‡ã€‚ SUMï¼šè®¡ç®—æŒ‡å®šåˆ—çš„æ•°å€¼ä¹‹å’Œã€‚ AVGï¼šè®¡ç®—æŒ‡å®šåˆ—çš„æ•°å€¼å¹³å‡å€¼ã€‚ MAXï¼šæ‰¾å‡ºæŒ‡å®šåˆ—çš„æœ€å¤§å€¼ã€‚ MINï¼šæ‰¾å‡ºæŒ‡å®šåˆ—çš„æœ€å°å€¼ã€‚ --æ±‡æ€»å­¦ç”Ÿè¡¨ä¸­æ‰€æœ‰å­¦ç”Ÿçš„æ€»æˆç»©ï¼ˆtotal_scoreï¼‰ã€å¹³å‡æˆç»©ï¼ˆavg_scoreï¼‰ã€æœ€é«˜æˆç»©ï¼ˆmax_scoreï¼‰å’Œæœ€ä½æˆç»©ï¼ˆmin_scoreï¼‰ï¼Œæ±‡æ€»æ•°æ®æ¡æ•°ï¼ˆtotalï¼‰ SELECT SUM(score) AS total_score, AVG(score) AS avg_score, MAX(score) AS max_score, MIN(score) AS min_score, COUNT(*) AS total FROM student; COUNT( column_name ) è¿”å›æŒ‡å®šåˆ—çš„å€¼çš„æ•°ç›®ï¼Œä¸ä¼šè®¡å…¥ NULL å€¼ COUNT(1) å’Œ COUNT(*) éƒ½ä¼šè®°å½•NULLå€¼ DATEDIFF DATEDIFF(æ—¥æœŸ1, æ—¥æœŸ2)ï¼š è¿”å›æ—¥æœŸ1ä¸æ—¥æœŸ2ç›¸å·®çš„å¤©æ•°ã€‚ å¦‚æœæ—¥æœŸ1æ¯”æ—¥æœŸ2å¤§ï¼Œç»“æœä¸ºæ­£ï¼›å¦‚æœæ—¥æœŸ1æ¯”æ—¥æœŸ2å°ï¼Œç»“æœä¸ºè´Ÿ åˆ†ç»„èšåˆ --å•å­—æ®µåˆ†ç»„ --ç»Ÿè®¡å­¦ç”Ÿè¡¨ä¸­çš„ç­çº§ç¼–å·ï¼ˆclass_idï¼‰å’Œæ¯ä¸ªç­çº§çš„å¹³å‡æˆç»©ï¼ˆavg_scoreï¼‰ SELECT class_id, AVG(score) AS avg_score FROM student GROUP BY class_id; --å¤šå­—æ®µåˆ†ç»„ --ç»Ÿè®¡å­¦ç”Ÿè¡¨ä¸­æ¯ä¸ªç­çº§æ¯æ¬¡è€ƒè¯•çš„æ€»å­¦ç”Ÿäººæ•°ï¼ˆtotal_numï¼‰ SELECT class_id, exam_num, COUNT(*) AS total_num FROM student GROUP BY class_id, exam_num; HAVING HAVINGè¦ç”¨åœ¨ GROUP BY å SELECT name FROM Employee WHERE id IN (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT(*) &gt;= 5) ; å› ä¸ºå­æŸ¥è¯¢æœ‰å¤šæ¡ç»“æœï¼Œæ‰€ä»¥è¦ç”¨ â€œid INâ€ å…³è”ï¼ˆè¿æ¥ï¼‰ CROSS JOIN æ™®é€šå…³è”ï¼Œè¿”å›å¤šä¸ªè¡¨çš„ç¬›å¡å°”ç§¯ --å°†å­¦ç”Ÿè¡¨å’Œç­çº§è¡¨çš„æ‰€æœ‰è¡Œç»„åˆåœ¨ä¸€èµ·ï¼Œå¹¶è¿”å›å­¦ç”Ÿå§“åï¼ˆstudent_nameï¼‰ã€å­¦ç”Ÿå¹´é¾„ï¼ˆstudent_ageï¼‰ã€ç­çº§ç¼–å·ï¼ˆclass_idï¼‰ä»¥åŠç­çº§åç§°ï¼ˆclass_nameï¼‰ select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name from student s, class c; INNER JOIN æ˜¯ä¸€ç§å¸¸è§çš„å…³è”æŸ¥è¯¢æ–¹å¼ï¼Œå®ƒæ ¹æ®ä¸¤ä¸ªè¡¨ä¹‹é—´çš„å…³è”æ¡ä»¶ï¼Œå°†æ»¡è¶³æ¡ä»¶çš„è¡Œç»„åˆåœ¨ä¸€èµ·ã€‚æ³¨æ„ï¼ŒINNER JOIN åªè¿”å›ä¸¤ä¸ªè¡¨ä¸­æ»¡è¶³å…³è”æ¡ä»¶çš„äº¤é›†éƒ¨åˆ†ï¼Œå³åœ¨ä¸¤ä¸ªè¡¨ä¸­éƒ½å­˜åœ¨çš„åŒ¹é…è¡Œã€‚ --æ ¹æ®å­¦ç”Ÿè¡¨å’Œç­çº§è¡¨ä¹‹é—´çš„ç­çº§ç¼–å·è¿›è¡ŒåŒ¹é…ï¼Œè¿”å›å­¦ç”Ÿå§“åï¼ˆstudent_nameï¼‰ã€å­¦ç”Ÿå¹´é¾„ï¼ˆstudent_ageï¼‰ã€ç­çº§ç¼–å·ï¼ˆclass_idï¼‰ã€ç­çº§åç§°ï¼ˆclass_nameï¼‰ã€ç­çº§çº§åˆ«ï¼ˆclass_levelï¼‰ select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s join class c on s.class_id = c.id; å·¦å¤–è¿æ¥ï¼ˆLEFT JOINï¼‰ï¼šå³ä½¿å³è¡¨ä¸­æ²¡æœ‰åŒ¹é…ï¼Œä¹Ÿä»å·¦è¡¨è¿”å›æ‰€æœ‰çš„è¡Œ SELECT * FROM table1 RIGHT JOIN table2 ON condition; å³å¤–è¿æ¥ï¼ˆRIGHT JOINï¼‰ï¼šå³ä½¿å·¦è¡¨ä¸­æ²¡æœ‰åŒ¹é…ï¼Œä¹Ÿä»å³è¡¨è¿”å›æ‰€æœ‰çš„è¡Œ SELECT * FROM table1 RIGHT JOIN table2 ON condition; NATURAL JOIN è‡ªç„¶è¿æ¥ï¼Œ ç”¨äºåœ¨ä¸¤ä¸ªè¡¨ä¸­æŸ¥æ‰¾åŒååˆ—å¹¶ä¸”è¿™äº›åˆ—çš„å€¼ç›¸åŒçš„è¡Œã€‚è‡ªç„¶è¿æ¥ä¼šè‡ªåŠ¨é€‰æ‹©ä¸¤ä¸ªè¡¨ä¸­åŒåçš„ã€ç›¸åŒæ•°æ®ç±»å‹çš„åˆ—è¿›è¡Œè¿æ¥ SELECT * FROM employees NATURAL JOIN departments; ç´¢å¼• //æ™®é€šç´¢å¼• CREATE INDEX index_name ON table_name(index_column_1); //è”åˆç´¢å¼• CREATE INDEX index_name ON table_name(index_column_1ï¼Œindex_column_2ï¼Œ...); äº‹åŠ¡ START TRANSACTION;//æ‰§è¡Œç¬¬ä¸€æ¡è¯­å¥æ—¶å¯åŠ¨äº‹åŠ¡ //start transaction with consistent snapshot//ç«‹å³å¯åŠ¨äº‹åŠ¡ COMMIT; é” å…¨å±€é” flush tables with read lock; unlock tables; è¡¨é” è¡¨çº§é” //è¡¨çº§åˆ«çš„å…±äº«é”ï¼Œä¹Ÿå°±æ˜¯è¯»é”ï¼› lock tables t_student read; //è¡¨çº§åˆ«çš„ç‹¬å é”ï¼Œä¹Ÿå°±æ˜¯å†™é”ï¼› lock tables t_stuent write; unlock tables; æ„å‘é” //å…ˆåœ¨è¡¨ä¸ŠåŠ ä¸Šæ„å‘å…±äº«é”ï¼Œç„¶åå¯¹è¯»å–çš„è®°å½•åŠ å…±äº«é” select ... lock in share mode; //å…ˆè¡¨ä¸ŠåŠ ä¸Šæ„å‘ç‹¬å é”ï¼Œç„¶åå¯¹è¯»å–çš„è®°å½•åŠ ç‹¬å é” select ... for update; è¡Œçº§é” //å¯¹è¯»å–çš„è®°å½•åŠ å…±äº«é” select ... lock in share mode; //å¯¹è¯»å–çš„è®°å½•åŠ ç‹¬å é” select ... for update;","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"/tags/SQL/"}],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"c++","slug":"4","date":"2024-06-04T06:44:59.523Z","updated":"2024-06-04T07:49:22.591Z","comments":true,"path":"2024/06/04/4/","link":"","permalink":"/2024/06/04/4/","excerpt":"","text":"å¤šæ€æ³¨æ„ç‚¹ class B{ public: int a = 1; }; class D : public B{ public: int b = 1; }; int main() { D *pd = new D(); // åˆ›å»ºDç±»çš„å¯¹è±¡ pd-&gt;a = 2; B *pb = pd; // åŸºç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡ std::cout &lt;&lt; pb-&gt;a &lt;&lt; '\\n'; // std::cout &lt;&lt; pb-&gt;b &lt;&lt; '\\n'; errorï¼ŒåŸºç±»æŒ‡é’ˆpbæŒ‡å‘æ´¾ç”Ÿç±»æ—¶ï¼Œåªèƒ½è®¿é—®ç»§æ‰¿çš„éƒ¨åˆ† return 0; } ç¼ºçœå‚æ•°æ—©ç»‘å®šï¼Œç¼ºçœå‚æ•°å¯¹åº”çš„è™šå‡½æ•°æ™šç»‘å®š #include&lt;bits/stdc++.h&gt; using namespace std; class A{ public: A(){cout &lt;&lt; 1 &lt;&lt; '\\n';} A(A&amp;&amp; a) {cout &lt;&lt; 2 &lt;&lt; '\\n';} A(const A &amp;a) {cout &lt;&lt; 3 &lt;&lt; '\\n';}; void operator = (const A&amp; a) {cout &lt;&lt; 4 &lt;&lt; '\\n';} }; class B: public A{ public: B(){cout &lt;&lt; 'a' &lt;&lt; '\\n';} B(B&amp;&amp; b):A(b) {cout &lt;&lt; 'b' &lt;&lt; '\\n';} B(const B &amp;b):A(b) {cout &lt;&lt; 'c' &lt;&lt; '\\n';}; void operator = (const B&amp; b) {cout &lt;&lt; 'd' &lt;&lt; '\\n';} }; int main() { B b;//1a B m(b);//3c B p = b;//3cï¼Œæ³¨æ„æ˜¯åˆå§‹åŒ–ä¸æ˜¯èµ‹å€¼æ“ä½œï¼Œä¼šéšå¼è½¬æ¢æˆP(b) B q = move(b);//3bï¼Œæ³¨æ„A(b)è¿›å»å°±å¼ºè½¬ä¸ºå·¦å€¼äº† return 0; } è™šå‡½æ•°å®ç°åŸç† 1ã€è™šå‡½æ•°çš„å®ç°æ–¹å¼ï¼Œæ˜¯ç¼–è¯‘å™¨å†³å®šçš„ 2ã€å¦‚æœç±»å®šä¹‰äº†è™šå‡½æ•°ï¼Œç¼–è¯‘å™¨ä¼šä¸ºè¯¥ç±»åˆ›å»ºä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼ˆå…¶å®æ˜¯ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œæ•°ç»„å­˜æ”¾çš„å…ƒç´ æ˜¯è™šå‡½æ•°åœ°å€ï¼‰ï¼Œè¯¥è™šå‡½æ•°è¡¨å¹¶ä¸å­˜å‚¨åœ¨ç±»é‡Œé¢ï¼Œç¼–è¯‘å™¨ä¸ºç±»åˆ›å»ºäº†ä¸€ä¸ªéšè—æŒ‡é’ˆï¼ˆè¯¥æŒ‡é’ˆå ç”¨å­˜å‚¨ç©ºé—´ï¼‰ï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘è™šå‡½æ•°è¡¨ã€‚æ¯ä¸ªç±»å¯¹è±¡éƒ½ä¼šæœ‰ä¸€ä¸ªéšè—æŒ‡é’ˆã€‚ 3ã€å¦‚æœå£°æ˜äº†è™šå‡½æ•°çš„ç±»è¢«ç»§æ‰¿ï¼Œé‚£ä¹ˆå®ƒçš„è™šå‡½æ•°è¡¨ï¼Œä¼šè¢«å­ç±»å¤åˆ¶æ‹·è´ï¼ˆå†…å®¹ä¸€æ ·ï¼Œç‰©ç†ç©ºé—´ç‹¬ç«‹ï¼‰ï¼Œå¦‚æœè¯¥ ç±»è¦†ç›–äº†çˆ¶ç±»çš„è™šå‡½æ•°ï¼Œé‚£ä¹ˆè™šå‡½æ•°è¡¨é‡Œé¢å¯¹åº”çš„å‡½æ•°æŒ‡é’ˆå°±ä¼šæŒ‡å‘ï¼Œå­ç±»çš„è¦†ç›–å‡½æ•°ã€‚å¦‚æœå­ç±»æ–°å®šä¹‰äº†å…¶ä»–è™šå‡½æ•°ï¼Œé‚£ä¹ˆåœ¨è¯¥è™šå‡½æ•°è¡¨çš„åé¢è¿½åŠ è™šå‡½æ•°æŒ‡é’ˆã€‚ 4ã€å¦‚æœçˆ¶ç±»æŒ‡é’ˆæŒ‡å‘äº†ä¸€ä¸ªå­ç±»å¯¹è±¡ï¼Œé‚£ä¹ˆçˆ¶ç±»æŒ‡é’ˆä¼šè·å–å­ç±»å¯¹è±¡çš„éšè—çš„è™šå‡½æ•°è¡¨æŒ‡é’ˆã€‚å½“è°ƒç”¨ä¸€ä¸ªè™šå‡½æ•°åï¼Œä¼šé€šè¿‡è™šå‡½æ•°è¡¨æŒ‡é’ˆæ‰¾åˆ°è™šå‡½æ•°ï¼Œå†é€šè¿‡ç›¸å¯¹åç§»ï¼Œæ‰¾åˆ°å¯¹åº”çš„è™šå‡½æ•°æŒ‡é’ˆï¼Œè¿›è€Œæ‰¾åˆ°è™šå‡½æ•°ã€‚ 5ã€è°ƒç”¨è™šå‡½æ•°æ˜¯æ ¹æ®å…¶ç›¸å¯¹è™šå‡½æ•°è¡¨çš„é¦–åœ°å€çš„åç§»æ¥æŸ¥æ‰¾çš„ï¼Œåªè¦å°†åŸºç±»çš„è™šå‡½æ•°è¡¨æŒ‡é’ˆæ¢æˆå­ç±»çš„åŸºå‡½æ•°æŒ‡é’ˆï¼Œè‡ªåŠ¨å°±ä¼šå¯»æ‰¾åˆ°å­ç±»å®šä¹‰çš„è™šå‡½æ•°ã€‚ this-&gt;vptr-&gt;vtable-&gt;virtual fun è™šå‡½æ•°è¡¨å­˜æ”¾åœ¨å…¨å±€åŒº æ™®é€šç±»æˆå‘˜å‡½æ•°æ”¾åœ¨ä»£ç åŒº ä¸èƒ½å£°æ˜ä¸ºè™šå‡½æ•°çš„å‡½æ•°ï¼š æ„é€ å‡½æ•° å‹å…ƒå‡½æ•° éç±»æˆå‘˜å‡½æ•° é™æ€æˆå‘˜å‡½æ•° æ³¨æ„ï¼šå†…è”å‡½æ•°å¯ä»¥ä¸ºè™šå‡½æ•°ï¼Œä½†åœ¨è¡¨ç°å¤šæ€æ€§æ—¶ä¸ä¼šè¿›è¡Œå†…è”(å†™æ²¡å†™inlineæ˜¯ä¸€æ ·çš„)ï¼Œå› ä¸ºå†…è”å‡½æ•°æ˜¯åœ¨ç¼–è¯‘æ—¶å±•å¼€ ç¼–è¯‘å™¨å¤„ç†è™šå‡½æ•°è¡¨åº”è¯¥å¦‚ä½•å¤„ç† æ‹·â»‰åŸºç±»çš„è™šå‡½æ•°è¡¨ï¼Œå¦‚æœæ˜¯å¤šç»§æ‰¿ï¼Œå°±æ‹·â»‰æ¯ä¸ªæœ‰è™šå‡½æ•°åŸºç±»çš„è™šå‡½æ•°è¡¨ è¿˜æœ‰â¼€ä¸ªåŸºç±»çš„è™šå‡½æ•°è¡¨å’Œæ´¾â½£ç±»â¾ƒèº«çš„è™šå‡½æ•°è¡¨å…±â½¤äº†â¼€ä¸ªè™šå‡½æ•°è¡¨ï¼Œä¹Ÿç§°ä¸ºæŸä¸ªåŸºç±»ä¸ºæ´¾â½£ç±»çš„ä¸»åŸºç±» æŸ¥çœ‹æ´¾â½£ç±»ä¸­æ˜¯å¦æœ‰é‡å†™åŸºç±»ä¸­çš„è™šå‡½æ•°ï¼Œ å¦‚æœæœ‰ï¼Œå°±æ›¿æ¢æˆå·²ç»é‡å†™çš„è™šå‡½æ•°åœ°å€ï¼›æŸ¥çœ‹æ´¾â½£ç±»æ˜¯å¦æœ‰â¾ƒ èº«çš„è™šå‡½æ•°ï¼Œå¦‚æœæœ‰ï¼Œå°±è¿½åŠ â¾ƒèº«çš„è™šå‡½æ•°åˆ°â¾ƒèº«çš„è™šå‡½æ•°è¡¨ä¸­ è™šææ„å‡½æ•° è§£å†³ï¼šå¤šæ€ä½¿ç”¨æ—¶ï¼Œå¦‚æœå­ç±»ä¸­æœ‰å±æ€§å¼€è¾Ÿåˆ°å †åŒºï¼Œé‚£ä¹ˆçˆ¶ç±»çš„æŒ‡é’ˆåœ¨é‡Šæ”¾æ—¶æ— æ³•è°ƒç”¨å­ç±»çš„è™šæ„å‡½æ•° å¦‚æœå£°æ˜äº†è™šææ„å‡½æ•°ï¼Œåˆ™ä¸€å®šè¦æœ‰å‡½æ•°å®ç°ï¼Œä¸ç„¶åœ¨é‡Šæ”¾å¯¹è±¡æ—¶ä¼šäº§ç”ŸæŠ¥é”™ çº¯è™šå‡½æ•°å¯ä»¥æ²¡æœ‰å‡½æ•°å®ç°ï¼Œå› ä¸ºçº¯è™šå‡½æ•°ä¸èƒ½å®ä¾‹åŒ–å¯¹è±¡ è·å–è™šå‡½æ•°è¡¨ï¼Œè™šå‡½æ•°åœ°å€ #include&lt;bits/stdc++.h&gt; using namespace std; class intelCPU { public: virtual void run() { cout &lt;&lt; &quot;intelCPU æ­£åœ¨è¢«è°ƒç”¨&quot; &lt;&lt; '\\n'; } }; int main() { intelCPU a; cout &lt;&lt; *(int *)(&amp;a) &lt;&lt; '\\n';//è™šå‡½æ•°è¡¨åœ°å€ï¼Œè™šå‡½æ•°è¡¨ä½äºç±»åœ°å€çš„é¦–ä½ int addr = *(int *)(&amp;a); cout &lt;&lt; *(int *)(addr + 0);//è™šå‡½æ•°åœ°å€ *(int *)(addr + 4*x)ï¼Œxä»0å¼€å§‹ï¼Œå¤šä¸€ä¸ªè™šå‡½æ•°å°±+1 return 0; } è±å½¢ç»§æ‰¿ è™šç»§æ‰¿ #include &lt;iostream&gt; using namespace std; class A { public: int a; }; class B : virtual public A { public: int b; }; class C : virtual public A { public: int c; }; class D : public B, public C //è¿™é‡Œä¹Ÿå¯ä»¥åŠ ä¸Švirtualï¼Œä½†æ²¡æœ‰æ„ä¹‰ã€‚ä½†ä¸èƒ½è¿™é‡ŒåŠ virtualè€Œä¸Šé¢æ²¡æœ‰åŠ ï¼Œå› ä¸ºè¿™æ ·ä¼šå¯¼è‡´Bï¼ŒCä¸­å·²ç»æœ‰å„è‡ªç‹¬ç«‹çš„Açš„å®ä¾‹ { public: int d; }; int main() { D d; cout &lt;&lt; &amp;d.a &lt;&lt; endl;//è¾“å‡ºç›¸åŒï¼Œdä¸­åªæœ‰ä¸€ä»½å‰¯æœ¬ cout &lt;&lt; &amp;d.B::a &lt;&lt; endl; cout &lt;&lt; &amp;d.C::a &lt;&lt; endl; return 0; } è™šç»§æ‰¿ä¸­ï¼ŒDåªä¼šæœ‰ä¸€ä¸ªè™šå‡½æ•°è¡¨æŒ‡é’ˆï¼ŒæŒ‡å‘ABCä¸­è™šå‡½æ•°å…±äº«çš„è™šå‡½æ•°è¡¨ éè™šç»§æ‰¿ä¸­ï¼ŒDä¸­ä¼šæœ‰ä¸¤ä¸ªè™šå‡½æ•°è¡¨æŒ‡é’ˆ c++11æ–°ç‰¹æ€§ auto åˆ«åæ¨¡æ¿ template &lt;typename T&gt; using Vec = std::vector&lt;T&gt;; template&lt;typename T, typename U&gt; struct A { T t; U u; }; template&lt;typename T&gt; using B = A&lt;T, int&gt;; int main() { B&lt;double&gt; b; b.t = 10; b.u = 20; cout &lt;&lt; b.t &lt;&lt; endl; cout &lt;&lt; b.u &lt;&lt; endl; return 0; } æ™ºèƒ½æŒ‡é’ˆ æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸€ä¸ªç±»ï¼Œç”¨æ¥å­˜å‚¨æŒ‡å‘åŠ¨æ€åˆ†é…å¯¹è±¡çš„æŒ‡é’ˆï¼Œè´Ÿè´£è‡ªåŠ¨é‡Šæ”¾åŠ¨æ€åˆ†é…çš„å¯¹è±¡ ï¼Œé˜²æ­¢å †å†…å­˜æ³„æ¼ã€‚ å½“ç±»å¯¹è±¡å£°æ˜å‘¨æœŸç»“æŸæ—¶ï¼Œè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°é‡Šæ”¾èµ„æºã€‚ å¤´æ–‡ä»¶ C++11 å¼•å…¥ 3 ä¸ªæ™ºèƒ½æŒ‡é’ˆç±»å‹ï¼š unique_ptrï¼šç‹¬å èµ„æºæ‰€æœ‰æƒæŒ‡é’ˆ unique_ptr çš„ä½¿ç”¨æ¯”è¾ƒç®€å•ï¼Œä¹Ÿæ˜¯ç”¨å¾—æ¯”è¾ƒå¤šçš„æ™ºèƒ½æŒ‡é’ˆã€‚å½“æˆ‘ä»¬ç‹¬å èµ„æºçš„æ‰€æœ‰æƒçš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ unique_ptr å¯¹èµ„æºè¿›è¡Œç®¡ç†â€”â€”ç¦»å¼€ unique_ptr å¯¹è±¡çš„ä½œç”¨åŸŸæ—¶ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾èµ„æº unique_ptr æ˜¯ move-only çš„ï¼Œä¹Ÿæ˜¯å®ç°å°†ä¸€ä¸ª unique_ptr å¯¹è±¡èµ‹å€¼ç»™å¦ä¸€ä¸ª unique_ptr å¯¹è±¡çš„æ–¹æ³• { std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200); std::unique_ptr&lt;int&gt; uptr1 = uptr; // ç¼–è¯‘é”™è¯¯ï¼Œstd::unique_ptr&lt;T&gt; æ˜¯ move-only çš„ std::unique_ptr&lt;int&gt; uptr2 = std::move(uptr); assert(uptr == nullptr); } shared_ptrï¼šå…±äº«èµ„æºæ‰€æœ‰æƒæŒ‡é’ˆ shared_ptr å…¶å®å°±æ˜¯å¯¹èµ„æºåšå¼•ç”¨è®¡æ•°â€”â€”å½“å¼•ç”¨è®¡æ•° sptr.use_count() ä¸º 0çš„æ—¶å€™ï¼Œè‡ªåŠ¨é‡Šæ”¾èµ„æºã€‚ { std::shared_ptr&lt;int&gt; sptr = std::make_shared&lt;int&gt;(200); assert(sptr.use_count() == 1); // æ­¤æ—¶å¼•ç”¨è®¡æ•°ä¸º 1 { std::shared_ptr&lt;int&gt; sptr1 = sptr; assert(sptr.get() == sptr1.get()); assert(sptr.use_count() == 2); // sptr å’Œ sptr1 å…±äº«èµ„æºï¼Œå¼•ç”¨è®¡æ•°ä¸º 2 } assert(sptr.use_count() == 1); // sptr1 å·²ç»é‡Šæ”¾ } // use_count ä¸º 0 æ—¶è‡ªåŠ¨é‡Šæ”¾å†…å­˜ #include &lt;iostream&gt; #include &lt;mutex&gt; using namespace std; template&lt;typename T&gt; class shared_ptr{ public: explicit shared_ptr(T *ptr = nullptr) :m_ptr(ptr), m_count(new unsigned int(0)), m_mutex(new mutex) { if(ptr != nullptr) addCount(); } explicit shared_ptr(const shared_ptr&lt;T&gt; &amp;sp) :m_ptr(sp.m_ptr), m_count(sp.m_count), m_mutex(sp.m_mutex) { addCount(); } shared_ptr&lt;T&gt;&amp; operator= (const shared_ptr&lt;T&gt; &amp;sp) { if(m_ptr != sp.m_ptr) { release(); m_ptr = sp.m_ptr; m_count = sp.m_count; m_mutex = sp.m_mutex; addCount(); } return *this; } T* operator-&gt; () { return m_ptr; } T operator* () { return *m_ptr; } T* get() { return m_ptr; } unsigned int getCount() { return *m_count; } ~shared_ptr() { release(); } private: T* m_ptr; unsigned int *m_count; mutex *m_mutex; void addCount() { m_mutex-&gt;lock(); ++(*m_count); m_mutex-&gt;unlock(); } void release() { bool deleteFlag = false; m_mutex-&gt;lock(); if(--(*m_count) == 0) { delete m_ptr; m_ptr = NULL; delete m_count; m_count = NULL; deleteFlag = true; } m_mutex-&gt;unlock(); if(deleteFlag) { delete m_mutex; m_mutex = NULL; } } }; int main() { shared_ptr&lt;int&gt; p1(new int(6)); cout &lt;&lt; p1.getCount() &lt;&lt; '\\n'; shared_ptr&lt;int&gt; p2(p1); cout &lt;&lt; p1.getCount() &lt;&lt; '\\n'; shared_ptr&lt;int&gt; p3; p3 = p1; cout &lt;&lt; p1.getCount() &lt;&lt; '\\n'; cout &lt;&lt; *p1 &lt;&lt; ' ' &lt;&lt; *p2 &lt;&lt; ' ' &lt;&lt; *p3 &lt;&lt; '\\n'; shared_ptr&lt;int&gt; p4(new int(7)); p3 = p4; cout &lt;&lt; p1.getCount() &lt;&lt; ' ' &lt;&lt; p4.getCount() &lt;&lt; '\\n'; return 0; } weak_ptrï¼šå…±äº«èµ„æºçš„è§‚å¯Ÿè€…ï¼Œéœ€è¦å’Œshared_pträ¸€èµ·ä½¿ç”¨ #include &lt;iostream&gt; #include &lt;memory&gt; class CB; class CA { public: CA() { std::cout &lt;&lt; &quot;CA()&quot; &lt;&lt; std::endl; } ~CA() { std::cout &lt;&lt; &quot;~CA()&quot; &lt;&lt; std::endl; } void set_ptr(std::shared_ptr&lt;CB&gt;&amp; ptr) { m_ptr_b = ptr; } private: std::shared_ptr&lt;CB&gt; m_ptr_b; }; class CB { public: CB() { std::cout &lt;&lt; &quot;CB()&quot; &lt;&lt; std::endl; } ~CB() { std::cout &lt;&lt; &quot;~CB()&quot; &lt;&lt; std::endl; } void set_ptr(std::shared_ptr&lt;CA&gt;&amp; ptr) { m_ptr_a = ptr; } private: std::weak_ptr&lt;CA&gt; m_ptr_a; }; int main() { std::shared_ptr&lt;CA&gt; ptr_a(new CA()); std::shared_ptr&lt;CB&gt; ptr_b(new CB()); ptr_a-&gt;set_ptr(ptr_b); ptr_b-&gt;set_ptr(ptr_a); std::cout &lt;&lt; ptr_a.use_count() &lt;&lt; &quot; &quot; &lt;&lt; ptr_b.use_count() &lt;&lt; std::endl;//1 2 return 0; } weak_ptrç»‘å®šåˆ°ä¸€ä¸ªshared_pträ¸ä¼šæ”¹å˜shared_ptrçš„å¼•ç”¨è®¡æ•° atomic åŸå­å˜é‡æ˜¯ç‰¹æ®Šçš„æ•°æ®ç±»å‹ï¼Œæä¾›äº†ä¸€ç§çº¿ç¨‹å®‰å…¨çš„æ–¹å¼æ¥è®¿é—®å’Œä¿®æ”¹å…±äº«æ•°æ®ï¼Œè€Œæ— éœ€ä½¿ç”¨æ˜¾å¼çš„äº’æ–¥é” ã€‚ memoryåº“ä¸­çš„shared_ptrå°±æ˜¯ä½¿ç”¨atomicä¿è¯çš„çº¿ç¨‹å®‰å…¨ atomic&lt;int&gt; a(1);//å£°æ˜ b = a.fetch_add(1);//b = 1ï¼Œa = 2ï¼Œa.fetch_add(1)çš„è¿”å›å€¼æ˜¯åŸæ¥çš„å€¼ b = a.load();//b = 2ï¼Œa.load()è¿”å›açš„å½“å‰å€¼ åŸå­å˜é‡åªæœ‰ä½¿ç”¨åŸå­æ“ä½œ( fetch_add(åç½®è‡ªå¢) ã€ compare_exchange_strong ã€load(è¯»)ã€store(ä¿®æ”¹)ç­‰)æ‰æ˜¯çº¿ç¨‹å®‰å…¨çš„ ++ã€â€“ã€+ ç­‰æœ‰å¯¹åº”åŸå­æ“ä½œè¿ç®—éƒ½ä¼šè½¬æ¢æˆåŸå­æ“ä½œ ä½¿ç”¨éåŸå­æ“ä½œå‡½æ•°æ¥è®¿é—® std::atomic å˜é‡çš„åº•å±‚å€¼ï¼Œé‚£ä¹ˆè¿™äº›æ“ä½œå°±ä¸å†æ˜¯çº¿ç¨‹å®‰å…¨ å†…å­˜åº C++11ä¸­çš„å†…å­˜åºï¼ˆmemory orderï¼‰æ˜¯ä¸€ç§ç”¨äºæŒ‡å®šåŸå­æ“ä½œåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­å¦‚ä½•åŒæ­¥çš„æœºåˆ¶ã€‚å®ƒå®šä¹‰äº†åŸå­æ“ä½œå¯¹å†…å­˜çš„è®¿é—®é¡ºåºï¼Œä»¥åŠå¦‚ä½•åœ¨ä¸åŒçº¿ç¨‹ä¹‹é—´ä¼ æ’­å†…å­˜ä¿®æ”¹çš„è§„åˆ™ åªæœ‰åŸå­æ“ä½œæ”¯æŒå†…å­˜åº c++11æœ‰6ç§å†…å­˜åº åæ¬¡è§£é‡Šï¼š â€‹ **happens-before:**æŒ‰ç…§ç¨‹åºçš„ä»£ç åºæ‰§è¡Œ â€‹ **synchronized-with:**ä¸åŒçº¿ç¨‹é—´ï¼Œå¯¹äºåŒä¸€ä¸ªåŸå­æ“ä½œï¼Œéœ€è¦åŒæ­¥å…³ç³»ï¼Œstoreæ“ä½œä¸€å®šè¦å…ˆäº loadï¼Œä¹Ÿå°±æ˜¯è¯´ å¯¹äºä¸€ä¸ªåŸå­å˜é‡xï¼Œå…ˆå†™xï¼Œç„¶åè¯»xæ˜¯ä¸€ä¸ªåŒæ­¥çš„æ“ä½œï¼Œè¯»xå¹¶ä¸ä¼šè¯»å–ä¹‹å‰çš„å€¼ï¼Œè€Œæ˜¯å†™xåçš„å€¼ã€‚ memory_order_relaxed ä¸å¯¹æ‰§è¡Œé¡ºåºåšä¿è¯ï¼Œæ²¡æœ‰ happens-beforeçš„çº¦æŸã€‚ // çº¿ç¨‹ 1 ï¼š r1 = y.load(std::memory_order_relaxed); // A x.store(r1, std::memory_order_relaxed); // B // çº¿ç¨‹ 2 ï¼š r2 = x.load(std::memory_order_relaxed); // C y.store(6, std::memory_order_relaxed); // D æ‰§è¡Œé¡ºåºå¯èƒ½æ˜¯DABC memory_order_acquire å’Œmemory_order_release memory_order_releaseä¿è¯æœ¬çº¿ç¨‹ä¸­,æ‰€æœ‰ä¹‹å‰çš„å†™æ“ä½œå®Œæˆåæ‰èƒ½æ‰§è¡Œæœ¬æ¡åŸå­æ“ä½œã€‚ memory_order_acquireä¿è¯æœ¬çº¿ç¨‹ä¸­,æ‰€æœ‰åç»­çš„è¯»æ“ä½œå¿…é¡»åœ¨æœ¬æ¡åŸå­æ“ä½œå®Œæˆåæ‰§è¡Œã€‚ #include &lt;thread&gt; #include &lt;atomic&gt; #include &lt;cassert&gt; #include &lt;string&gt; std::atomic&lt;std::string*&gt; ptr; int data; void producer() { std::string* p = new std::string(&quot;Hello&quot;); data = 42; ptr.store(p, std::memory_order_release); } void consumer() { std::string* p2; while (!(p2 = ptr.load(std::memory_order_acquire))) ; assert(*p2 == &quot;Hello&quot;); // ç»æ— é—®é¢˜ assert(data == 42); // ç»æ— é—®é¢˜ } int main() { std::thread t1(producer); std::thread t2(consumer); t1.join(); t2.join(); } memory_order_releaseå’Œmemory_order_acquireçš„ç»„åˆæä¾›äº†ä¸€ç§ä¿è¯çº¿ç¨‹é—´æ“ä½œé¡ºåºå’Œå¯è§æ€§çš„æœºåˆ¶ï¼Œä»è€Œé¿å…äº†æ•°æ®ç«äº‰å’Œå…¶ä»–å¹¶å‘é”™è¯¯ã€‚ å¦‚æœåªæœ‰memory_order_releaseè€Œæ²¡æœ‰memory_order_acquireï¼Œè™½ç„¶èƒ½ä¿è¯dataæ›´æ–°äº†ï¼Œä½†å¯èƒ½å› ä¸ºç¼“å­˜ä¸€è‡´æ€§å¯¼è‡´æ‰§è¡Œ assert(data == 42); dataçš„å€¼ä¸å¯è§è¿˜æ˜¯æ—§å€¼0 memory_order_consume memory_order_acq_rel memory_order_acquire å’Œmemory_order_releaseçš„ç»“åˆ memory_order_seq_cst åŒæ­¥æ¨¡å¼ï¼ŒåŒæ—¶ä¹Ÿæ˜¯é»˜è®¤çš„æ¨¡å‹ï¼Œå…·æœ‰å¼ºçƒˆçš„happens-beforeè¯­ä¹‰ï¼Œ æ¥ä¿è¯æŒ‡ä»¤çš„é¡ºåºä¸€è‡´æ‰§è¡Œï¼Œç›¸å½“äºä¸æ‰“å¼€ç¼–è¯‘å™¨ä¼˜åŒ–æŒ‡ä»¤ï¼ŒæŒ‰ç…§æ­£å¸¸çš„æŒ‡ä»¤åºæ‰§è¡Œã€‚å¤šçº¿ç¨‹å„åŸå­æ“ä½œä¹Ÿä¼šSynchronized-withï¼Œè­¬å¦‚atomic::load()éœ€è¦ç­‰å¾…atomic::store()å†™ä¸‹å…ƒç´ æ‰èƒ½è¯»å–ã€‚æ›´è¿›ä¸€æ­¥åœ°ï¼Œè¯»æ“ä½œéœ€è¦åœ¨â€œä¸€ä¸ªå†™æ“ä½œå¯¹æ‰€æœ‰å¤„ç†å™¨å¯è§â€çš„æ—¶å€™æ‰èƒ½è¯»ï¼Œé€‚ç”¨äºåŸºäºç¼“å­˜çš„ä½“ç³»ç»“æ„ã€‚ lambda(åŒ¿åå‡½æ•°) //[&amp;],[=],[A, B, C]åªè·å¾—ABC auto f = [](int a, int b) -&gt;{ return a + b; } void fun1()//å€¼æ•è·ä¼šåœ¨lambdaåˆ›å»ºæ—¶æ‹·è´ { size_t v1 = 42; auto f = [v1]() mutable {return ++v1;}; v1 = 0; auto j = f();//43 } void fun2()//å¼•ç”¨æ•è·ä¼šåœ¨lambdaè°ƒç”¨æ—¶å¼•ç”¨ { size_t v1 = 42; auto f = [&amp;v1]() {return ++v1;}; v1 = 0; auto j = f();//1 } å³å€¼ ä¸€ä¸ªéå¼•ç”¨å·¦å€¼å¼ºåˆ¶ç±»å‹è½¬æ¢åä¸ºå³å€¼ nullptr NULLæ˜¯0ï¼Œè€Œnullptrå°±æ˜¯ç©ºæŒ‡é’ˆï¼Œæœ‰è‡ªå·±çš„ç±»å‹ æ ¹æ®ç±»å‹å¯ä»¥æŠ›å‡ºå¼‚å¸¸ constexpr å¯ä»¥ç”¨æ¥åˆ¤æ–­ä¸€ä¸ªè¡¨è¾¾å¼æ˜¯å¦ä¸ºå¸¸é‡è¡¨è¾¾å¼ åœ¨ç¼–è¯‘æ—¶å°±ç¡®å®šå…¶ä¿®é¥°å¯¹è±¡çš„å€¼ constexpræŒ‡é’ˆ æ‰€æŒ‡å˜é‡å¿…é¡»æ˜¯å…¨å±€å˜é‡æˆ–è€…staticå˜é‡ const: é™å®šä¸€ä¸ªå˜é‡ä¸å…è®¸è¢«æ”¹å˜ å¦‚ä½•const ä¿®é¥°çš„å˜é‡æ˜¯å¸¸é‡æˆ–è¡¨è¾¾å¼)å¼åˆ™åœ¨ç¼–è¯‘æ—¶ç¡®å®šå€¼ï¼Œä¸ç„¶åœ¨è¿è¡Œæ—¶ç¡®å®šå€¼ å¼•ç”¨ç±»å‹å¿…é¡»äºå…¶æ‰€å¼•ç”¨çš„å¯¹è±¡ç±»å‹ä¸€è‡´ï¼Œä½†ç”¨ä¸€ç§ä¾‹å¤–ã€‚ åˆå§‹åŒ–å¸¸é‡[å¼•ç”¨]æ—¶å…è®¸ç”¨ä»»æ„è¡¨è¾¾å¼ä½œä¸ºåˆå§‹å€¼ int i = 1; const int &amp;a = i;//correct const int b = i; finalå’Œoverideå…³é”®å­— overideï¼šå‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªå‡½æ•°ä¸€å®šä¼šé‡å†™åŸºç±»ä¸­çš„è™šå‡½æ•°ï¼Œå¦‚æœåŸºç±»ä¸­æ²¡æœ‰è¯¥è™šå‡½æ•°åˆ™ç¼–è¯‘æ— æ³•é€šè¿‡ finalï¼šå‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªå‡½æ•°åˆ°å½“å‰æˆªæ­¢ï¼Œåé¢æœ‰ç±»ç»§æ‰¿è¯¥ç±»ä¹Ÿä¸èƒ½é‡å†™è¯¥å‡½æ•°ã€‚ä¹Ÿå¯ä»¥ä¿®é¥°ç±»ï¼Œè¡¨ç¤ºè¯¥ç±»ä¸å¯ä»¥è¢«ç»§æ‰¿ struct Base1 final { }; struct Derived1 : Base1 {}; // ç¼–è¯‘é”™ï¼šBase1ä¸å…è®¸è¢«ç»§æ‰¿ struct Base2 { virtual void f1() final; virtual void f2(); }; struct Derived2 : Base2 { virtual void f1(); // ç¼–è¯‘é”™ï¼šf1ä¸å…è®¸é‡å†™ virtual void f2(int) override; // ç¼–è¯‘é”™ï¼šâ½—ç±»ä¸­æ²¡æœ‰ void f2(int) }; C++14æ–°ç‰¹æ€§ å‡½æ•°è¿”å›ç±»å‹æ¨å¯¼ auto func(int i) { return i; } lambda å‚æ•° auto auto f = [] (int a) { return a; }//c++11 auto f = [] (auto a) { return a; };//c++14 å˜é‡æ¨¡æ¿ template&lt;class T&gt; constexpr T pi = T(3.1415926535897932385L); int main() { cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl; // 3 cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl; // 3.14159 return 0; } æ”¾å®½å¯¹constexprçš„é™åˆ¶ C++11ä¸­constexprå‡½æ•°å¯ä»¥ä½¿ç”¨é€’å½’ï¼Œåœ¨C++14ä¸­å¯ä»¥ä½¿ç”¨å±€éƒ¨å˜é‡å’Œå¾ªç¯ constexpr int factorial(int n) { // C++14 å’Œ C++11å‡å¯ return n &lt;= 1 ? 1 : (n * factorial(n - 1)); } constexpr int factorial(int n) { // C++11ä¸­ä¸å¯ï¼ŒC++14ä¸­å¯ä»¥ int ret = 0; for (int i = 0; i &lt; n; ++i) { ret += i; } return ret; } C++11ä¸­constexprå‡½æ•°å¿…é¡»å¿…é¡»æŠŠæ‰€æœ‰ä¸œè¥¿éƒ½æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„returnè¯­å¥ä¸­ï¼Œc++14åˆ™æ— æ­¤é™åˆ¶ constexpr int func(bool flag) { // C++14 å’Œ C++11å‡å¯ return 0; } constexpr int func(bool flag) { // C++11ä¸­ä¸å¯ï¼ŒC++14ä¸­å¯ä»¥ if (flag) return 1; else return 0; } äºŒè¿›åˆ¶å­—é¢é‡ä¸æ•´å½¢å­—é¢é‡åˆ†éš”ç¬¦ int a = 0b0001'0011'1010; double b = 3.14'1234'1234'1234; std::make_unique struct A {}; std::unique_ptr&lt;A&gt; ptr = std::make_unique&lt;A&gt;(); std::exchange exchange(a, b) å°†aå˜æˆbï¼Œå‡½æ•°è¿”å›açš„æ—§å€¼ int main() { std::vector&lt;int&gt; v; std::exchange(v, {1,2,3,4}); cout &lt;&lt; v.size() &lt;&lt; endl; for (int a : v) { cout &lt;&lt; a &lt;&lt; &quot; &quot;; } return 0; } exchangeæºç  template&lt;class T, class U = T&gt; constexpr T exchange(T&amp; obj, U&amp;&amp; new_value) { T old_value = std::move(obj); obj = std::forward&lt;U&gt;(new_value); return old_value; } std::forward æ˜¯æ¨¡æ¿å‡½æ•°ï¼Œç”¨äºå®ç°å®Œç¾è½¬å‘ï¼Œå¯ä»¥æé«˜æ•ˆç‡ å½“new_valueæ˜¯å·¦å€¼æ—¶ï¼Œåˆ™å°†å…¶æ‹·è´ç»™obj å½“new_valueæ˜¯å³å€¼æ—¶ï¼Œåˆ™å°†å…¶ç§»åŠ¨ç»™obj c++17æ–°ç‰¹æ€§ æ„é€ å‡½æ•°æ¨¡æ¿æ¨å¯¼ pair p(1, 2.2); // c++17 è‡ªåŠ¨æ¨å¯¼ vector v = {1, 2, 3}; // c++17 ç»“æ„åŒ–ç»‘å®š æŠ˜å è¡¨è¾¾å¼ å¯ä»¥ç®€åŒ–å¯å˜å‚æ•°æ¨¡æ¿ç¼–ç¨‹ template &lt;typename ... Ts&gt; auto sum(Ts ... ts) { return (ts + ...); } int a {sum(1, 2, 3, 4, 5)}; å‘½åç©ºé—´åµŒå¥—å®šä¹‰ namespace A { namespace B { namespace C { void func(); } } } // c++17ï¼Œæ›´æ–¹ä¾¿æ›´èˆ’é€‚ namespace A::B::C { void func(); } c++20æ–°ç‰¹æ€§ æ¨¡å— **è§£å†³ï¼š**ä½¿ç”¨#includeåŒ…å«å¤´æ–‡ä»¶è¿›è¡Œæ¨¡å—åŒ–ç¼–ç¨‹ã€‚ä½†æ˜¯#includeæ˜¯åœ¨é¢„å¤„ç†é˜¶æ®µå¼•å…¥æ–‡ä»¶é‡Œçš„å†…å®¹ï¼Œå°¤å…¶æ˜¯æ¶‰åŠåˆ°é€’å½’å¼•å…¥æ—¶ï¼Œå¢åŠ ç¼–è¯‘æ—¶é•¿ï¼›å¤´æ–‡ä»¶åšå‡ºä¿®æ”¹ï¼Œæ‰€æœ‰å¼•å…¥è¯¥å¤´æ–‡ä»¶çš„ç¿»è¯‘å•å…ƒå‡éœ€è¦é‡æ–°ç¼–è¯‘ï¼Œä¹Ÿä¼šå¢åŠ ç¼–è¯‘æ—¶é—´ï¼›åŒæ—¶å¤´æ–‡ä»¶å†…çš„å®ã€å…¨å±€å˜é‡å¦æ˜¯åœ¨å…¨å±€å‘½åç©ºé—´ä¸­å®šä¹‰ï¼Œæ˜“å¯¼è‡´å‘½åå†²çª **æ”¹è¿›äº†ç¼–è¯‘é€Ÿåº¦å’Œæ€§èƒ½ ï¼š**æ¨¡å—ä¼šè¢«ç¼–è¯‘å™¨é¢„å…ˆç¼–è¯‘ä¸€æ¬¡ **æ›´å¿«çš„æ„å»ºæ—¶é—´ï¼š**ç”±äºæ¨¡å—å¯ä»¥å‡å°‘å¤´æ–‡ä»¶çš„é‡å¤è§£æå’Œç¼–è¯‘ï¼Œå› æ­¤å¯ä»¥åŠ å¿«æ•´ä½“çš„æ„å»ºæ—¶é—´ **é¿å…å®æ±¡æŸ“ï¼š**ä¼ ç»Ÿçš„#includeé¢„å¤„ç†æŒ‡ä»¤å¯èƒ½ä¼šå¼•å…¥ä¸å¿…è¦çš„å®å®šä¹‰ï¼Œå¯èƒ½å¯¼è‡´å‘½åç©ºé—´æ±¡æŸ“å’Œæ„å¤–çš„è¡Œä¸ºã€‚ä½¿ç”¨æ¨¡å—å¯ä»¥å‡å°‘è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œå› ä¸ºæ¨¡å—çš„å¯¼å…¥æ›´ä¸ºæ˜ç¡® **æé«˜ä»£ç çš„å¯ç»´æŠ¤æ€§ï¼š**æ¨¡å—æä¾›äº†æ›´æ¸…æ™°çš„æ¥å£å’Œä¾èµ–å…³ç³»ï¼Œä½¿å¾—ä»£ç æ›´æ˜“äºç†è§£ã€ç»´æŠ¤å’Œé‡ç”¨ã€‚ //math_separate.ixx //è¯¥æ¨¡å—æ¥å£æ–‡ä»¶æ— æ¨¡å—å…¨å±€ç‰‡æ®µ // å¯¼å‡ºæ¨¡å—æ¥å£ï¼Œæ¨¡å—æ¥å£éƒ¨åˆ† export module math_separate; // å®šä¹‰æ¨¡å—æ¥å£ export int add(int a, int b); //math_separate.cpp module; #include&lt;iostream&gt; //å¦‚ä¸‹ä¸€è¡Œå«ä¹‰ä¸ºæŒ‡æ˜è¯¥æ–‡ä»¶ä¸ºmath_separateçš„å®ç°æ–‡ä»¶ module math_separate; int add(int a, int b)//æ¨¡å—å®ç° { std::cout &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;=&quot; &lt;&lt; a + b &lt;&lt; &quot;\\n&quot;; return a + b; } ä¸€ä¸ªæ¨¡å—å¯ä»¥åˆ†å‰²ä¸ºä¸€ä¸ªæ¨¡å—æ¥å£æ–‡ä»¶å’Œå¤šä¸ªæ¨¡å—å®ç°æ–‡ä»¶ï¼Œå¯ä»¥å­˜åœ¨ä¸€å¯¹å¤šçš„å…³ç³» åç¨‹ åç¨‹æ˜¯ä¸€ä¸ªå¯ä»¥æš‚åœæ‰§è¡Œä»¥ä¾¿ç¨åæ¢å¤çš„å‡½æ•° ã€‚ åç¨‹çš„æŒ‚èµ·å’Œæ¢å¤æ˜¯é€šè¿‡åç¨‹å¥æŸ„(ä¿å­˜æ‰§è¡Œçš„ä¸Šä¸‹æ–‡)æ¥å®ç°çš„ã€‚è€Œä¸æ˜¯é€šè¿‡é˜»å¡çº¿ç¨‹æ¥å®ç°ã€‚ çº¿ç¨‹å› ä¸ºæ˜¯linuxç³»ç»Ÿå†…æ ¸æä¾›ï¼Œæ‰€ä»¥ä»–æ˜¯æœ‰ç‹¬ç«‹çš„æ ˆç©ºé—´å’Œæ‰§è¡Œä¸Šä¸‹æ–‡çš„ã€‚è€Œåç¨‹åˆ™æ²¡æœ‰ï¼Œ å¤šä¸ªåç¨‹å¯èƒ½éƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œé¢è¿è¡Œï¼Œä»–æ˜¯ä¸€ä¸ªè½»é‡çº§çš„çº¿ç¨‹ã€‚ è¿›ç¨‹å’Œçº¿ç¨‹åˆ‡æ¢éƒ½ä¼šæœ‰å†…æ ¸æ€å’Œç”¨æˆ·æ€çš„åˆ‡æ¢ï¼Œè€Œåç¨‹åˆ™æ˜¯ç”¨æˆ·è‡ªå·±æ§åˆ¶åˆ‡æ¢çš„æ—¶æœºï¼Œå¹¶ä¸éœ€è¦åˆ‡æ¢è‡³å†…æ ¸æ€ï¼Œæ‰€ä»¥è¿™æ ·ä»¥æ¥æ‰§è¡Œæ•ˆç‡éå¸¸é«˜ é€‚åˆå¼‚æ­¥æ‰§è¡Œï¼ŒåŒæ­¥å†™æ³•å†™å¼‚æ­¥ä»£ç ï¼Œè®©å¼‚æ­¥ä»£ç æ›´åŠ ç®€æ´ c++20å¼•å…¥ä¸‰ä¸ªä¸åç¨‹ç›¸å…³çš„å…³é”®å­— co_awaitï¼šæš‚åœåç¨‹å¹¶ç­‰å¾…ä¸€ä¸ªæ“ä½œå®Œæˆ co_yield ï¼šè¿”å›ä¸€ä¸ªå€¼ç»™åç¨‹çš„è°ƒç”¨è€…ï¼Œå¹¶æš‚åœåç¨‹çš„æ‰§è¡Œ co_returnï¼šè¿”å›ä¸€ä¸ªå€¼å¹¶ç»ˆæ­¢åç¨‹ ä¸»ç¨‹åºä¸åç¨‹é—´ç”¨ promise è¿›è¡Œé€šä¿¡ï¼Œç±»ä¼¼ä¸ç®¡é“ LRU class Node{ public: int key, val; Node *pre, *next; Node(int key, int val) { this-&gt;key = key; this-&gt;val = val; pre = NULL; next = NULL; } }; class LRUCache { public: LRUCache(int capacity) { this-&gt;capacity = capacity; head = new Node(-1, -1); tail = new Node(-1, -1); head-&gt;next = tail; tail-&gt;pre = head; } void remove(Node *p) { p-&gt;pre-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = p-&gt;pre; } void insert(Node *p) { p-&gt;next = head-&gt;next; p-&gt;pre = head; head-&gt;next-&gt;pre = p; head-&gt;next = p; } int get(int key) { if(hash.find(key) == hash.end()) return -1; Node *p = hash[key]; remove(p); insert(p); return p-&gt;val; } void put(int key, int value) { if(hash.find(key) != hash.end()) { Node* p = hash[key]; p-&gt;val = value; remove(p); insert(p); } else { if(hash.size() == capacity) { Node *p = tail-&gt;pre; remove(p); hash.erase(p-&gt;key); delete p; p = NULL; } Node *p = new Node(key, value); hash[key] = p; insert(p); } } ~LRUCache() { while(head != NULL) { Node *nowNode = head; head = head-&gt;next; delete nowNode; nowNode = NULL; } } private: int capacity; Node *head, *tail; unordered_map&lt;int, Node*&gt; hash; }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ STL vector 1ã€åº•å±‚ï¼šåŠ¨æ€æ•°ç»„ã€‚å¯ä»¥è‡ªåŠ¨è°ƒæ•´å¤§å°ã€‚å®ƒä½¿ç”¨ä¸€å—è¿ç»­çš„å†…å­˜å—æ¥å­˜å‚¨å…ƒç´ ï¼Œå¯ä»¥é€šè¿‡æŒ‡é’ˆè¿ç®—æ¥å¿«é€Ÿè®¿é—®å…ƒç´ ã€‚ å½“éœ€è¦æ‰©å¤§å®¹é‡æ—¶ï¼Œä¼šé‡æ–°ç”³è¯·ä¸€å—æ›´å¤§çš„å†…å­˜ï¼Œå°†åŸæ¥çš„å…ƒç´ æ‹·è´åˆ°æ–°çš„å†…å­˜å—ä¸­ï¼Œå¹¶é‡Šæ”¾åŸæ¥çš„å†…å­˜ã€‚ å› æ­¤ï¼Œåœ¨æ’å…¥å’Œåˆ é™¤å…ƒç´ æ—¶ï¼Œå¯èƒ½éœ€è¦ç§»åŠ¨å†…å­˜å—ä¸­çš„å¾ˆå¤šå…ƒç´ ï¼Œå¯¼è‡´æ•ˆç‡ä½ä¸‹ï¼Œå½“ç„¶ï¼Œè¦çœ‹å®é™…æ“ä½œå¦‚ä½•ã€‚ 2ã€æ—¶é—´å¤æ‚åº¦ 2.1 è®¿é—®å…ƒç´ O(1)ï¼šæ”¯æŒéšæœºè®¿é—®ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥é€šè¿‡ä¸‹æ ‡æˆ–è€…è¿­ä»£å™¨ç›´æ¥è®¿é—®ä»»æ„ä½ç½®çš„å…ƒç´ ï¼›æŒ‡é’ˆè¿ç®—ç›´æ¥è·å–åœ°å€ã€‚ 2.2 æ’å…¥ã€åˆ é™¤ï¼šåœ¨æœ«å°¾æ’å…¥åˆ é™¤æ—¶é—´å¤æ‚åº¦ä¸ºO(1)ï¼Œä¸å­˜åœ¨æ•°æ®çš„ç§»åŠ¨ï¼›å…¶ä»–åœ°æ–¹çš„æƒ…å†µä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦å¹³å‡ä¸ºO(n)ã€‚ 2.3 æ‰©å®¹O(n)ï¼šå½“å®¹é‡capcity == sizeæ—¶éœ€è¦æ‰©å®¹ï¼Œç”³è¯·ä¸€å—æ–°çš„åœ°å€ç©ºé—´ï¼Œç„¶åå°†æ•°æ®æ‹·è´åˆ°æ–°çš„ç©ºé—´ä¸­ã€‚ vectorå®¹å™¨å¯¹è±¡ï¼Œåˆå§‹å®¹é‡é»˜è®¤ä¸º0ï¼ˆC++11ï¼‰ï¼Œå¦‚æœè¿›è¡Œæ•°æ®æ·»åŠ ä¸€æ¬¡ï¼Œæ­¤æ—¶ä¼šæ‰©å®¹ä¸º1ï¼›è‹¥æ˜¯å†ç»§ç»­æ·»åŠ å°±ä¼šæŒ‰ç…§å¢åŠ ä¸€å€çš„æ–¹å¼ç»§ç»­æ‰©å®¹ï¼ˆ2ã€4ã€8...ï¼‰ã€‚ 2.4 æŸ¥æ‰¾å…ƒç´ O(n) 3ã€ç›¸å…³é—®é¢˜ 3.1 vectorå†…éƒ¨å¦‚ä½•å®ç°åŠ¨æ€æ‰©å®¹ï¼Ÿ å½“å®¹é‡ä¸è¶³ä»¥å­˜å‚¨æ–°å…ƒç´ æ—¶ï¼Œä¼šåˆ†é…ä¸€ä¸ªæ›´å¤§çš„å†…å­˜å—ï¼Œå°†åŸæœ‰å…ƒç´ å¤åˆ¶åˆ°æ–°å†…å­˜ä¸­ï¼Œå¹¶é‡Šæ”¾åŸæ¥çš„ç©ºé—´ã€‚æ–°çš„å†…å­˜å—å¤§å°é€šå¸¸ä¸ºå½“å‰å®¹é‡çš„2å€æ•°ã€‚ 3.2 vectorå¦‚ä½•é¿å…å†…å­˜æµªè´¹ï¼Ÿ vectoré‡‡å–é¢„ç•™ç©ºé—´çš„æœºåˆ¶ï¼Œå³åœ¨æœªä½¿ç”¨å®Œå½“å‰å®¹é‡æ—¶ï¼Œå¯ä»¥é¢„ç•™ä¸€å®šçš„é¢å¤–ç©ºé—´ï¼Œé¿å…ä¸å¿…è¦çš„å†…å­˜é‡æ–°åˆ†é…ã€‚é€šè¿‡è°ƒç”¨reserve(newCapcity)å‡½æ•°å¯ä»¥æå‰åˆ†é…å¥½å†…å­˜å—çš„å¤§å°ã€‚ 3.3 vector&lt;int&gt;å’Œvector&lt;bool&gt; çš„å·®å¼‚æ˜¯ä»€ä¹ˆï¼Ÿ vector&lt;int&gt;æ˜¯å°†æ•´æ•°ç±»å‹å­˜å‚¨åœ¨è¿ç»­çš„å†…å­˜ä¸­ï¼Œæ¯ä¸ªå…ƒç´ éƒ½å ç”¨å›ºå®šå­—èŠ‚æ•°ã€‚ vector&lt;bool&gt;å®ç°ä¸ºä½å‘é‡ï¼Œæ¯ä¸ªå…ƒç´ éƒ½åªå ç”¨ä¸€ä¸ªäºŒè¿›åˆ¶ä½ï¼Œæœ€å°åŒ–å†…å­˜å ç”¨ã€‚ 3.4 vectorçš„è¿­ä»£å™¨å¤±æ•ˆæƒ…å†µæœ‰å“ªäº›ï¼Ÿ å½“vectorè¿›è¡Œæ’å…¥æˆ–è€…åˆ é™¤æ“ä½œæ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´æŒ‡å‘å…ƒç´ çš„è¿­ä»£å™¨å¤±æ•ˆã€‚å–å†³äºè¿™äº›ä½ç½®æ˜¯å¦å‘ç”Ÿäº†æ”¹å˜ï¼Œå¯èƒ½æœªæ”¹å˜ã€‚ 3.6 vectorå’Œarrayçš„åŒºåˆ«ï¼Ÿ vectoræ˜¯ä¸€ç§åŠ¨æ€æ•°ç»„ï¼Œå¯ä»¥åŠ¨æ€å¢åŠ å’Œåˆ é™¤å…ƒç´ ï¼› arrayæ˜¯ä¸€ç§é™æ€æ•°ç»„ï¼Œä¸€æ—¦å£°æ˜ä¹‹åå°±æ— æ³•æ”¹å˜å¤§å°ã€‚ æ­¤å¤–ï¼Œç”±äºarrayæ˜¯å›ºå®šå¤§å°çš„ï¼Œå› æ­¤å¯ä»¥åœ¨æ ˆä¸Šåˆ†é…ç©ºé—´ï¼Œæ¯”å †ä¸Šåˆ†é…çš„vectoræ›´å¿«ã€‚ åœ¨main()ä¸­å¼€ä¸€ä¸ªvector&lt;int&gt; vec(5)ï¼Œvecå¯¹è±¡æœ¬èº«åœ¨æ ˆä¸Šåˆ†é…ç©ºé—´ï¼Œä½†vecç®¡ç†çš„å†…å­˜ï¼Œä¹Ÿå°±æ˜¯vecä¸­çš„å…ƒç´ å®åœ¨å †ä¸Šåˆ†é…çš„ã€‚ â€‹ list 1ã€åº•å±‚ï¼šåŒå‘é“¾è¡¨ï¼Œå³æ¯ä¸ªèŠ‚ç‚¹éƒ½åŒ…å«æŒ‡å‘å‰é©±å’Œåç»§èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ä¸vectorä¸åŒï¼Œlistçš„å…ƒç´ åœ¨å†…å­˜ä¸­ä¸æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œå› æ­¤å¯ä»¥é«˜æ•ˆçš„æ’å…¥æˆ–è€…åˆ é™¤ä»»æ„ä½ç½®çš„å…ƒç´ ã€‚ 2ã€æ—¶é—´å¤æ‚åº¦ bool empty() constï¼š åˆ¤æ–­ list æ˜¯å¦ä¸ºç©ºï¼ŒO(1) size_type size() constï¼š è¿”å› list çš„å¤§å°ï¼ŒO(1) void resize(size_type sz, T c = T())ï¼š è°ƒæ•´ list å¤§å°ä¸º szï¼Œæ–°å¢çš„å…ƒç´ ä½¿ç”¨å€¼ c åˆå§‹åŒ–ï¼ŒO(n) void clear()ï¼š æ¸…ç©º listï¼ŒO(n) reference front()ï¼Œconst_reference front() constï¼š è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ï¼ŒO(1) reference back()ï¼Œconst_reference back() constï¼š è¿”å›æœ€åä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ï¼ŒO(1) void push_front(const T&amp; x)ï¼š åœ¨å¤´éƒ¨æ’å…¥å…ƒç´  xï¼ŒO(1) void push_back(const T&amp; x)ï¼š åœ¨å°¾éƒ¨æ’å…¥å…ƒç´  xï¼ŒO(1) void pop_front()ï¼š åˆ é™¤å¤´éƒ¨å…ƒç´ ï¼ŒO(1) void pop_back()ï¼š åˆ é™¤å°¾éƒ¨å…ƒç´ ï¼ŒO(1) iterator insert(iterator position, const T&amp; x)ï¼š åœ¨ position å‰é¢æ’å…¥å…ƒç´  xï¼ŒO(1) iterator erase(iterator position)ï¼š åˆ é™¤ position æŒ‡å‘çš„å…ƒç´ ï¼ŒO(1) void remove(const T&amp; val)ï¼š åˆ é™¤æ‰€æœ‰å€¼ä¸º val çš„å…ƒç´ ï¼ŒO(n) void reverse()ï¼š åè½¬ listï¼ŒO(n) void unique()ï¼š åˆ é™¤ç›¸é‚»é‡å¤çš„å…ƒç´ ï¼ŒO(n) void sort()ï¼š ä½¿ç”¨é»˜è®¤æ’åºè§„åˆ™ï¼ˆoperator&lt;ï¼‰å¯¹ list è¿›è¡Œæ’åºï¼ŒO(n log n) bool operator==(const list&amp; rhs) constï¼š åˆ¤æ–­ä¸¤ä¸ª list æ˜¯å¦ç›¸ç­‰ï¼ŒO(n) bool operator!=(const list&amp; rhs) constï¼š åˆ¤æ–­ä¸¤ä¸ª list æ˜¯å¦ä¸ç›¸ç­‰ï¼ŒO(n) æ€»ä½“æ¥è¯´ï¼Œlist åœ¨æ’å…¥ã€åˆ é™¤ã€åè½¬ã€æŸ¥æ‰¾ç­‰æ“ä½œæ–¹é¢è¡¨ç°ä¼˜ç§€ï¼Œè€Œåœ¨éšæœºè®¿é—®å’Œæ’åºæ–¹é¢åˆ™ä¸å¦‚ vector è¡¨ç°ã€‚ 3ã€ç›¸å…³é¢è¯•é¢˜ 3.1 ä¸vectorç›¸æ¯”ï¼Œlistæœ‰ä»€ä¹ˆä¼˜ç‚¹ï¼Ÿ ä¸»è¦ä¼˜ç‚¹æ˜¯æ”¯æŒé«˜æ•ˆåœ°åœ¨ä»»ä½•ä½ç½®æ·»åŠ æˆ–è€…åˆ é™¤èŠ‚ç‚¹å…ƒç´ ï¼Œä¸ä¼šå¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆï¼› ç¼ºç‚¹æ˜¯ä¸æ”¯æŒéšæœºè®¿é—®ï¼Œåªèƒ½é€šè¿‡è¿­ä»£å™¨æ¥è®¿é—®å…ƒç´ ï¼Œå¦å¤–ï¼Œç©ºé—´å ç”¨è¾ƒå¤§ã€‚ â€‹ dequeï¼ˆåŒç«¯é˜Ÿåˆ—double-ended queueï¼‰ 1ã€åº•å±‚ï¼šä¸€ä¸ªæˆ–è€…å¤šä¸ªè¿ç»­åœ°å­˜å‚¨å—ï¼Œæ¯ä¸ªå­˜å‚¨å—å†…éƒ¨æ˜¯ä¸€ä¸ªå›ºå®šå¤§å°åœ°æ•°ç»„ã€‚å½“dequeå®¹é‡ä¸è¶³æ—¶ï¼Œä¼šåˆ†é…æ–°çš„å­˜å‚¨å—ã€‚ è¿™ç§è®¾è®¡ä½¿å¾—dequeå¯ä»¥åœ¨ä¸¤ç«¯è¿›è¡Œå¸¸æ•°æ—¶é—´å¤æ‚åº¦çš„æ’å…¥å’Œåˆ é™¤æ“ä½œO(1)ï¼›åœ¨ä¸­é—´è¿›è¡Œçº¿æ€§æ—¶é—´å¤æ‚åº¦çš„æ’å…¥å’Œåˆ é™¤æ“ä½œO(n)ã€‚ 2ã€æ—¶é—´å¤æ‚åº¦ 2.1 å¤´æ’å°¾æ’ã€å¤´åˆ å°¾åˆ ï¼šO(1) 2.2 è®¿é—®å¤´å…ƒç´ å’Œå°¾å…ƒç´ O(1) 2.3 åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ O(n) æ€»çš„æ¥è¯´ï¼Œdequeçš„ä¼˜ç‚¹åœ¨äºæ”¯æŒé«˜æ•ˆçš„åœ¨ä¸¤ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œã€‚ä½†æ˜¯å¦‚æœå­˜å‚¨å—è¿‡å¤šä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ï¼Œå¯ç”¨å…¶ä»–å®¹å™¨æ›¿ä»£ã€‚ 3ã€å…³äºå­˜å‚¨å— å¦‚æœä¸€ä¸ªdequeä¸­çš„ä¸€ä¸ªå­˜å‚¨å—ä¸­çš„æ•°æ®è¢«æ¸…ç©ºäº†ï¼Œè¿™ä¸ªå­˜å‚¨å—è¿˜æ˜¯ä¼šå­˜åœ¨ç€ï¼Œå¹¶å æ®ä¸€å®šç©ºé—´ã€‚è¿™æ˜¯å› ä¸ºdequeçš„å®ç°é€šå¸¸ç”±å¤šä¸ªå­˜å‚¨å—ç»„æˆï¼Œæ¯ä¸ªå­˜å‚¨å—éƒ½ä¼šè¢«åˆ†é…ä¸€å®šç©ºé—´ã€‚å³ä½¿ä¸€ä¸ªå­˜å‚¨å—ä¸­çš„æ•°æ®è¢«åˆ é™¤äº†ï¼Œè¿™ä¸ªå­˜å‚¨å—ä»ç„¶ä¼šå­˜åœ¨ä¸ä¼šç«‹å³å›æ”¶è¿™äº›ç©ºé—²å­˜å‚¨å—ï¼Œåªæ˜¯å˜æˆäº†ç©ºé—²çŠ¶æ€ã€‚ä»¥å¤‡åç»­ç»§ç»­æ·»åŠ æ•°æ®ï¼Œé¿å…é¢‘ç¹å…ƒç´ æ•°æ®æ•°é‡å˜åŠ¨è¿›è¡Œå­˜å‚¨å—çš„åˆ†é…å’Œé‡Šæ”¾æ“ä½œã€‚ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå½“dequeä¸­çš„å…ƒç´ æ•°é‡å‡å°‘åˆ°æŸä¸€å®šç¨‹åº¦ï¼Œå®ç°ä¼šå°†å¤šä½™çš„å­˜å‚¨å—é‡Šæ”¾æ‰ï¼Œä»è€Œå‡å°‘å†…å­˜çš„å ç”¨ï¼Œè¿™ä¸ªé˜ˆå€¼å¯ä»¥æ˜¯å›ºå®šçš„ä¹Ÿå¯ä»¥åŠ¨æ€è°ƒæ•´ã€‚ 4ã€ç›¸å…³é—®é¢˜ 4.1 dequeä¼˜åŠ¿åœ¨å“ªï¼Ÿ å®ƒæ˜¯ä¸€ç§åŒç«¯é˜Ÿåˆ—å®¹å™¨ï¼Œå¯ä»¥åœ¨é˜Ÿåˆ—çš„ä¸¤ç«¯è¿›è¡Œå¿«é€Ÿæ’å…¥å’Œåˆ é™¤ã€‚ä¸vectorç›¸æ¯”ï¼Œdequeçš„æ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ›´åŠ ç¨³å®šï¼Œä¸å—æ’å…¥å’Œåˆ é™¤ä½ç½®çš„å½±å“ã€‚åŒæ—¶ï¼Œdequeæ”¯æŒéšæœºè®¿é—®å’Œè¿­ä»£å™¨æ“ä½œï¼Œå¯ä»¥å¿«é€Ÿå®šä½å…ƒç´ ï¼Œä½†æ˜¯ç›¸æ¯”äºvectorçš„å¿«é€Ÿå®šä½ä¼šæ›´æ…¢äº›ã€‚ 4.2 dequeå’ŒvectoråŒºåˆ«ï¼Ÿ åº•å±‚æ•°æ®ç»“æ„ï¼švectorä½¿ç”¨è¿ç»­å†…å­˜å—å­˜å‚¨å…ƒç´ ï¼Œè€Œdequeä½¿ç”¨å¤šä¸ªå›ºå®šå¤§å°çš„å­˜å‚¨å—ç»„æˆçš„åŒå‘é“¾è¡¨å­˜å‚¨å…ƒç´ ã€‚ æ’å…¥å’Œåˆ é™¤æ“ä½œï¼švectoræ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œé™¤äº†å°¾éƒ¨æ“ä½œï¼ˆO(1)ï¼‰.dequeä¸¤ç«¯æ“ä½œä¸ºO(1)ã€‚ è¿­ä»£å™¨å¤±æ•ˆï¼šå¯¹äºvectoråœ¨æ’å…¥å’Œåˆ é™¤æ—¶ï¼Œè¿­ä»£å™¨å¯èƒ½ä¼šå¤±æ•ˆï¼›è€Œdequeåªæœ‰åœ¨åˆ é™¤ä¸­é—´å…ƒç´ æ—¶ï¼Œè¿­ä»£å™¨æ‰ä¼šå¤±æ•ˆã€‚ 4.3 ä½¿ç”¨åœºæ™¯ éœ€è¦åœ¨ä¸¤ç«¯è¿›è¡Œé¢‘ç¹æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚ éœ€è¦å¯¹å¤§é‡å…ƒç´ è¿›è¡Œéšæœºè®¿é—®ã€‚ å½“å…ƒç´ æ•°é‡è¾ƒå¤§æ—¶ï¼Œä½¿ç”¨dequeå¯ä»¥é¿å…vectorçš„å†…å­˜ç®¡ç†é—®é¢˜å’Œè¿­ä»£å™¨å¤±æ•ˆé—®é¢˜ã€‚ â€‹ set 1ã€ä»‹ç»ï¼šä¸€ç§å…³è”å®¹å™¨ï¼Œå…¶ä¸­çš„å…ƒç´ æŒ‰ç…§ä¸€å®šçš„æ’åºè§„åˆ™è¿›è¡Œæ’åºï¼Œå¹¶ä¸”æ¯ä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ã€‚å› æ­¤å¯ä»¥ä½¿ç”¨setè¿›è¡Œå…ƒç´ çš„æŸ¥æ‰¾å’Œå»é‡æ“ä½œã€‚ 2ã€åº•å±‚ï¼šçº¢é»‘æ ‘ç»“æ„ï¼Œçº¢é»‘æ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘ï¼Œç›¸å¯¹äºå¹³è¡¡äºŒå‰æ ‘æ€§èƒ½æ›´ä¼˜ã€‚å¯ä»¥ç†è§£ä¸ºå¹³è¡¡äºŒå‰æ ‘æ˜¯å¯¹äºŒå‰æ’åºæ ‘çš„ä¼˜åŒ–ï¼Œçº¢é»‘æ ‘æ˜¯å¯¹å¹³è¡¡äºŒå‰æ ‘çš„ä¼˜åŒ–ï¼Œåœ¨è‡ªå¹³è¡¡ä¸Šæé«˜äº†æ€§èƒ½ã€‚ 3ã€æ—¶é—´å¤æ‚åº¦ 3.1 æ’å…¥å…ƒç´ (è‡ªæ’åº)ï¼šO(logn) 3.2 åˆ é™¤å…ƒç´ ï¼šO(logn) 3.3 æŸ¥æ‰¾å…ƒç´ ï¼šO(logn) 3.4 éå†ï¼šO(n) â€‹ multisetï¼šåŒsetçº¢é»‘æ ‘ç»“æ„ï¼Œåªæ˜¯å…è®¸æ•°æ®ç›¸åŒï¼Œä¸ä¼šå»é‡ã€‚ â€‹ unordered_set 1ã€ä»‹ç»ï¼šæ˜¯å“ˆå¸Œè¡¨å®ç°ï¼Œæä¾›äº†å¿«é€Ÿçš„å…ƒç´ æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤ç­‰æ“ä½œã€‚ 2ã€åº•å±‚ï¼šunordered_setåº•å±‚ä½¿ç”¨äº†å“ˆå¸Œè¡¨ï¼Œä¸€ç§æ ¹æ®å…³é”®å­—ç›´æ¥è®¿é—®å†…å­˜å­˜å‚¨ä½ç½®çš„æ•°æ®ç»“æ„ï¼Œå› æ­¤å…·å¤‡éå¸¸å¿«çš„æŸ¥æ‰¾å’Œæ’å…¥é€Ÿåº¦ã€‚å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªåŠ¨æ€æ•°ç»„å’Œä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œå“ˆå¸Œè¡¨ä¸­å­˜å‚¨ç€æŒ‡å‘åŠ¨æ€æ•°ç»„ä¸­å…ƒç´ çš„æŒ‡é’ˆã€‚æ¯ä¸ªå…ƒç´ çš„ä½ç½®æ˜¯ç”±å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ¥çš„ï¼Œä¸åŒçš„å…ƒç´ å¯èƒ½ä¼šè¢«æ˜ å°„åˆ°åŒä¸€ä¸ªä½ç½®ä¸Šï¼Œå› æ­¤å“ˆå¸Œè¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œç”¨äºè§£å†³å†²çªã€‚ 3ã€æ’å…¥æµç¨‹ä»‹ç»ï¼š æœ‰å…ƒç´ æ’å…¥ï¼Œæ ¹æ®è¯¥å…ƒç´ è®¡ç®—å‡ºè¯¥å…ƒç´ çš„å“ˆå¸Œå€¼ï¼Œè¿™ä¸ªå“ˆå¸Œå€¼ç›´æ¥å®šä½åˆ°å†…å­˜åœ°å€ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢åŠ¨æ€æ•°ç»„ä¸­çš„ä½ç½®ï¼ˆæ¡¶ï¼‰ï¼› å¦‚æœè¯¥ä½ç½®ä¸å­˜åœ¨ä»»ä½•å…ƒç´ ï¼Œé‚£ä¹ˆå°±æ’å…¥ï¼› ä½†æ˜¯ï¼Œå“ˆå¸Œå‡½æ•°è¡¨ç¤ºç»å¯¹å®Œç¾çš„ï¼Œå¯èƒ½ä¼šå‡ºç°å¤šä¸ªå…ƒç´ æ˜ å°„åˆ°åŒä¸€ä¸ªåœ°å€ï¼Œæ­¤æ—¶ï¼Œä¼šåœ¨æ¡¶ä¸­ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨ï¼Œå°†å“ˆå¸Œå€¼ç›¸åŒçš„å…ƒç´ å­˜å‚¨åœ¨åŒä¸€ä¸ªé“¾è¡¨ä¸­ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œè‹¥æ˜¯å†²çªè¿‡å¤šï¼ŒæŸ¥æ‰¾æ•ˆç‡ä¼šå˜ä½ã€‚ 4ã€æ—¶é—´å¤æ‚åº¦ 4.1 æ’å…¥ï¼šO(1); æœ€åO(n)ï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰å…ƒç´ å…¨éƒ¨æ˜ å°„åˆ°ä¸€ä¸ªåœ°å€ã€‚ 4.2 åˆ é™¤ï¼šO(1)ï¼›æœ€åO(n) 4.3 æŸ¥æ‰¾ï¼šO(1)ï¼›æœ€åO(n) 4.3 éå†ï¼šO(n) 5ã€ç‰¹ç‚¹ï¼š 5.1 å…ƒç´ æ— åº 5.2 ä¸å…è®¸æœ‰é‡å¤å…ƒç´ ï¼Œä¼šå»é‡ 5.3 å¯ä»¥è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ï¼Œç”¨æ¥è®¡ç®—å…ƒç´ çš„å“ˆå¸Œå€¼ã€‚åœ¨è‡ªå®šä¹‰ç±»å‹ä¸­å°±éœ€è¦è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ï¼Œç”¨äºæ¯”è¾ƒä¸¤ä¸ªå…ƒç´ æ—¶å€™ç›¸åŒã€‚ 6ã€ç›¸å…³é—®é¢˜ 6.1 å®ç°åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ é€šè¿‡å“ˆå¸Œè¡¨å®ç°ï¼Œå…·ä½“æ¥è¯´æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„å…ƒç´ éƒ½æ˜¯ä¸€ä¸ªé“¾è¡¨ã€‚å½“è¦æ’å…¥æˆ–è€…æŸ¥æ‰¾å…ƒç´ æ—¶ï¼Œé¦–å…ˆæ ¹æ®å…ƒç´ çš„å“ˆå¸Œå€¼å¾—åˆ°å®ƒåœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼Œç„¶ååœ¨å¯¹åº”é“¾è¡¨ä¸­è¿›è¡Œæ“ä½œã€‚ 6.2 ä½¿ç”¨åœºæ™¯ï¼Ÿ é€‚ç”¨äºéœ€è¦å¿«é€ŸæŸ¥æ‰¾å’Œæ’å…¥å…ƒç´ çš„åœºæ™¯ï¼Œå› ä¸ºå“ˆå¸Œè¡¨çš„æŸ¥æ‰¾å’Œæ’å…¥å¤æ‚åº¦éƒ½æ˜¯å¸¸æ•°çº§åˆ«ã€‚ 6.3 ä¸ºä»€ä¹ˆunordered_setçš„è¿­ä»£å™¨åªæ”¯æŒå‰å‘è¿­ä»£å™¨ï¼Ÿ å› ä¸ºåº•å±‚æ˜¯å“ˆå¸Œè¡¨ï¼Œæ¯ä¸ªæ¡¶ä¸­å¯èƒ½æœ‰å¤šä¸ªå…ƒç´ ï¼Œé‡‡ç”¨é“¾è¡¨æˆ–è€…çº¢é»‘æ ‘æ¥è§£å†³å“ˆå¸Œå†²çªã€‚æ¯ä¸ªæ¡¶å†…çš„å…ƒç´ æ˜¯æ— åºçš„ï¼Œä¸ä¼šæŒ‰ç…§ç”¨æˆ·çš„æ’å…¥é¡ºåºå­˜æ”¾ï¼Œå› æ­¤åªèƒ½å‘å‰éå†æ¯ä¸ªæ¡¶ä¸­çš„å…ƒç´ ã€‚æ­¤å¤–ï¼Œå†…éƒ¨çš„å­˜å‚¨ç»“æ„å¯èƒ½éšæ—¶å˜åŒ–ï¼Œå› æ­¤è¿­ä»£å™¨çš„é€’å¢è¿‡ç¨‹ä¹Ÿæ¯”è¾ƒå¤æ‚ï¼Œåªèƒ½å®ç°å‘å‰éå†ã€‚ â€‹ map 1ã€ä»‹ç»ï¼šæ˜¯ä¸€ä¸ªå…³è”å®¹å™¨ï¼Œç”¨äºå­˜å‚¨é”®å€¼å¯¹ï¼Œå…¶ä¸­çš„é”®å’Œå€¼éƒ½å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ã€‚æ¯ä¸ªé”®åœ¨mapä¸­éƒ½æ˜¯å”¯ä¸€çš„ï¼Œå†…éƒ¨é‡‡ç”¨çº¢é»‘æ ‘å®ç°ã€‚ 2ã€åº•å±‚ï¼šåº•å±‚ä½¿ç”¨çº¢é»‘æ ‘å®ç°ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ªé”®å€¼å¯¹pairï¼ŒæŒ‰ç…§é”®å€¼å…³ç³»æ„å»ºä¸€é¢—äºŒå‰æŸ¥æ‰¾æ ‘ã€‚ 3ã€æ—¶é—´å¤æ‚åº¦ï¼š æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ ï¼š O(logn); éå†O(n) è™½ç„¶èƒ½å¤Ÿè‡ªå¹³è¡¡ï¼Œä½†æ˜¯åœ¨æç«¯æƒ…å†µä¸‹ä¼šé€€åŒ–ä¸ºé“¾è¡¨ï¼Œæ¯”å¦‚æ’å…¥çš„æ•°æ®æœ‰åºã€‚ 4ã€ç‰¹æ€§ï¼š ç±»ä¼¼äºsetï¼Œæ ¹æ®é”®è‡ªåŠ¨æ’åºï¼›å¯è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ã€‚å¦‚æœæ’å…¥é”®ç›¸åŒçš„å…ƒç´ ï¼Œé‚£ä¹ˆä¹‹å‰çš„å€¼ä¼šè¢«æ›¿æ¢æˆæ–°æ’å…¥çš„ã€‚ 5ã€ç›¸å…³é—®é¢˜ 5.1 Map å’Œ unordered_map çš„åŒºåˆ«æ˜¯ä»€ä¹ˆ? Map å’Œ unordered_map éƒ½æ˜¯ C++ ä¸­çš„å…³è”å¼å®¹å™¨ï¼Œå®ƒä»¬çš„åŒºåˆ«åœ¨äºåº•å±‚çš„å®ç°æ–¹å¼ä¸åŒã€‚Map ä½¿ç”¨çº¢é»‘æ ‘æ¥å®ç°ï¼Œè€Œ unordered_map ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å®ç°ã€‚å› æ­¤ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œunordered_map çš„æŸ¥æ‰¾å’Œæ’å…¥æ“ä½œæ¯” Map æ›´å¿«ï¼Œä½†æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒMap çš„æ€§èƒ½å¯èƒ½ä¼šæ›´å¥½ã€‚ â€‹ multimapï¼šåŸºæœ¬åŒmapï¼Œä½†æ˜¯å¯ä»¥æ’å…¥é”®ç›¸åŒçš„å…ƒç´ ã€‚ â€‹ unordered_mapï¼ˆåº•å±‚ç±»ä¼¼äºunordered_set) 1ã€ä»‹ç»ï¼š unordered_mapï¼ˆæ— åºæ˜ å°„ï¼‰æ˜¯ä¸€ç§å…³è”å®¹å™¨ï¼Œç”¨äºå­˜å‚¨ç”±é”®å€¼å¯¹ç»„æˆçš„å…ƒç´ ã€‚å®ƒä½¿ç”¨å“ˆå¸Œè¡¨ä½œä¸ºåº•å±‚å®ç°ï¼Œå¯ä»¥å®ç°å¸¸æ•°æ—¶é—´å†…çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œå› æ­¤åœ¨éœ€è¦å¿«é€Ÿè®¿é—®å…ƒç´ çš„åœºæ™¯ä¸­å¾ˆæœ‰ç”¨ã€‚ 2ã€åº•å±‚ï¼šunordered_map çš„åº•å±‚å®ç°æ˜¯å“ˆå¸Œè¡¨ï¼Œå“ˆå¸Œè¡¨æ˜¯ä¸€ç§é€šè¿‡å“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°å€¼çš„æ•°æ®ç»“æ„ã€‚å“ˆå¸Œè¡¨é€šå¸¸åŒ…å«ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæ¡¶ï¼Œæ¡¶ä¸­å­˜æ”¾ç€å“ˆå¸Œå€¼ç›¸åŒçš„é”®å€¼å¯¹ã€‚ 3ã€æ—¶é—´å¤æ‚åº¦ æŸ¥æ‰¾ä¸€ä¸ªå…ƒç´ ï¼ˆoperator[]ã€atã€findï¼‰ï¼šå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œæœ€åæƒ…å†µä¸‹ä¸º O(n)ï¼› æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼ˆinsertï¼‰ï¼šå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œæœ€åæƒ…å†µä¸‹ä¸º O(n)ï¼› åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼ˆeraseï¼‰ï¼šå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œæœ€åæƒ…å†µä¸‹ä¸º O(n)ï¼› éå†æ‰€æœ‰å…ƒç´ ï¼ˆbegin/end/forï¼‰ï¼šæ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€‚ 4ã€ç›¸å…³é—®é¢˜ 4.1 unordered_map æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ unordered_map é€šå¸¸æ˜¯ä½¿ç”¨å“ˆå¸Œè¡¨å®ç°çš„ï¼Œå®ƒçš„é”®å’Œå€¼éƒ½å­˜å‚¨åœ¨æ¡¶ä¸­ã€‚å“ˆå¸Œè¡¨å°†é”®æ˜ å°„åˆ°æ¡¶ä¸­ï¼Œè¿™æ˜¯é€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºæ¥çš„ã€‚å½“å¤šä¸ªé”®è¢«æ˜ å°„åˆ°åŒä¸€ä¸ªæ¡¶æ—¶ï¼Œå®ƒä»¬å­˜å‚¨åœ¨é“¾è¡¨ä¸­ã€‚å½“é“¾è¡¨å˜å¾—å¤ªé•¿æ—¶ï¼Œå®ƒä»¬è¢«è½¬æ¢ä¸ºæ›´é«˜æ•ˆçš„æ•°æ®ç»“æ„ï¼Œå¦‚çº¢é»‘æ ‘ã€‚ 4.2 unordered_map çš„åº•å±‚æ•°æ®ç»“æ„æ˜¯ä»€ä¹ˆï¼Ÿ unordered_map çš„åº•å±‚æ•°æ®ç»“æ„æ˜¯å“ˆå¸Œè¡¨ï¼Œå…·ä½“å®ç°å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒï¼Œä½†é€šå¸¸åŒ…æ‹¬ä¸€ä¸ªæ¡¶æ•°ç»„å’Œä¸€ä¸ªå“ˆå¸Œå‡½æ•°ã€‚ 4.3 unordered_map çš„æ—¶é—´å¤æ‚åº¦æ˜¯ä»€ä¹ˆï¼Ÿ åœ¨å¹³å‡æƒ…å†µä¸‹ï¼Œunordered_map çš„æ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(1)ï¼Œä½†åœ¨æœ€åæƒ…å†µä¸‹ï¼Œè¿™äº›æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¼šé€€åŒ–åˆ° O(n)ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœå“ˆå¸Œå‡½æ•°äº§ç”Ÿçš„å“ˆå¸Œå†²çªå¤ªå¤šï¼Œå°±ä¼šå¯¼è‡´é“¾è¡¨å˜å¾—éå¸¸é•¿ï¼Œé™ä½äº†æ•ˆç‡ã€‚ â€‹ stack 1ã€ä»‹ç»ï¼šä¸€ç§å…ˆè¿›åå‡ºçš„å®¹å™¨ï¼Œå³æ ˆã€‚ 2ã€åº•å±‚ä½¿ç”¨dequeè¿›è¡ŒäºŒæ¬¡å°è£…ã€‚å› æ­¤å®ƒä¹Ÿå¯ä»¥åŠ¨æ€æ‰©å®¹ã€‚ â€‹ queue 1ã€ä»‹ç»ï¼šæ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ã€‚é˜Ÿåˆ—å®¹å™¨åœ¨ä»»åŠ¡é˜Ÿåˆ—ã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰åº”ç”¨ä¸­éå¸¸å¸¸è§ã€‚ 2ã€åº•å±‚ï¼šé€šå¸¸ä½¿ç”¨dequeä½œä¸ºå…¶åº•å±‚æ•°æ®ç»“æ„æ¥å®ç°ã€‚ä½†æ˜¯queueæ˜¯ä¸æ”¯æŒéšæœºè®¿é—®çš„ã€‚ â€‹ array 1ã€åº•å±‚ï¼šåº•å±‚æ˜¯C++çš„æ™®é€šæ•°ç»„ï¼Œæ˜¯å›ºå®šå¤§å°çš„ã€‚åˆå§‹åŒ–æ—¶éœ€è¦æŒ‡å®šå¤§å° å¼ºåˆ¶ç±»å‹è½¬æ¢ 1.é™æ€è½¬æ¢(static_cast)ï¼šå¯ä»¥ç”¨äºåŸºæœ¬æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œä¹Ÿå¯ä»¥å°†åŸºç±»æŒ‡é’ˆæˆ–å¼•ç”¨è½¬æ¢ä¸ºæ´¾ç”Ÿç±»æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œä½†æ˜¯è½¬æ¢æ—¶éœ€è¦ä¿è¯ç±»å‹è½¬æ¢æ˜¯å®‰å…¨çš„ã€‚é™æ€è½¬æ¢ä¸èƒ½ç”¨äºå»é™¤å¯¹è±¡çš„constã€volatileå±æ€§ã€‚ 2.åŠ¨æ€è½¬æ¢(dynamic_cast)ï¼šä¸»è¦ç”¨äºå°†åŸºç±»æŒ‡é’ˆæˆ–å¼•ç”¨è½¬æ¢ä¸ºæ´¾ç”Ÿç±»æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œä½†æ˜¯è½¬æ¢æ—¶éœ€è¦åˆ¤æ–­ç±»å‹è½¬æ¢æ˜¯å¦å®‰å…¨ï¼Œå¦‚æœä¸å®‰å…¨åˆ™è¿”å›ç©ºæŒ‡é’ˆã€‚åªæœ‰æŒ‡å‘å…·æœ‰å¤šæ€æ€§è´¨çš„ç±»çš„åŸºç±»æŒ‡é’ˆæˆ–å¼•ç”¨æ‰èƒ½ä½¿ç”¨dynamic_castã€‚ **å®‰å…¨ï¼š**åŸºç±»è‡³å°‘æœ‰ä¸€ä¸ªè™šå‡½æ•°ï¼ŒåŸºç±»æŒ‡é’ˆæŒ‡å‘çš„éœ€è¦æ˜¯æ´¾ç”Ÿç±»å¯¹è±¡ **ç”¨æ³•ï¼š**static_cast&lt;ç›®çš„ç±»å‹&gt;(è¡¨è¾¾å¼) åŸºç±»å’Œæ´¾ç”Ÿç±»ä¹‹é—´çš„è½¬æ¢â€“æ²¡æœ‰virtual class A { public: void fn() { cout &lt;&lt; &quot;A::fn&quot; &lt;&lt; endl; } void gn() { cout &lt;&lt; &quot;A::gn&quot; &lt;&lt; endl; } }; class B :public A { public: void fn() { cout &lt;&lt; &quot;B::fn&quot; &lt;&lt; endl; }//éšè—ï¼Œæ²¡æœ‰è™š void hn() { cout &lt;&lt; &quot;B::hn&quot; &lt;&lt; endl; } }; int main() { A a; B b; A* pa = &amp;b; pa-&gt;fn();//A pa-&gt;gn();//A // B* pb = &amp;a;//error B* pb = static_cast&lt;B*&gt;(&amp;a); pb-&gt;fn();//B pb-&gt;gn();//A pb-&gt;hn();//B pb-&gt;A::fn();//A } ä¸¤ä¸ªæ— å…³ç±» #include&lt;bits/stdc++.h&gt; using namespace std; class A { public: void fn() { cout &lt;&lt; &quot;A::fn&quot; &lt;&lt; endl; } }; class B { public: B(A&amp;a){}//æ„é€ å‡½æ•°å¯ä»¥è¿›è¡Œå¼ºè½¬ void gn() { cout &lt;&lt; &quot;B::gn&quot; &lt;&lt; endl; } }; int main() { A a; B b = static_cast&lt;B&gt;(a);//B b(a); b.gn(); } å…³é”®å­— volatileï¼š å…è®¸ä¿®é¥°çš„å˜é‡è¢«ä¸€äº›æœªçŸ¥çš„å¤–éƒ¨å› ç´ è®¿é—®ï¼Œå¦‚æ“ä½œç³»ç»Ÿå’Œç¡¬ä»¶ï¼Œæ‰€ä»¥è®¿é—®è¯¥å˜é‡æ—¶éƒ½ä¼šé‡æ–°ä»å†…å­˜ä¸­è¯»å–æ•°æ® volatile int iï¼› externï¼š ä½œç”¨1.å¯¹å˜é‡æˆ–å‡½æ•°è¿›è¡Œå£°æ˜ï¼Œè¡¨ç¤ºåœ¨åˆ«å¤„å®šä¹‰è¦åœ¨æ­¤å¤„å£°æ˜ã€‚ //config.cpp int globalConfig = 42; // main.cpp #include &lt;iostream&gt; extern int globalConfig; int main() { std::cout &lt;&lt; &quot;Global Config value is: &quot; &lt;&lt; globalConfig &lt;&lt; std::endl; return 0; } g++ -c config.cpp -o config.o g++ -c main.cpp -o main.o g++ config.o main.o -o program.exe //é“¾æ¥ ./program.exe å¦‚æœä¸å†™ â€œextern int globalConfig;â€ åˆ™ä¼šåœ¨ç¼–è¯‘çš„ç¼–è¯‘è¿‡ç¨‹ä¸­äº§ç”ŸæŠ¥é”™ ä½œç”¨2ï¼š æŒ‡ç¤º C æˆ–è€… C+ï¼‹å‡½æ•°çš„è°ƒâ½¤è§„èŒƒï¼Œ åœ¨ C++ ä¸­è°ƒç”¨ C åº“å‡½æ•°ï¼Œå°±éœ€è¦åœ¨ C++ ç¨‹åºä¸­ç”¨ extern â€œCâ€ å£°æ˜è¦å¼•ç”¨çš„å‡½æ•° ã€‚åŸå› å°±æ˜¯ C++ å’Œ C ç¨‹åºç¼–è¯‘å®Œæˆååœ¨ç›®æ ‡ä»£ç ä¸­å‘½åè§„åˆ™ä¸åŒ ç±»åªèƒ½åŠ¨æ€åˆ†é…å’Œåªèƒ½é™æ€åˆ†é… **åŠ¨æ€åˆ†é…ï¼š**å°†ææ„å‡½æ•°è®¾ç½®ä¸ºprotectedç±»å‹ï¼Œå› ä¸ºåœ¨æ ˆä¸Šåˆ†é…ç©ºé—´ä¼šå…ˆæ£€æŸ¥ææ„å‡½æ•°æ˜¯å¦å¯è®¿é—®ï¼Œä¸å¯è®¿é—®ä¼šæ‹’ç»ç”³è¯· **é™æ€åˆ†é…ï¼š**å°†newè¿ç®—ç¬¦è®¾ç½®ä¸ºç§æœ‰ï¼Œç¦ç”¨ class A { private: void* operator new(size_t t){} //æ³¨æ„å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°å’Œè¿”å›å€¼éƒ½æ˜¯å›ºå®šçš„ void operator delete(void* ptr){} //é‡è½½äº†newå°±éœ€è¦é‡è½½delete }; å †æ’åº #include&lt;bits/stdc++.h&gt; using namespace std; void keep_heap(vector&lt;int&gt; &amp;v, int n, int node) { int left = node * 2 + 1; int right = node * 2 + 2; if(left &gt; n - 1) return; if(right &gt; n - 1) { if(v[node] &lt; v[left]) { swap(v[node], v[left]); keep_heap(v, n, left); } } else { if(v[left] &gt; v[node] &amp;&amp; v[left] &gt;= v[right]) { swap(v[node], v[left]); keep_heap(v, n, left); } else if(v[right] &gt; v[node] &amp;&amp; v[right] &gt;= v[left]) { swap(v[node], v[right]); keep_heap(v, n, right); } } } void big_heap(vector&lt;int&gt; &amp;v) { int node = v.size() / 2 - 1; while(node &gt;= 0) { keep_heap(v, v.size(), node); node--; } } void heap_sort(vector&lt;int&gt; &amp;v) { big_heap(v); int n = v.size(); for(int i = n - 1; i &gt;= 0; i--) { swap(v[0], v[i]); n--; keep_heap(v, n, 0); } } int main() { vector&lt;int&gt; v = {91,60,96,13,35,65,46,65,10,30,20,31,77,81,22}; heap_sort(v); for (auto it : v) cout &lt;&lt; it &lt;&lt; &quot; &quot;; return 0; } å¸Œå°”æ’åº // å¸Œå°”æ’åº void shellSort(vector&lt;int&gt;&amp; nums) { for (int gap = nums.size() / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; nums.size(); ++i) { for (int j = i; j - gap &gt;= 0 &amp;&amp; nums[j - gap] &gt; nums[j]; j -= gap) { swap(nums[j - gap], nums[j]); } } } } ç¼–è¯‘è¿‡ç¨‹ **é¢„å¤„ç†ï¼š**å±•å¼€æ‰€æœ‰å®ã€åˆ é™¤æ³¨é‡Šç­‰ã€‚å°† .c æ–‡ä»¶è½¬æ¢ä¸º .i æ–‡ä»¶ ç¼–è¯‘ï¼š æŠŠé¢„å¤„ç†å®Œçš„æ–‡ä»¶è¿›è¡Œä¸€ç³»åˆ—è¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æä»¥åŠä¼˜åŒ–åç”Ÿæˆç›¸åº”çš„æ±‡ç¼–ä»£ç æ–‡ä»¶ï¼Œ.i è½¬æ¢ä¸º .s æ±‡ç¼–ï¼šå°†æ±‡ç¼–è¯­è¨€è½¬æ¢ä¸ºæœºå™¨æŒ‡ä»¤(äºŒè¿›åˆ¶)ï¼Œ.s è½¬æ¢ä¸º .o é“¾æ¥ï¼šå°†æ‰€æœ‰ .o æ–‡ä»¶å’Œåº“é“¾æ¥åœ¨ä¸€èµ·ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚.o è½¬æ¢ä¸º .out é™æ€é“¾æ¥åº“å’ŒåŠ¨æ€é“¾æ¥åº“ é™æ€é“¾æ¥åº“æ˜¯æŠŠlibæ–‡ä»¶ä¸­ç”¨åˆ°çš„å‡½æ•°ä»£ç ç›´æ¥é“¾æ¥è¿›ç›®æ ‡ç¨‹åºï¼Œè¿è¡Œæ—¶å°±ä¸éœ€è¦å…¶å®ƒçš„åº“æ–‡ä»¶ åŠ¨æ€é“¾æ¥åº“æ˜¯æŠŠè°ƒç”¨å‡½æ•°æ‰€åœ¨çš„DLLæ–‡ä»¶å’Œå‡½æ•°åœ¨æ–‡ä»¶ä¸­çš„ä½ç½®ç­‰ä¿¡æ¯é“¾æ¥è¿›ç›®æ ‡ç¨‹åºï¼Œè¿è¡Œæ—¶æŸ¥æ‰¾ç›¸å…³ä»£ç  æ¨¡æ¿ éç±»å‹æ¨¡æ¿å‚æ•° template&lt;unsigned int N, unsigned int M&gt; void compare(char (&amp;p1) [N], char (&amp;p2) [M]){ cout &lt;&lt; N &lt;&lt; ' ' &lt;&lt; M &lt;&lt; '\\n'; } ä½¿ç”¨ compare(â€œhiâ€, â€œmomâ€)ä¼šå®ä¾‹åŒ–æˆ compare(char (&amp;p1) [3], char (&amp;p2) [4]) å› ä¸ºä¼šåœ¨å­—ç¬¦ä¸²å­—é¢å¸¸é‡æœ«å°¾æ’å…¥ä¸€ä¸ª â€˜\\0â€™ ç±»æ¨¡æ¿è¢«å®ä¾‹åŒ–æ—¶ï¼Œæˆå‘˜å˜é‡ä¼šè¢«å®ä¾‹åŒ–ï¼Œè€Œæˆå‘˜å‡½æ•°éœ€è¦åœ¨ä½¿ç”¨æ—¶æ‰ä¼šè¢«å®ä¾‹åŒ–ã€‚ å¯å˜å‚æ•°æ¨¡æ¿ å¯å˜å‚æ•°å‡½æ•°é€šå¸¸æ˜¯é€’å½’çš„ #include&lt;bits/stdc++.h&gt; using namespace std; template&lt;typename T&gt; void print(const T &amp;t) { cout &lt;&lt; t &lt;&lt; ' '; } template&lt;typename T, typename... Args&gt; void print(const T &amp;t, const Args&amp;... args) { cout &lt;&lt; t &lt;&lt; ' '; print(args...); //å‡½æ•°å‚æ•°å±•å¼€ï¼Œç­‰ä»·äºprint(a1, args(a2,a3,...,an)) } template&lt;typename... Args&gt; void write(const Args&amp;... args) { (print(args), ...);//æŠ˜å è¡¨è¾¾å¼ï¼Œéœ€è¦ä½¿ç”¨åˆ†éš”ç¬¦éš”å¼€ //ç­‰ä»·äº print(a1),print(a2),...,print(an) } int main() { print(1, 2, 6.1, &quot;abc&quot;);//è¾“å‡º 1, 2, 6.1, &quot;abc&quot; write(1, 2, 6.1, &quot;abc&quot;);//è¾“å‡º 1, 2, 6.1, &quot;abc&quot; return 0; } æ¨¡æ¿ç‰¹ä¾‹åŒ– template &lt;typename T, int Line, int Column&gt; // (1) class Matrix; template &lt;typename T&gt; // (2) class Matrix&lt;T, 3, 3&gt;{}; template &lt;&gt; // (3) class Matrix&lt;int, 3, 3&gt;{}; ä¸»æ¨¡æ¿ ç¬¬ (1) è¡Œæ˜¯ä¸»æ¨¡æ¿ã€‚ä¸»æ¨¡æ¿å¿…é¡»åœ¨éƒ¨åˆ†æˆ–å…¨ç‰¹åŒ–æ¨¡æ¿ä¹‹å‰å£°æ˜ã€‚å¦‚æœä¸éœ€è¦ä¸»æ¨¡æ¿ï¼Œåƒç¬¬ (1) è¡Œè¿™æ ·çš„å£°æ˜å°±å¯ä»¥äº†ã€‚ åç‰¹åŒ– ç¬¬ (2) è¡Œæ˜¯åç‰¹åŒ–æ¨¡æ¿ã€‚åªæœ‰ç±»æ¨¡æ¿æ”¯æŒåç‰¹åŒ–ã€‚ä¸€ä¸ªåç‰¹åŒ–æ¨¡æ¿æœ‰æ¨¡æ¿å½¢å‚å’Œæ˜ç¡®æŒ‡å®šçš„æ¨¡æ¿å®å‚ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç±» Matrix çš„ T æ˜¯æ¨¡æ¿å½¢å‚ï¼Œæ•°å­—æ˜¯æ¨¡æ¿å®å‚ã€‚ å…¨ç‰¹åŒ– ç¬¬ (3) è¡Œæ˜¯å…¨ç‰¹åŒ–æ¨¡æ¿ã€‚â€œå…¨â€æ„å‘³ç€æ‰€æœ‰çš„æ¨¡æ¿å®å‚éƒ½å·²æ˜ç¡®ï¼Œæ¨¡æ¿å½¢å‚åˆ—è¡¨ä¸ºç©ºï¼šæ­£å¦‚ç¬¬ (3) è¡Œçš„ template &lt;&gt; æ‰€ç¤ºã€‚ ä½¿ç”¨æ¨¡æ¿ç‰¹ä¾‹åŒ–ï¼Œåˆ¤æ–­ä¸¤ä¸ªæ•°æ®ç±»å‹æ˜¯å¦ç›¸åŒ // ä¸»æ¨¡æ¿å®šä¹‰ template&lt;class T1, class T2&gt; class my_is_same { public: operator bool() { // é‡è½½éšå¼è½¬æ¢ return false; } }; // ç‰¹ä¾‹åŒ–å®šä¹‰ï¼Œå½“ä¸¤ä¸ªç±»å‹å‚æ•°ç›¸åŒ template&lt;class T1&gt; class my_is_same&lt;T1, T1&gt; { public: operator bool() { return true; } }; int main() { // ä½¿ç”¨ my_is_same æ¥åˆ¤æ–­ä¸¤ä¸ªç±»å‹æ˜¯å¦ç›¸åŒ std::cout &lt;&lt; std::boolalpha &lt;&lt; my_is_same&lt;int, float&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; my_is_same&lt;int, int&gt;() &lt;&lt; std::endl; return 0; } ç±»å‹æ“¦é™¤ ç±»å‹æ“¦é™¤æŒ‡çš„æ˜¯é€šè¿‡ä¸€äº›æŠ€æœ¯æ“¦é™¤c++çš„ç±»å‹ä¿¡æ¯ï¼Œä½¿å¾—ä¸€ä¸ªæ•°æ®ç»“æ„æˆ–ç®—æ³•èƒ½å¤Ÿåº”ç”¨äºä¸åŒç±»å‹çš„æ•°æ® æŠ€æœ¯æ˜¯é€šè¿‡æ¨¡æ¿å’Œå¤šæ€(çˆ¶ç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡) c++å†…å­˜åˆ†åŒº å…¨å±€é™æ€åŒºã€å¸¸é‡åŒºã€ä»£ç åŒºã€å †åŒºã€æ ˆåŒº å †å’Œæ ˆçš„åŒºåˆ« **å †ï¼š**éœ€è¦æ‰‹åŠ¨åˆ†é…å†…å­˜ï¼Œä½åœ°å€å‘é«˜åœ°å€æ‰©å±•ã€‚ä¸è¿ç»­å†…å­˜ç©ºé—´ï¼Œä¼šäº§ç”Ÿå†…å­˜ç¢ç‰‡ã€‚ **æ ˆï¼š**è‡ªåŠ¨åˆ†é…å†…å­˜ï¼Œé«˜åœ°å€å‘ä½åœ°å€æ‰©å±•ã€‚è¿ç»­å†…å­˜ç©ºé—´ï¼Œä¸ä¼šäº§ç”Ÿå†…å­˜ç¢ç‰‡ã€‚ sizeof sizeof æ˜¯è¿ç®—ç¬¦ int i = 1; cout &lt;&lt; i &lt;&lt; '\\n';//1 cout &lt;&lt; sizeof(++i) &lt;&lt; '\\n';//4 cout &lt;&lt; i &lt;&lt; '\\n';//1 å› ä¸ºsizeofä¼šåœ¨ç¼–è¯‘æ—¶ç¡®å®šå¤§å° union unionå˜é‡å…±ç”¨å†…å­˜ union u { int a; int b; }; union u mu; mu.a = 1; cout &lt;&lt; mu.b;//è¾“å‡ºï¼šmu.b = 1 å ç”¨å†…å­˜ä¸ºæœ€å¤§çš„å˜é‡ç±»å‹æ‰€å ç”¨å†…å­˜çš„æ•´æ•°å€ union u { char a[9]; //9*1=9å­—èŠ‚ int b[3]; //3*4=12å­—èŠ‚ double c; //8å­—èŠ‚ }; cout &lt;&lt; sizeof(union u);// è¾“å‡º16 #8*2=16å¤§äºä»»æ„å˜é‡æ‰€éœ€å­—èŠ‚æ•° å¤§ç«¯å°ç«¯ åœ¨unionä¸­ï¼Œæ•°æ®éƒ½æ˜¯ä»ä½åœ°å€å¼€å§‹å­˜æ”¾ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ¥åˆ¤æ–­æ˜¯å¤§ç«¯è¿˜æ˜¯å°ç«¯ union A{ char a; int b; /* char å ä¸€ä¸ªå­—èŠ‚,intå å››ä¸ªå­—èŠ‚ æ‰€ä»¥è”åˆä½“çš„å¤§å°ä¸ºå››ä¸ªå­—èŠ‚,ä¸”a bå…¬ç”¨ä¸€å—å†…å­˜ å½“å¯¹bèµ‹å€¼ä¸º1æ—¶,åˆ™b=0x00 00 00 01; ====ã€‹æ•°æ®ä»é«˜åˆ°ä½ åœ°å€ä»ä½åˆ°é«˜ å½“ä¸ºå¤§ç«¯æ¨¡å¼æ—¶:è¯»å–aå¾—åˆ°çš„å€¼ä¸º0; ====ã€‹ä½ä½åœ°å€é«˜ä½æ•°æ® å½“ä¸ºå°ç«¯æ¨¡å¼æ—¶:è¯»å–aå¾—åˆ°çš„å€¼ä¸º1; ====ã€‹ä½ä½åœ°å€ä½ä½æ•°æ® */ }; union { int a; char b[2]; char c; } u; int main() { u.a = 0; u.b[0] = 0x10; u.b[1] = 0x11; cout &lt;&lt; hex &lt;&lt; u.a &lt;&lt; '\\n';//1110ï¼Œb[0]æ˜¯ä½ä½ï¼Œb[1]æ˜¯é«˜ä½ u.c = 0x22; cout &lt;&lt; hex &lt;&lt; u.a &lt;&lt; '\\n';//1122ï¼Œcå ç”¨b[0]çš„ä½ç½® return 0; } #include &lt;iostream&gt; using namespace std; union{ int a; char b[3]; }u; int main() { u.a = 0; u.b[0] = 0x1; u.b[1] = 0x2; u.b[2] = 0x3; cout &lt;&lt; hex &lt;&lt; u.a;//è¾“å‡º30201 return 0; } new new å¯ä»¥åœ¨æŒ‡å®šåœ°å€ä¸Šè¿›è¡Œè°ƒç”¨ ä¸€èˆ¬ç”¨äºåœ¨é¢„åˆ†é…çš„å†…å­˜å—ä¸­åˆ†é…å¯¹è±¡ #include &lt;iostream&gt; class MyClass { public: MyClass() { std::cout &lt;&lt; &quot;Constructor called.&quot; &lt;&lt; std::endl; } ~MyClass() { std::cout &lt;&lt; &quot;Destructor called.&quot; &lt;&lt; std::endl; } }; int main() { char buffer[sizeof(MyClass)]; // é¢„åˆ†é…å†…å­˜ MyClass* obj = new (buffer) MyClass(); // åœ¨æŒ‡å®šåœ°å€ä¸Šæ„é€ å¯¹è±¡ obj-&gt;~MyClass(); // æ˜¾å¼è°ƒç”¨ææ„å‡½æ•° // å¦‚æœ buffer æ˜¯åŠ¨æ€åˆ†é…çš„ï¼Œè¿˜éœ€è¦æ‰‹åŠ¨é‡Šæ”¾å†…å­˜ return 0; }","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"å†™ä¸€ä¸ªå‡½æ•°åœ¨ main å‡½æ•°æ‰§â¾å‰å…ˆè¿â¾","slug":"3","date":"2024-04-16T10:37:55.467Z","updated":"2024-04-16T10:46:40.678Z","comments":true,"path":"2024/04/16/3/","link":"","permalink":"/2024/04/16/3/","excerpt":"","text":"//ç¬¬â¼€ç§ï¼šgccæ‰©å±•ï¼Œæ ‡è®°è¿™ä¸ªå‡½æ•°åº”å½“åœ¨mainå‡½æ•°ä¹‹å‰æ‰§â¾ã€‚åŒæ ·æœ‰â¼€ä¸ª__attribute((destructor))ï¼Œæ ‡è®°å‡½ //æ•°åº”å½“åœ¨ç¨‹åºç»“æŸä¹‹å‰ï¼ˆmainç»“æŸä¹‹åï¼Œæˆ–è€…è°ƒâ½¤äº†exitåï¼‰æ‰§â¾; __attribute((constructor))void before() { printf(&quot;before main 1\\n&quot;); } //ç¬¬â¼†ç§ï¼šå…¨å±€ static å˜é‡çš„åˆå§‹åŒ–åœ¨ç¨‹åºåˆå§‹é˜¶æ®µï¼Œå…ˆäº main å‡½æ•°çš„æ‰§â¾ int test1(){ cout &lt;&lt; &quot;before main 2&quot; &lt;&lt; endl; return 1; } static int i = test1(); // ç¬¬ä¸‰ç§ï¼šçŸ¥ä¹â¼¤â½œ Milo Yip çš„å›ç­”åˆ©â½¤ lambda è¡¨è¾¾å¼ int a = []() { cout &lt;&lt; &quot;before main 3&quot; &lt;&lt; endl; return 0; }(); int main(int argc, char** argv) { cout &lt;&lt; &quot;main function&quot; &lt;&lt;endl; return 0; } è¾“å‡º before main 2 before main 3 before main 1 main function å…¶ä¸­ 2 å’Œ 3 å–å†³äºè°ƒç”¨ä½ç½®","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[{"name":"c++","slug":"c","permalink":"/tags/c/"}],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"å­æ•°ç»„å’Œä¸º0è®¡æ•°","slug":"2","date":"2024-04-04T13:45:51.399Z","updated":"2024-06-04T06:50:22.584Z","comments":true,"path":"2024/04/04/2/","link":"","permalink":"/2024/04/04/2/","excerpt":"","text":"B. Eugene and an arrayï¼ˆä¸€ä¸ªæ•°ç»„ä¸­ï¼Œæ±‚å’Œä¸º0çš„å­æ•°ç»„çš„æ•°é‡ï¼‰ https://codeforces.ml/group/DOZ49JViPG/contest/380948/problem/B é¢˜æ„ï¼šå®šä¹‰ä¸€ä¸ªæ•°ç»„ä¸º good array å¦‚æœè¯¥æ•°ç»„çš„æ‰€æœ‰å­æ•°ç»„å’Œéƒ½ä¸ä¸º 0 æ±‚ä¸€ä¸ªæ•°ç»„ä¸­æœ‰å¤šå°‘ä¸ªå­æ•°ç»„æ˜¯ good arrayã€‚ æ€è·¯ï¼šè¿ç”¨å‰ç¼€å’ŒæŸ¥æ‰¾å‡ºå’Œä¸º 0 çš„å­æ•°ç»„ï¼Œè‹¥å‰ç¼€ pre[i] ä¹‹å‰å­˜åœ¨ä¸€ä¸ªç›¸åŒçš„ pre[j] (j &lt; i)ï¼Œ åˆ™å­æ•°ç»„ [j, i] çš„å’Œä¸º 0, è‹¥ pre[i] == 0ï¼Œ åˆ™å…¶æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå’Œä¸º 0 çš„å­æ•°ç»„ã€‚ #include&lt;bits/stdc++.h&gt; #define ll long long #define ull unsigned long long #define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); using namespace std; const ll N = 2e5 + 5; ll n, pre[N]; map&lt;ll, ll&gt; mp;//è®°å½•å‰ç¼€å’Œç›¸åŒçš„æœ€å³è¾¹çš„ä½ç½® void solve() { cin &gt;&gt; n; ll ans =n * (n + 1) / 2;//ç­”æ¡ˆæœ€å¤§å€¼ä¸º n * (n + 1) / 2, åç»­å¤„ç†åˆ é™¤ä¸ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ ll l = 0;//ç”¨læ ‡è®°å·¦è¾¹å·²ç»å¤„ç†åˆ°çš„ä½ç½®ï¼Œlå‰é¢çš„æ— éœ€å¤„ç†ï¼Œå¦åˆ™ä¼šé€ æˆé‡å¤å­æ•°ç»„çš„åˆ é™¤ for (ll i = 1, x; i &lt;= n; i++) { cin &gt;&gt; x; pre[i] = pre[i - 1] + x;//é¢„å¤„ç†å‰ç¼€å’Œ } for (ll i = 1; i &lt;= n; i++) { if (mp[pre[i]] + 1 &gt; l &amp;&amp; (mp[pre[i]] || !pre[i]))//è¦åˆ é™¤[mp[pre[i]] + 1, i]çš„å­æ•°ç»„ï¼Œè‹¥mp[pre[i]] + 1 &gt; låˆ™å½“å‰å¯åˆ é™¤ä¸ºåˆ é™¤è¿‡çš„å­æ•°ç»„(åˆ é™¤åŒºé—´[l, mp[pre[i]] + 1 &gt; l]ä¸­çš„éƒ¨åˆ†å…ƒç´ ) { ans -= (mp[pre[i]] - l + 1) * (n - i + 1);//åˆ é™¤ä¸ç¬¦åˆæ¡ä»¶å¹¶ä¸”æ²¡æœ‰åˆ è¿‡çš„å­æ•°ç»„ l = mp[pre[i]] + 1;//å°†læ›´æ–°è‡³æœ€å³è¾¹ï¼Œ ç«¯ç‚¹åœ¨å·¦è¾¹ä¸ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„å‡å·²åˆ é™¤ } mp[pre[i]] = i; } cout &lt;&lt; ans &lt;&lt; '\\n'; }","categories":[{"name":"é¢˜ç›®","slug":"é¢˜ç›®","permalink":"/categories/é¢˜ç›®/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"/tags/codeforces/"}],"keywords":[{"name":"é¢˜ç›®","slug":"é¢˜ç›®","permalink":"/categories/é¢˜ç›®/"}]},{"title":"LCAç®—æ³•æ¿å­","slug":"1","date":"2024-03-25T09:54:14.393Z","updated":"2024-06-04T06:48:47.093Z","comments":true,"path":"2024/03/25/1/","link":"","permalink":"/2024/03/25/1/","excerpt":"","text":"LCA tarjan #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll N = 5e5 + 7; vector&lt;ll&gt; G[N], Q[N]; ll ans[N][3], fa[N], n, m, s; ll vis[N]; void init() { for (ll i = 0; i &lt; N; i++) fa[i] = i; } int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); } void tarjan(int u) { vis[u] = 1;//æ ‡è®°è¯¥ç‚¹å·²è¢«è®¿é—® for (auto i : Q[u]) { if (vis[ans[i][1]] &amp;&amp; vis[ans[i][0]]) ans[i][2] = find(ans[i][0] == u ? ans[i][1] : ans[i][0]); } for (auto v : G[u]) {//çˆ¶äº²æ˜¯é è¿‘æ ¹èŠ‚ç‚¹çš„èŠ‚ç‚¹ if (vis[v]) continue; tarjan(v); fa[v] = u;//vçš„å­èŠ‚ç‚¹å·²å…¨éƒ¨è®¿é—®å®Œ } } signed main() { init(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;//é¡¶ç‚¹æ•°ã€è¯¢é—®æ¬¡æ•°ã€æ ¹èŠ‚ç‚¹ for (int i = 1, x, y; i &lt; n; i++) cin &gt;&gt; x &gt;&gt; y, G[x].push_back(y), G[y].push_back(x);//å­˜å›¾ for (int i = 1; i &lt;= m; i++)//å­˜è¯¢é—® { cin &gt;&gt; ans[i][0] &gt;&gt; ans[i][1]; Q[ans[i][0]].push_back(i); Q[ans[i][1]].push_back(i); } tarjan(s); for (int i = 1; i &lt;= m; i++) cout &lt;&lt; ans[i][2] &lt;&lt; '\\n'; return 0; } å€å¢ ä¸¤ä¸ªèŠ‚ç‚¹åˆ°è¾¾åŒä¸€èŠ‚ç‚¹åï¼Œä¸è®ºæ€ä¹ˆå‘ä¸Šèµ°ï¼Œè¾¾åˆ°çš„æ˜¾ç„¶è¿˜æ˜¯åŒä¸€èŠ‚ç‚¹ int fa[21][N], dep[N]; void dfs(int x, int pre, int d)//æ‰¾åˆ°æ¯ä¸ªèŠ‚ç‚¹çˆ¶äº²ä¸æ·±åº¦ { fa[0][x] = pre; dep[x] = d; for(auto &amp;to : g[x]) if(to != pre) dfs(to, x, d + 1); } int LCA(int u, int v) { if(dep[u] &gt; dep[v]) swap(u, v); int temp = dep[v] - dep[u];//å°†u vç§»åˆ°åŒä¸€æ·±åº¦ for(int i = 0; ((1 &lt;&lt; i) &lt;= temp); i++) if((1 &lt;&lt; i) &amp; temp) v = fa[i][v]; if(u == v) return u; for(int i = log2(n); i &gt;= 0; i--)//ä¸¤ä¸ªèŠ‚ç‚¹ä¸€èµ·å¾€ä¸Šèµ° { //æœ€å¤šåˆæ³•çš„è·³è·ƒæ˜¯ 2 ^ log2(n) if(fa[i][u] != fa[i][v])//å¦‚æœç›¸åŒåˆ™ä»£è¡¨è·³çš„å¤ªå¤šäº† { u = fa[i][u]; v = fa[i][v]; } } return fa[0][u]; } void init_LCA()// æ³¨æ„æ ¹èŠ‚ç‚¹æ˜¯ä»€ä¹ˆï¼Œdfs é»˜è®¤æ˜¯æ ¹èŠ‚ç‚¹æ˜¯ 1 { for(int j = 0; j &lt;= 20; j++) for( int i = 1; i &lt;= n; i++) fa[j][i] = 0; dfs(root, -1, 0); for(int j = 0; (1 &lt;&lt; j) &lt;= n; j++)//é¢„å¤„ç†å‡ºæ¯ä¸ªèŠ‚ç‚¹å¾€ä¸Šèµ°2^jæ‰€åˆ°çš„èŠ‚ç‚¹ï¼Œè¶…è¿‡æ ¹èŠ‚ç‚¹è®°ä¸º-1 { for(int i = 1; i &lt;= n; i++) { if(fa[j][i] &lt; 0) fa[j + 1][i] = -1; else fa[j + 1][i] = fa[j][fa[j][i]]; } } }","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]},{"title":"DP","slug":"8","date":"2023-01-01T07:30:57.361Z","updated":"2024-06-04T08:06:14.016Z","comments":true,"path":"2023/01/01/8/","link":"","permalink":"/2023/01/01/8/","excerpt":"","text":"å•è°ƒé˜Ÿåˆ—ä¼˜åŒ– å•è°ƒé˜Ÿåˆ—(æ»‘åŠ¨çª—å£)ä¼˜åŒ–åŠ¨æ€è§„åˆ’é—®é¢˜çš„åŸºæœ¬å½¢æ€ï¼šå½“å‰çŠ¶æ€çš„æ‰€æœ‰å€¼å¯ä»¥ä»ä¸Šä¸€ä¸ªçŠ¶æ€çš„æŸä¸ªè¿ç»­çš„æ®µçš„å€¼å¾—åˆ°ï¼Œè¦å¯¹è¿™ä¸ªè¿ç»­çš„æ®µè¿›è¡Œ RMQ æ“ä½œï¼Œç›¸é‚»çŠ¶æ€çš„æ®µçš„å·¦å³åŒºé—´æ»¡è¶³éé™çš„å…³ç³»ã€‚ //https://codeforces.com/problemset/problem/372/C /* é¢˜æ„ï¼šä½ åœ¨ä¸€ä¸ªé•¿åº¦ä¸ºnçš„å¤§è¡—ä¸Šï¼Œæœ‰mæ¬¡çƒŸèŠ±è¡¨æ¼”ï¼Œåˆ†åˆ«åœ¨t[i]æ—¶åˆ»ä¸Šæ¼”ï¼Œå‡è®¾ä½ ç°åœ¨ç«™åœ¨ä½ç½®xä¸Šï¼Œä½ è§‚çœ‹ç¬¬iæ¬¡çƒŸèŠ±è¡¨æ¼”ï¼Œå¯ä»¥è·å¾—b[i]-abs(a[i]-x) çš„å¹¸ç¦å€¼ï¼ˆä¸èƒ½ä¸çœ‹ï¼‰ï¼Œç„¶åä½ æ¯ä¸€ä¸ªæ—¶åˆ»å¯ä»¥ç§»åŠ¨dä¸ªå•ä½é•¿åº¦ï¼Œå¼€å§‹ä½ å¯ä»¥åœ¨ä»»æ„ä½ç½®ï¼Œä¸èƒ½èµ°å‡ºå¤§è¡—ï¼Œé—®ä½ æœ€å¤šèƒ½è·å¾—å¤šå°‘å¹¸ç¦å€¼ */ int n, m, d, a[N], b[N], t[N]; int q[N]; ll dp[2][N]; void solve()//æ—¶é—´å¤æ‚åº¦O(nm) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; t[i]; int cur = 1; for(int i = 1; i &lt;= m; i++) { int l = 1, r = 0, k = 1; for(int j = 1; j &lt;= n; j++) { for(; k &lt;= min(1ll * n, j + 1ll * d * (t[i] - t[i - 1])); k++) { while(l &lt;= r &amp;&amp; dp[cur ^ 1][q[r]] &lt; dp[cur ^ 1][k]) r--; q[++r] = k; } while(l &lt;= r &amp;&amp; q[l] &lt; max(1ll, j - 1ll * d * (t[i] - t[i - 1]))) l++; dp[cur][j] = dp[cur ^ 1][q[l]] + b[i] - abs(a[i] - j); } cur ^= 1; } ll ans = -INF; for(int j = 1; j &lt;= n; j++) ans = max(ans, dp[cur ^ 1][j]); cout &lt;&lt; ans &lt;&lt; '\\n'; } å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–å¤šé‡èƒŒåŒ… //n ç§ç‰©å“ï¼ŒèƒŒåŒ…å®¹é‡ mï¼Œç¬¬ i ç§ç‰©å“æœ€å¤šæœ‰ s[i] ä»¶ï¼Œæ¯ä»¶ä½“ç§¯æ˜¯ v[i]ï¼Œä»·å€¼æ˜¯ w[i]ã€‚ const int N = 1e3 + 10; int n, m; int f[2][20005], que[20005]; void solve()//æ—¶é—´å¤æ‚åº¦O(nm)ï¼ŒO(ç‰©å“ç§æ•° * èƒŒåŒ…å®¹ç§¯) { cin &gt;&gt; n &gt;&gt; m; int cur = 1; for(int i = 1; i &lt;= n; i++) { int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int r = 0; r &lt; v; r++)//æšä¸¾ä½™æ•° { for(int k = 0, head = 1, tail = 0; r + k * v &lt;= m; k++) { while(head &lt;= tail &amp;&amp; k - que[head] &gt; s) head++; while(head &lt;= tail &amp;&amp; f[cur ^ 1][r + que[tail] * v] - que[tail] * w &lt;= f[cur ^ 1][r + k * v] - k * w) tail--; que[++tail] = k; f[cur][r + k * v] = f[cur ^ 1][r + que[head] * v] + (k - que[head]) * w; } } cur ^= 1; } cout &lt;&lt; f[cur ^ 1][m] &lt;&lt; '\\n'; } æ–œç‡ä¼˜åŒ–DP æœ€å°å€¼ç»´æŠ¤ä¸‹å‡¸åŒ…ï¼Œæœ€å¤§å€¼ç»´æŠ¤ä¸Šå‡¸åŒ… $x$ å•è°ƒï¼Œä½†æ–œç‡ä¸å•è°ƒï¼Œå¯ä»¥äºŒåˆ†åˆ‡ç‚¹ å¯ä»¥å®å®šä¹‰/å‡½æ•° $x , y$ æ¥å‡å°‘å†…å­˜ å®å®šä¹‰æ—¶ï¼Œè¡¨è¾¾å¼æœ€å¤–é¢è®°å¾—åŠ æ‹¬å·ï¼Œä¸ç„¶è¿ç®—é¡ºåºä¸å¯¹ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ //https://loj.ac/p/10188 /* f[i] = min{f[j] + (i - (j + 1) + pre[i] - pre[j] - C) ^ 2} ä»¤ L = C + 1, s[i] = pre[i] + i åˆ™ f[i] = min{f[j] + (s[i] - s[j] - L) ^ 2} å°†ä¸jæ— å…³çš„ç§»åˆ°å¤–é¢ åˆ™ f[i] - (s[i] - L) ^ 2 = min{f[j] + s[j] ^ 2 + 2 * s[j] * (L - s[i])} å›  y = kx + b, ç§»é¡¹å¾— b = y - kx å°†ä¸ j æœ‰å…³çš„ä¿¡æ¯è¡¨ç¤ºä¸º y çš„å½¢å¼ æŠŠåŒæ—¶ä¸ i, j ç›¸å…³çš„ä¿¡æ¯è¡¨ç¤ºä¸º kx æŠŠéœ€è¦æœ€å°åŒ–çš„ä¿¡æ¯(ä¸ i æœ‰å…³çš„ä¿¡æ¯)è¡¨ç¤ºä¸º b çš„å½¢å¼ï¼Œ ä¹Ÿå°±æ˜¯æˆªè· x[j] = s[j] y[j] = f[j] + s[j] ^ 2 k[i] = -2(L - s[i]) b[i] = f[i] - (s[i] - L) ^ 2 åˆ™ b[i] = min{y[j] - k[i] * x[j]} æŠŠ x, y çœ‹åšäºŒç»´å¹³é¢ä¸Šçš„ç‚¹ï¼Œé‚£é—®é¢˜å°±è½¬åŒ–ä¸ºæœ€å°åŒ–æˆªè· ***å¯ä»¥çœ‹å‡ºåœ¨æœ¬é¢˜æ–°åŠ å…¥çš„å†³ç­–ç‚¹çš„æ¨ªåæ ‡å•è°ƒï¼Œæ–œç‡kä¹Ÿå•è°ƒ å°†ä¸€æ¡æ–œç‡ä¸º k[i] çš„ç›´çº¿ä»ä¸‹å¾€ä¸Šç§»åŠ¨ï¼Œç¬¬ä¸€ä¸ªç¢°åˆ°çš„ç‚¹ p å°±æ˜¯æœ€ä¼˜è½¬ç§»ç‚¹ æ‰€ä»¥åªæœ‰ä¸‹å‡¸åŒ…ä¸Šçš„ç‚¹å¯èƒ½æˆä¸ºè½¬ç§»ç‚¹ è€ƒè™‘ä½¿ç”¨å•è°ƒé˜Ÿåˆ—ç»´æŠ¤ä¸‹å‡¸å£³ä¸Šçš„ç‚¹ é˜Ÿåˆ—ä¸­çš„ç‚¹æ»¡è¶³æ¡ä»¶ K(i - 1, i) &lt; K(i, i + 1) åŒæ—¶ç»´æŠ¤ä¸€ä¸ªæŒ‡é’ˆ p ç»´æŠ¤æœ€ä¼˜è½¬ç§»ç‚¹ï¼Œå› ä¸º k[i] é€’å¢ï¼Œ æ‰€ä»¥ p ä¹Ÿé€’å¢ åœ¨æ’å…¥ä¸€ä¸ªç‚¹æ—¶ï¼Œ è¦åˆ¤æ–­é˜Ÿå°¾è¿˜æ˜¯å¦æ˜¯ä¸‹å‡¸å£³ä¸Šçš„ç‚¹ï¼Œè‹¥æ»¡è¶³ K(r-1, r) &lt;= K(r, i) åˆ™æ˜¯ä¸‹å‡¸å£³ä¸Šçš„ç‚¹ */ int n, L; ll pre[N], s[N]; int que[N], head, p; ll x[N], y[N], f[N]; void solve() { cin &gt;&gt; n &gt;&gt; L; L++; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; pre[i]; pre[i] += pre[i - 1]; s[i] = pre[i] + i; } que[++head] = 0; p = 1; for(int i = 1; i &lt;= n; i++) { ll k = -2 * (L - s[i]); while(p &lt; head &amp;&amp; k * (x[que[p + 1]] - x[que[p]]) &gt;= y[que[p + 1]] - y[que[p]]) p++;//ç»´æŠ¤æœ€å¤§å€¼å°±æŠŠ &gt;= æ”¹æˆ &lt;= f[i] = y[que[p]] - k * x[que[p]] + (s[i] - L) * (s[i] - L); x[i] = s[i]; y[i] = f[i] + s[i] * s[i]; while(p &lt; head &amp;&amp; (y[que[head]] - y[que[head-1]]) * (x[i] - x[que[head]]) &gt;= (y[i] - y[que[head]]) * (x[que[head]] - x[que[head-1]])) head--;//ç»´æŠ¤æœ€å¤§å€¼å°±æŠŠ &gt;= æ”¹æˆ &lt;= que[++head] = i; } cout &lt;&lt; f[n] &lt;&lt; '\\n'; } å‡¸åŒ…ä¸Šç›¸é‚»ä¸¤ç‚¹çš„æ–œç‡å…·æœ‰å•è°ƒæ€§ å¯ä»¥å°†æ–œç‡ä¼˜åŒ–ä¸äºŒåˆ†/åˆ†æ²»/æ•°æ®ç»“æ„ç­‰ç»“åˆï¼Œæ¥ç»´æŠ¤æ€§è´¨ä¸é‚£ä¹ˆå¥½ï¼ˆç¼ºå°‘ä¸€äº›å•è°ƒæ€§æ€§è´¨ï¼‰çš„ DP æ–¹ç¨‹ CDQåˆ†æ²»ï¼Œå…ˆè§£å†³[l, mid]ï¼Œåœ¨è§£å†³[mid + 1, r]ä»[l,mid]çš„è½¬ç§»ï¼ˆæ­¤æ—¶[l,mid]æ˜¯ä¸€ä¸ªé™æ€å‡¸å£³,ä¸ä¼šæœ‰æ–°çš„å†³ç­–ç‚¹åŠ å…¥ï¼Œç»´æŠ¤å¥½å‡¸åŒ…åå¯ä»¥å°†[mid+1,r]å†…æŒ‰æ–œç‡æ’åºè§£å†³è½¬ç§»ï¼‰ï¼Œæœ€åè§£å†³[mid+1,r] æ•°ä½DP //https://www.luogu.com.cn/problem/P2602 //æ¯ä¸ªæ•°ç å„å‡ºç°äº†å¤šå°‘æ¬¡ã€‚ int num[20]; ll pow10[20], now[20]; ll f[20]; ll dfs(int pos, int dig, bool lead, bool limit) { if(pos == 0) return 0; if(!lead &amp;&amp; !limit &amp;&amp; f[pos] != -1) return f[pos]; ll ans = 0; int up = limit ? num[pos] : 9; for(int i = 0; i &lt;= up; i++) { if(lead &amp;&amp; i == 0) ans += dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); else if(i == dig &amp;&amp; limit &amp;&amp; i == up)//è´¡çŒ®æ˜¯åé¢çš„æ•°çš„æ•°é‡ ans += now[pos - 1] + 1 + dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); else if(i == dig) ans += pow10[pos - 1] + dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); else ans += dfs(pos - 1, dig, lead &amp;&amp; i == 0, limit &amp;&amp; i == up); } if(!lead &amp;&amp; !limit) f[pos] = ans; return ans; } ll run(ll x, int dig) { int len = 0; while(x) { num[++len] = x % 10; x /= 10; now[len] = now[len - 1] + pow10[len - 1] * num[len]; } return dfs(len, dig, true, true); } void solve() { ll l, r; cin &gt;&gt; l &gt;&gt; r; pow10[0] = 1; for(int i = 1; i &lt;= 15; i++) pow10[i] = pow10[i - 1] * 10; memset(f, -1, sizeof f); for(int i = 0; i &lt;= 9; i++) cout &lt;&lt; run(r, i) - run(l - 1, i) &lt;&lt; &quot; \\n&quot;[i == 9]; } //https://vjudge.net/problem/HDU-2089 //æ•°å­—ä¸­ä¸èƒ½æœ‰4æˆ–62 int num[20]; ll f[20][2]; ll dfs(int pos, int pre, bool sta, bool limit)//éœ€è¦staæ˜¯å› ä¸ºè¿™ä¸€ä½æ˜¯å¦æ”¾ 6 å¯¹åé¢è®¡æ•°æœ‰å½±å“ { if (pos == 0) return 1; if (!limit &amp;&amp; f[pos][sta] != -1) return f[pos][sta]; ll ans = 0; int up = limit ? num[pos] : 9; for (int i = 0; i &lt;= up; i++) { if(i == 4 || pre == 6 &amp;&amp; i == 2) continue; ans += dfs(pos - 1, i, i == 6, limit &amp;&amp; i == up); } if (!limit) f[pos][sta] = ans; return ans; } ll run(ll x) { int len = 0; while (x) { num[++len] = x % 10; x /= 10; } return dfs(len, 0, 0, 1); } void solve() { memset(f, -1, sizeof f);//åˆå§‹åŒ–æœ‰äº›é¢˜å¯ä»¥æ”¾å¤šç»„è¾“å…¥å¤–é¢ã€‚è¿™ä¸€ç‚¹æ˜¯ä¸€ä¸ªæ•°ä½ç‰¹ç‚¹ï¼Œä½¿ç”¨çš„æ¡ä»¶æ˜¯ï¼šçº¦æŸæ¡ä»¶æ˜¯æ¯ä¸ªæ•°è‡ªèº«çš„å±æ€§ï¼Œè€Œä¸è¾“å…¥æ— å…³ã€‚ä¾‹å¦‚æœ‰çš„é¢˜æ¯æ¬¡æ¨¡æ•°ä¸åŒï¼Œåˆ™ä¸èƒ½å¼€åœ¨å¤–é¢ ll l, r; while (cin &gt;&gt; l &gt;&gt; r, l || r) cout &lt;&lt; run(r) - run(l - 1) &lt;&lt; '\\n'; } WQSäºŒåˆ† /* é¢˜æ„ï¼šæœ‰ä¸€é¢—å¸¦è¾¹æƒçš„æ ‘ï¼Œä»ä¸­é€‰å‡ºç¡®å®šçš„ K æ¡é¡¶ç‚¹ä¸ç›¸äº¤çš„è¾¹ï¼Œä½¿è¿™ K æ¡è¾¹çš„æƒå€¼å’Œæœ€å¤§ ç”¨ WQSäºŒåˆ† å°†é€‰å‡ºæ°å¥½ K æ¡è¾¹è½¬åŒ–ä¸ºé€‰ä»»æ„æ¡è¾¹çš„é—®é¢˜ååšæ ‘å½¢DPå³å¯ */ #define int ll pair&lt;ll, int&gt; operator + (const pair&lt;ll, int&gt; &amp;a, const pair&lt;ll,int&gt; &amp;b){ return {a.first + b.first, a.second + b.second}; } vector&lt;array&lt;int, 2&gt;&gt; g[N]; pair&lt;ll, int&gt; f[N][2]; void dfs(int x, int fa, int c) { f[x][0] = f[x][1] = {0, 0}; for(auto &amp;[to, w] : g[x]) { if(to == fa) continue; dfs(to, x, c); f[x][1] = max(f[x][1] + max(f[to][0], f[to][1]), f[x][0] + f[to][0] + make_pair(w - c, 1)); f[x][0] = f[x][0] + max(f[to][0], f[to][1]); } } void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt; n; i++) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back({v, w}); g[v].push_back({u, w}); } int l = -1e13, r = 1e13;//ç­”æ¡ˆå€¼åŸŸ ll ans = -INF; while(l &lt;= r) { int c = (l + r) / 2; dfs(1, -1, c); auto [res, cnt] = max(f[1][0], f[1][1]);//å› ä¸ºä¸‹é¢æ˜¯ cnt &gt;=k ï¼Œæ‰€ä»¥ç›¸åŒè´¡çŒ®ä¸‹é€‰cntå¤§çš„ if(cnt &gt;= k) { ans = res + 1ll * k * c;// è¦åŠ  k * cï¼Œè€Œä¸æ˜¯ cnt * cï¼Œ å½“ k å’Œ k + 1 å¤„æ–œç‡ç›¸åŒæ—¶ï¼ŒDPå‡ºçš„æ•°é‡ç­”æ¡ˆæ˜¯ k + 1 æ˜¯çš„ï¼Œä½†æƒå€¼ç­”æ¡ˆä¸ k å…±äº« l = c + 1; } else r = c - 1; } if(ans == -INF) cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; '\\n'; else cout &lt;&lt; ans &lt;&lt; '\\n'; } æ ‘å½¢DPä»¥ä»»æ„ç‚¹ä¸å…¶ä»–æ‰€æœ‰ç‚¹çš„æœ€å¤§è·ç¦» void dfs1(int x, int fa)//f1[x] è®°å½•xçš„å­æ ‘ä¸­ä¸xçš„æœ€å¤§è·ç¦»ï¼Œf2[x]è®°å½•éxå­æ ‘ä¸­çš„ç‚¹åˆ°xçš„æœ€å¤§è·ç¦» { f1[x] = f2[x] = 0; for(auto &amp;to : g[x]) { if(to == fa) continue; dfs1(to, x); f1[x] = max(f1[x], f1[to] + 1); } } int pre[N], suf[N]; void dfs2(int x, int fa) { vector&lt;int&gt; v(1);//ä¸‹æ ‡ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥å…ˆæ”¾å…¥ä¸€ä¸ªå…ƒç´  for(auto &amp;to : g[x]) if(to != fa) v.push_back(to); int n = v.size() - 1; pre[0] = suf[n + 1] = 0; for(int i = 1; i &lt;= n; i++) pre[i] = max(pre[i - 1], f1[v[i]]); for(int i = n; i &gt;= 1; i--) suf[i] = max(suf[i + 1], f1[v[i]]); for(int i = 1; i &lt;= n; i++) { if(n &gt;= 2) f2[v[i]] = max(pre[i - 1], suf[i + 1]) + 2; f2[v[i]] = max(f2[v[i]], f2[x] + 1); } for(auto &amp;to : g[x]) if(to != fa) dfs2(to, x); } SOSDP è§£å†³æ±‚ $S$ çš„è´¡çŒ®æ˜¯æ‰€æœ‰å­é›†è´¡çŒ®å’Œçš„é—®é¢˜ //é¢˜æ„ï¼šç»™å®šä¸€ä¸ªæ•°ç»„ aï¼Œæ±‚æœ‰å¤šå°‘ä¸ª (i, j) ä½¿å¾— a[i] | a[j] = a[i] void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; cnt(1e6 + 10); for(int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; cnt[x]++; } auto f = cnt; for(int i = 0; i &lt;= 20; i++) for(int j = 1; j &lt;= 1e6; j++) if(j &gt;&gt; i &amp; 1) f[j] += f[j ^ (1 &lt;&lt; i)];//åœ¨ä¸€ä¸ª i ä¸‹ï¼Œä¸€ä¸ªæ•°åªä¼šè¢«è½¬ç§»ä¸€æ¬¡ ll ans = 0; for(int i = 1; i &lt;= 1e6; i++) ans += 1ll * cnt[i] * f[i]; cout &lt;&lt; ans &lt;&lt; '\\n'; } ä»è‡ªå·±çš„å› å­è½¬ç§» for(int fac = 1; fac &lt;= n; fac++)//æšä¸¾å› å­ for(int i = fac; i &lt;= n; i += fac) f[i] += f[fac] + w;","categories":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}],"tags":[{"name":"æ¿å­","slug":"æ¿å­","permalink":"/tags/æ¿å­/"}],"keywords":[{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"/categories/æ¨¡æ¿/"}]}]}